#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: bp_ac_BaseDoor

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "AkAudio_structs.hpp"
#include "FCT_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass bp_ac_BaseDoor.bp_ac_BaseDoor_C
// 0x01C0 (0x0400 - 0x0240)
class Abp_ac_BaseDoor_C final : public ADoor
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x0240(0x0008)(ZeroConstructor, Transient, DuplicateTransient, UObjectWrapper)
	class UInteractionProgressBarCreator*         InteractionProgressBarCreator;                     // 0x0248(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UContextStaticMeshComponent*            Open_Cheat_CSM;                                    // 0x0250(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UForceOpenIntaractionComponent_C*       ForceOpenIntaractionComponent;                     // 0x0258(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UContextStaticMeshComponent*            Force_Open_CSM;                                    // 0x0260(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UCheatInteractionComponent*             Cheat_Interaction;                                 // 0x0268(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UStaticMeshComponent*                   DP;                                                // 0x0270(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UArrowComponent*                        A;                                                 // 0x0278(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class Ubpc_sc_PointOfInterest_C*              Point_Of_Intrest_Mark;                             // 0x0280(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class Ubpc_ac_Hacking_C*                      Hacking_Door;                                      // 0x0288(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class Ubpc_ac_Opener_C*                       Opener_Door;                                       // 0x0290(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class Ubpc_ac_Lock_C*                         Lock_Door;                                         // 0x0298(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class Ubpc_ac_Sabotage_C*                     Sabotage_Door;                                     // 0x02A0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UAkComponent*                           Ak;                                                // 0x02A8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBoxComponent*                          ProximittyTrigger;                                 // 0x02B0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	bool                                          IsOpenedCosmetic;                                  // 0x02B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          AudioOpen;                                         // 0x02C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAkAudioEvent*                          AudioOpened;                                       // 0x02C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAkAudioEvent*                          AudioClose;                                        // 0x02D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAkAudioEvent*                          AudioClosed;                                       // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         TimeWindow_UnlockByTiming;                         // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, bool>                             ClickedButtons;                                    // 0x02E8(0x0050)(Edit, BlueprintVisible, AdvancedDisplay)
	struct FTimerHandle                           UnlockByTimingTimerHandle;                         // 0x0338(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
	TArray<int32>                                 ButtonIDSequence;                                  // 0x0340(0x0010)(Edit, BlueprintVisible, AdvancedDisplay)
	int32                                         SequenceStepIndex;                                 // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
	bool                                          SequencePartialSuccess;                            // 0x0354(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay)
	uint8                                         Pad_355[0x3];                                      // 0x0355(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, bool>                             UnlockedKeyCardSlots;                              // 0x0358(0x0050)(Edit, BlueprintVisible, AdvancedDisplay)
	bool                                          Debugging;                                         // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor)
	bool                                          ProximityCanOpenServer;                            // 0x03A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          CanCloseServer;                                    // 0x03AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3AB[0x5];                                      // 0x03AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           AutoCloseTimerHandle;                              // 0x03B0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UCurveFloat*                            DoorOpenCurve;                                     // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DoorLinearOpenAmount;                              // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DoorOpenSpeed;                                     // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          OpenWhenHacked;                                    // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3C9[0x3];                                      // 0x03C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TriggerBoxExtent;                                  // 0x03CC(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FLinearColor                           Debug_Trigger_Floor_Color;                         // 0x03D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          Repaired;                                          // 0x03E8(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor)
	bool                                          Reparing;                                          // 0x03E9(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor)
	bool                                          Neutral;                                           // 0x03EA(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor)
	uint8                                         Pad_3EB[0x1];                                      // 0x03EB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayBeforeClosingAfterForce;                      // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          WrenchOpen;                                        // 0x03F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3F1[0x7];                                      // 0x03F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AButton_DoorOpener_C*                   AdditionalButtonToActivateWhenClosed;              // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void ExecuteUbergraph_bp_ac_BaseDoor(int32 EntryPoint);
	void Wrench_It();
	void Open_And_Stay_Open();
	void BndEvt__ForceOpenIntaractionComponent_K2Node_ComponentBoundEvent_7_InteractionEndedDelegate__DelegateSignature(const struct FInteractionPayload& Payload, bool WasCancelled);
	void BndEvt__ForceOpenIntaractionComponent_K2Node_ComponentBoundEvent_6_InteractionDelegate__DelegateSignature(const struct FInteractionPayload& Payload);
	void BndEvt__ForceOpenIntaractionComponent_K2Node_ComponentBoundEvent_0_InteractionSuccessfulDelegate__DelegateSignature();
	void BndEvt__Force_Open_Interaction_K2Node_ComponentBoundEvent_3_InteractionDelegate__DelegateSignature(const struct FInteractionPayload& Payload);
	void BndEvt__Opener_Door_K2Node_ComponentBoundEvent_5_OnOpenStateChanged__DelegateSignature(bool IsOpening);
	void _Closed();
	void Disable_Personoid_Forcing();
	void Set_Neutral_Light();
	void Set_Reparing_Light();
	void Set_Repaired_Light();
	void Close_After_Force_Open();
	void Server_Remove_Force_Open_Tag();
	void IncorrectlySolved(class APlayerState* SolvingPlayerPlayerState);
	void CorrectlySolved(class APlayerState* SolvingPlayerPlayerState);
	void HandleHackingStateChanged(bool IsHacked);
	void HandleDoorOpenStateChanged(bool IsOpened);
	void ReceiveTick(float DeltaSeconds);
	void HandleAutoCloseServer();
	void HandleFailCooldownUpdate(float CooldownRemaining);
	void InitDoor(int32 Buttons_attached_by_last_index);
	void DoorButtonPressedServer(int32 ButtonID, class AActor* PressingPawn);
	void HandleLockedStateChanged(bool IsLocked, bool IsOnCooldown);
	void HandleSabotageCooldownUpdate(float CooldownLeft);
	void HandleSabotageStateChange(bool IsSabotaged);
	void Audio_Closed();
	void Audio_Opened();
	void Audio_Open();
	void Audio_Close();
	void Door_Closed();
	void Door_Opened();
	void Door_Close_Cosmetic();
	void Door_Open_Cosmetic();
	void BndEvt__ProximityCollider_K2Node_ComponentBoundEvent_4_ComponentEndOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void BndEvt__ProximityCollider_K2Node_ComponentBoundEvent_1_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void ReceiveBeginPlay();
	void UserConstructionScript();
	void AnyCharacterWithinTrigger(bool* CharacerFound);
	void BindToSabotageComponentEvents();
	void BindToDoorLockComponentEvents();
	void PressedUnlockByTiming(int32 ButtonID, bool* Unlocked);
	void FailedUnlockByTiming();
	void PressedUnlockBySequence(int32 ButtonID, bool* Unlocked);
	void FailedUnlockBySequence();
	void KeyCardInserted(int32 ButtonID, bool* Unlocked);
	void CalculateDoorPosition(bool Open, float* CurvedOpenAmount);
	void MoveDoors(float CurvedMovePositionNormalized);
	void DoProximityCanOpenServer();
	void BindToDoorOpenerComponentEvents();
	void BindToHackingComponentEvents();
	void OnRep_Repaired();
	void OnRep_Reparing();
	void OnRep_Neutral();

	void IsACharacterOverlapping(TArray<class UPrimitiveComponent*>& OtherComp, bool* Return_Value) const;
	bool CanAutoClose() const;
	int32 GetKeyCardSlotsCount() const;
	void IsOpenedWithKeyCards(bool* Return_Value) const;

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"bp_ac_BaseDoor_C">();
	}
	static class Abp_ac_BaseDoor_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<Abp_ac_BaseDoor_C>();
	}
};
static_assert(alignof(Abp_ac_BaseDoor_C) == 0x000008, "Wrong alignment on Abp_ac_BaseDoor_C");
static_assert(sizeof(Abp_ac_BaseDoor_C) == 0x000400, "Wrong size on Abp_ac_BaseDoor_C");
static_assert(offsetof(Abp_ac_BaseDoor_C, UberGraphFrame) == 0x000240, "Member 'Abp_ac_BaseDoor_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, InteractionProgressBarCreator) == 0x000248, "Member 'Abp_ac_BaseDoor_C::InteractionProgressBarCreator' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Open_Cheat_CSM) == 0x000250, "Member 'Abp_ac_BaseDoor_C::Open_Cheat_CSM' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, ForceOpenIntaractionComponent) == 0x000258, "Member 'Abp_ac_BaseDoor_C::ForceOpenIntaractionComponent' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Force_Open_CSM) == 0x000260, "Member 'Abp_ac_BaseDoor_C::Force_Open_CSM' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Cheat_Interaction) == 0x000268, "Member 'Abp_ac_BaseDoor_C::Cheat_Interaction' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, DP) == 0x000270, "Member 'Abp_ac_BaseDoor_C::DP' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, A) == 0x000278, "Member 'Abp_ac_BaseDoor_C::A' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Point_Of_Intrest_Mark) == 0x000280, "Member 'Abp_ac_BaseDoor_C::Point_Of_Intrest_Mark' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Hacking_Door) == 0x000288, "Member 'Abp_ac_BaseDoor_C::Hacking_Door' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Opener_Door) == 0x000290, "Member 'Abp_ac_BaseDoor_C::Opener_Door' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Lock_Door) == 0x000298, "Member 'Abp_ac_BaseDoor_C::Lock_Door' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Sabotage_Door) == 0x0002A0, "Member 'Abp_ac_BaseDoor_C::Sabotage_Door' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Ak) == 0x0002A8, "Member 'Abp_ac_BaseDoor_C::Ak' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, ProximittyTrigger) == 0x0002B0, "Member 'Abp_ac_BaseDoor_C::ProximittyTrigger' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, IsOpenedCosmetic) == 0x0002B8, "Member 'Abp_ac_BaseDoor_C::IsOpenedCosmetic' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, AudioOpen) == 0x0002C0, "Member 'Abp_ac_BaseDoor_C::AudioOpen' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, AudioOpened) == 0x0002C8, "Member 'Abp_ac_BaseDoor_C::AudioOpened' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, AudioClose) == 0x0002D0, "Member 'Abp_ac_BaseDoor_C::AudioClose' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, AudioClosed) == 0x0002D8, "Member 'Abp_ac_BaseDoor_C::AudioClosed' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, TimeWindow_UnlockByTiming) == 0x0002E0, "Member 'Abp_ac_BaseDoor_C::TimeWindow_UnlockByTiming' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, ClickedButtons) == 0x0002E8, "Member 'Abp_ac_BaseDoor_C::ClickedButtons' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, UnlockByTimingTimerHandle) == 0x000338, "Member 'Abp_ac_BaseDoor_C::UnlockByTimingTimerHandle' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, ButtonIDSequence) == 0x000340, "Member 'Abp_ac_BaseDoor_C::ButtonIDSequence' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, SequenceStepIndex) == 0x000350, "Member 'Abp_ac_BaseDoor_C::SequenceStepIndex' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, SequencePartialSuccess) == 0x000354, "Member 'Abp_ac_BaseDoor_C::SequencePartialSuccess' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, UnlockedKeyCardSlots) == 0x000358, "Member 'Abp_ac_BaseDoor_C::UnlockedKeyCardSlots' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Debugging) == 0x0003A8, "Member 'Abp_ac_BaseDoor_C::Debugging' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, ProximityCanOpenServer) == 0x0003A9, "Member 'Abp_ac_BaseDoor_C::ProximityCanOpenServer' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, CanCloseServer) == 0x0003AA, "Member 'Abp_ac_BaseDoor_C::CanCloseServer' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, AutoCloseTimerHandle) == 0x0003B0, "Member 'Abp_ac_BaseDoor_C::AutoCloseTimerHandle' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, DoorOpenCurve) == 0x0003B8, "Member 'Abp_ac_BaseDoor_C::DoorOpenCurve' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, DoorLinearOpenAmount) == 0x0003C0, "Member 'Abp_ac_BaseDoor_C::DoorLinearOpenAmount' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, DoorOpenSpeed) == 0x0003C4, "Member 'Abp_ac_BaseDoor_C::DoorOpenSpeed' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, OpenWhenHacked) == 0x0003C8, "Member 'Abp_ac_BaseDoor_C::OpenWhenHacked' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, TriggerBoxExtent) == 0x0003CC, "Member 'Abp_ac_BaseDoor_C::TriggerBoxExtent' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Debug_Trigger_Floor_Color) == 0x0003D8, "Member 'Abp_ac_BaseDoor_C::Debug_Trigger_Floor_Color' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Repaired) == 0x0003E8, "Member 'Abp_ac_BaseDoor_C::Repaired' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Reparing) == 0x0003E9, "Member 'Abp_ac_BaseDoor_C::Reparing' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, Neutral) == 0x0003EA, "Member 'Abp_ac_BaseDoor_C::Neutral' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, DelayBeforeClosingAfterForce) == 0x0003EC, "Member 'Abp_ac_BaseDoor_C::DelayBeforeClosingAfterForce' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, WrenchOpen) == 0x0003F0, "Member 'Abp_ac_BaseDoor_C::WrenchOpen' has a wrong offset!");
static_assert(offsetof(Abp_ac_BaseDoor_C, AdditionalButtonToActivateWhenClosed) == 0x0003F8, "Member 'Abp_ac_BaseDoor_C::AdditionalButtonToActivateWhenClosed' has a wrong offset!");

}

