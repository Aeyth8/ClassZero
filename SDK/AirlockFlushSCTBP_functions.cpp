#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AirlockFlushSCTBP

#include "Basic.hpp"

#include "AirlockFlushSCTBP_classes.hpp"
#include "AirlockFlushSCTBP_parameters.hpp"


namespace SDK
{

// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.ExecuteUbergraph_AirlockFlushSCTBP
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockFlushSCTBP_C::ExecuteUbergraph_AirlockFlushSCTBP(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "ExecuteUbergraph_AirlockFlushSCTBP");

	Params::AirlockFlushSCTBP_C_ExecuteUbergraph_AirlockFlushSCTBP Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.StartExecutionCountdown
// (BlueprintCallable, BlueprintEvent)

void AAirlockFlushSCTBP_C::StartExecutionCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "StartExecutionCountdown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.InvalidateFlushTimer
// (BlueprintCallable, BlueprintEvent)

void AAirlockFlushSCTBP_C::InvalidateFlushTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "InvalidateFlushTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.TimerExpired
// (BlueprintCallable, BlueprintEvent)

void AAirlockFlushSCTBP_C::TimerExpired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "TimerExpired");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.FlushDoomed
// (BlueprintCallable, BlueprintEvent)

void AAirlockFlushSCTBP_C::FlushDoomed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "FlushDoomed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.CloseDoor
// (BlueprintCallable, BlueprintEvent)

void AAirlockFlushSCTBP_C::CloseDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "CloseDoor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.OpenDoorMulticast
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AAirlockFlushSCTBP_C::OpenDoorMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "OpenDoorMulticast");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.SetupFlush
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ACharacter*>               DoomedCharacters_0                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AAirlockFlushSCTBP_C::SetupFlush(const TArray<class ACharacter*>& DoomedCharacters_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "SetupFlush");

	Params::AirlockFlushSCTBP_C_SetupFlush Parms{};

	Parms.DoomedCharacters_0 = std::move(DoomedCharacters_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.Timeline_0__UpdateFunc
// (BlueprintEvent)

void AAirlockFlushSCTBP_C::Timeline_0__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "Timeline_0__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.Timeline_0__FinishedFunc
// (BlueprintEvent)

void AAirlockFlushSCTBP_C::Timeline_0__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "Timeline_0__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.Server_LatentInteractionSuccess
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InteractingActorIsCharacter                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           InteractingInstigator                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           InteractionFacilitator                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Void                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockFlushSCTBP_C::Server_LatentInteractionSuccess(bool InteractingActorIsCharacter, class AActor* InteractingInstigator, class AActor* InteractionFacilitator, bool* Void)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "Server_LatentInteractionSuccess");

	Params::AirlockFlushSCTBP_C_Server_LatentInteractionSuccess Parms{};

	Parms.InteractingActorIsCharacter = InteractingActorIsCharacter;
	Parms.InteractingInstigator = InteractingInstigator;
	Parms.InteractionFacilitator = InteractionFacilitator;

	UObject::ProcessEvent(Func, &Parms);

	if (Void != nullptr)
		*Void = Parms.Void;
}


// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.InteractReleased
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InteractingActorIsCharacter                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Void                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockFlushSCTBP_C::InteractReleased(bool InteractingActorIsCharacter, class AActor* InteractingActor, bool* Void)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "InteractReleased");

	Params::AirlockFlushSCTBP_C_InteractReleased Parms{};

	Parms.InteractingActorIsCharacter = InteractingActorIsCharacter;
	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);

	if (Void != nullptr)
		*Void = Parms.Void;
}


// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.GetCanInteract
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsSimulated                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    InteractingActorIsCharacter                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CanInteract                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockFlushSCTBP_C::GetCanInteract(bool IsSimulated, bool InteractingActorIsCharacter, class AActor* InteractingActor, bool* CanInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "GetCanInteract");

	Params::AirlockFlushSCTBP_C_GetCanInteract Parms{};

	Parms.IsSimulated = IsSimulated;
	Parms.InteractingActorIsCharacter = InteractingActorIsCharacter;
	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);

	if (CanInteract != nullptr)
		*CanInteract = Parms.CanInteract;
}


// Function AirlockFlushSCTBP.AirlockFlushSCTBP_C.InteractPressed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InteractingActorIsCharacter                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       InteractedHitResult                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockFlushSCTBP_C::InteractPressed(bool InteractingActorIsCharacter, class AActor* InteractingActor, const struct FHitResult& InteractedHitResult, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockFlushSCTBP_C", "InteractPressed");

	Params::AirlockFlushSCTBP_C_InteractPressed Parms{};

	Parms.InteractingActorIsCharacter = InteractingActorIsCharacter;
	Parms.InteractingActor = InteractingActor;
	Parms.InteractedHitResult = std::move(InteractedHitResult);

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}

}

