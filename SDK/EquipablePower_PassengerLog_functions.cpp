#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: EquipablePower_PassengerLog

#include "Basic.hpp"

#include "EquipablePower_PassengerLog_classes.hpp"
#include "EquipablePower_PassengerLog_parameters.hpp"


namespace SDK
{

// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.ExecuteUbergraph_EquipablePower_PassengerLog
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AEquipablePower_PassengerLog_C::ExecuteUbergraph_EquipablePower_PassengerLog(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "ExecuteUbergraph_EquipablePower_PassengerLog");

	Params::EquipablePower_PassengerLog_C_ExecuteUbergraph_EquipablePower_PassengerLog Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.On Character Destiny
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FDestiny                         UltimateDestiny                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool                                    IsPersonoid                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AEquipablePower_PassengerLog_C::On_Character_Destiny(const struct FDestiny& UltimateDestiny, bool IsPersonoid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "On Character Destiny");

	Params::EquipablePower_PassengerLog_C_On_Character_Destiny Parms{};

	Parms.UltimateDestiny = std::move(UltimateDestiny);
	Parms.IsPersonoid = IsPersonoid;

	UObject::ProcessEvent(Func, &Parms);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.Initialize
// (Event, Protected, BlueprintEvent)

void AEquipablePower_PassengerLog_C::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "Initialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.DisplayAirlockWidgetBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Show                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AEquipablePower_PassengerLog_C::DisplayAirlockWidgetBPI(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "DisplayAirlockWidgetBPI");

	Params::EquipablePower_PassengerLog_C_DisplayAirlockWidgetBPI Parms{};

	Parms.Show = Show;

	UObject::ProcessEvent(Func, &Parms);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.LogOutBPI
// (Public, BlueprintCallable, BlueprintEvent)

void AEquipablePower_PassengerLog_C::LogOutBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "LogOutBPI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.AddAlcoholBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InputValue                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AEquipablePower_PassengerLog_C::AddAlcoholBPI(float InputValue, bool Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "AddAlcoholBPI");

	Params::EquipablePower_PassengerLog_C_AddAlcoholBPI Parms{};

	Parms.InputValue = InputValue;
	Parms.Delay = Delay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.TeleportLocationRotationBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          TargetLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         TargetRotation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AEquipablePower_PassengerLog_C::TeleportLocationRotationBPI(const struct FVector& TargetLocation, const struct FRotator& TargetRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "TeleportLocationRotationBPI");

	Params::EquipablePower_PassengerLog_C_TeleportLocationRotationBPI Parms{};

	Parms.TargetLocation = std::move(TargetLocation);
	Parms.TargetRotation = std::move(TargetRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.EnableIK&AimDelayBPI
// (Public, BlueprintCallable, BlueprintEvent)

void AEquipablePower_PassengerLog_C::EnableIK_AimDelayBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "EnableIK&AimDelayBPI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.SetDestinyBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EFate                                   Fate                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Impulse                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AEquipablePower_PassengerLog_C::SetDestinyBPI(EFate Fate, const struct FVector& Impulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "SetDestinyBPI");

	Params::EquipablePower_PassengerLog_C_SetDestinyBPI Parms{};

	Parms.Fate = Fate;
	Parms.Impulse = std::move(Impulse);

	UObject::ProcessEvent(Func, &Parms);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.PassengerLogVoteBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           AirlockTarget                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ACharacter*                       TargetCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ACharacter*                       VotingCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AEquipablePower_PassengerLog_C::PassengerLogVoteBPI(class AActor* AirlockTarget, class ACharacter* TargetCharacter, class ACharacter* VotingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "PassengerLogVoteBPI");

	Params::EquipablePower_PassengerLog_C_PassengerLogVoteBPI Parms{};

	Parms.AirlockTarget = AirlockTarget;
	Parms.TargetCharacter = TargetCharacter;
	Parms.VotingCharacter = VotingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.TrustVoteBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetAirlock                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Yes                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class ACharacter*                       VotingCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AEquipablePower_PassengerLog_C::TrustVoteBPI(class AActor* TargetAirlock, bool Yes, class ACharacter* VotingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "TrustVoteBPI");

	Params::EquipablePower_PassengerLog_C_TrustVoteBPI Parms{};

	Parms.TargetAirlock = TargetAirlock;
	Parms.Yes = Yes;
	Parms.VotingCharacter = VotingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.EliminationVoteBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           AirlockTarget                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ACharacter*                       VotedCharacter                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ACharacter*                       VotingCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AEquipablePower_PassengerLog_C::EliminationVoteBPI(class AActor* AirlockTarget, class ACharacter* VotedCharacter, class ACharacter* VotingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "EliminationVoteBPI");

	Params::EquipablePower_PassengerLog_C_EliminationVoteBPI Parms{};

	Parms.AirlockTarget = AirlockTarget;
	Parms.VotedCharacter = VotedCharacter;
	Parms.VotingCharacter = VotingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.InitiateAirlockSequenceBPI
// (Public, BlueprintCallable, BlueprintEvent)

void AEquipablePower_PassengerLog_C::InitiateAirlockSequenceBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "InitiateAirlockSequenceBPI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.StartElevatorBPI
// (Public, BlueprintCallable, BlueprintEvent)

void AEquipablePower_PassengerLog_C::StartElevatorBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "StartElevatorBPI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.SetAimingStateBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Aiming                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// uint8                                   AimType                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AEquipablePower_PassengerLog_C::SetAimingStateBPI(bool Aiming, uint8 AimType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "SetAimingStateBPI");

	Params::EquipablePower_PassengerLog_C_SetAimingStateBPI Parms{};

	Parms.Aiming = Aiming;
	Parms.AimType = AimType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.RagdollCharacterBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ToRagdoll                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          OptionalImpulse                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Force                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AEquipablePower_PassengerLog_C::RagdollCharacterBPI(bool ToRagdoll, float Duration, const struct FVector& OptionalImpulse, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "RagdollCharacterBPI");

	Params::EquipablePower_PassengerLog_C_RagdollCharacterBPI Parms{};

	Parms.ToRagdoll = ToRagdoll;
	Parms.Duration = Duration;
	Parms.OptionalImpulse = std::move(OptionalImpulse);
	Parms.Force = Force;

	UObject::ProcessEvent(Func, &Parms);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.OnRep_HiddenInGame
// (BlueprintCallable, BlueprintEvent)

void AEquipablePower_PassengerLog_C::OnRep_HiddenInGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "OnRep_HiddenInGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.IsAliveBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Alive                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AEquipablePower_PassengerLog_C::IsAliveBPI(bool* Alive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "IsAliveBPI");

	Params::EquipablePower_PassengerLog_C_IsAliveBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Alive != nullptr)
		*Alive = Parms.Alive;
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.GetHeldLogInfoBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPassengerLogFactType                   FactType                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FPlayerData>              Players                                                (Parm, OutParm)
// bool                                    HasLog                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AEquipablePower_PassengerLog_C::GetHeldLogInfoBPI(EPassengerLogFactType* FactType, TArray<struct FPlayerData>* Players, bool* HasLog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "GetHeldLogInfoBPI");

	Params::EquipablePower_PassengerLog_C_GetHeldLogInfoBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FactType != nullptr)
		*FactType = Parms.FactType;

	if (Players != nullptr)
		*Players = std::move(Parms.Players);

	if (HasLog != nullptr)
		*HasLog = Parms.HasLog;
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.IsPersonoidBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsPersonoid                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AEquipablePower_PassengerLog_C::IsPersonoidBPI(bool* IsPersonoid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "IsPersonoidBPI");

	Params::EquipablePower_PassengerLog_C_IsPersonoidBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsPersonoid != nullptr)
		*IsPersonoid = Parms.IsPersonoid;
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.GetPlayerNameBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Name_0                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void AEquipablePower_PassengerLog_C::GetPlayerNameBPI(class FString* Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "GetPlayerNameBPI");

	Params::EquipablePower_PassengerLog_C_GetPlayerNameBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.IsFemaleBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AEquipablePower_PassengerLog_C::IsFemaleBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "IsFemaleBPI");

	Params::EquipablePower_PassengerLog_C_IsFemaleBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.GetAbilitySystemComponentBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class UAbilitySystemComponent* AEquipablePower_PassengerLog_C::GetAbilitySystemComponentBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "GetAbilitySystemComponentBPI");

	Params::EquipablePower_PassengerLog_C_GetAbilitySystemComponentBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.GetPortrait
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class UTexture2D* AEquipablePower_PassengerLog_C::GetPortrait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "GetPortrait");

	Params::EquipablePower_PassengerLog_C_GetPortrait Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.GetHomingTargetBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class USceneComponent* AEquipablePower_PassengerLog_C::GetHomingTargetBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "GetHomingTargetBPI");

	Params::EquipablePower_PassengerLog_C_GetHomingTargetBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.IsPlayerBlocked
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState*                     Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bLocked                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AEquipablePower_PassengerLog_C::IsPlayerBlocked(class APlayerState* Player, bool* bLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "IsPlayerBlocked");

	Params::EquipablePower_PassengerLog_C_IsPlayerBlocked Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	if (bLocked != nullptr)
		*bLocked = Parms.bLocked;
}


// Function EquipablePower_PassengerLog.EquipablePower_PassengerLog_C.IsPlayerConsoleCommunicationBlocked
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState*                     Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bLocked                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AEquipablePower_PassengerLog_C::IsPlayerConsoleCommunicationBlocked(class APlayerState* Player, bool* bLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower_PassengerLog_C", "IsPlayerConsoleCommunicationBlocked");

	Params::EquipablePower_PassengerLog_C_IsPlayerConsoleCommunicationBlocked Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	if (bLocked != nullptr)
		*bLocked = Parms.bLocked;
}

}

