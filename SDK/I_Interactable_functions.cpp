#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: I_Interactable

#include "Basic.hpp"

#include "I_Interactable_classes.hpp"
#include "I_Interactable_parameters.hpp"


namespace SDK
{

// Function I_Interactable.I_Interactable_C.InteractPressed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InteractingActorIsCharacter                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       InteractedHitResult                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void II_Interactable_C::InteractPressed(bool InteractingActorIsCharacter, class AActor* InteractingActor, const struct FHitResult& InteractedHitResult, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("I_Interactable_C", "InteractPressed");

	Params::I_Interactable_C_InteractPressed Parms{};

	Parms.InteractingActorIsCharacter = InteractingActorIsCharacter;
	Parms.InteractingActor = InteractingActor;
	Parms.InteractedHitResult = std::move(InteractedHitResult);

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function I_Interactable.I_Interactable_C.GetCanInteract
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsSimulated                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    InteractingActorIsCharacter                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CanInteract                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void II_Interactable_C::GetCanInteract(bool IsSimulated, bool InteractingActorIsCharacter, class AActor* InteractingActor, bool* CanInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("I_Interactable_C", "GetCanInteract");

	Params::I_Interactable_C_GetCanInteract Parms{};

	Parms.IsSimulated = IsSimulated;
	Parms.InteractingActorIsCharacter = InteractingActorIsCharacter;
	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);

	if (CanInteract != nullptr)
		*CanInteract = Parms.CanInteract;
}


// Function I_Interactable.I_Interactable_C.InteractReleased
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InteractingActorIsCharacter                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Void                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void II_Interactable_C::InteractReleased(bool InteractingActorIsCharacter, class AActor* InteractingActor, bool* Void)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("I_Interactable_C", "InteractReleased");

	Params::I_Interactable_C_InteractReleased Parms{};

	Parms.InteractingActorIsCharacter = InteractingActorIsCharacter;
	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);

	if (Void != nullptr)
		*Void = Parms.Void;
}


// Function I_Interactable.I_Interactable_C.Server_LatentInteractionSuccess
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InteractingActorIsCharacter                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           InteractingInstigator                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           InteractionFacilitator                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Void                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void II_Interactable_C::Server_LatentInteractionSuccess(bool InteractingActorIsCharacter, class AActor* InteractingInstigator, class AActor* InteractionFacilitator, bool* Void)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("I_Interactable_C", "Server_LatentInteractionSuccess");

	Params::I_Interactable_C_Server_LatentInteractionSuccess Parms{};

	Parms.InteractingActorIsCharacter = InteractingActorIsCharacter;
	Parms.InteractingInstigator = InteractingInstigator;
	Parms.InteractionFacilitator = InteractionFacilitator;

	UObject::ProcessEvent(Func, &Parms);

	if (Void != nullptr)
		*Void = Parms.Void;
}

}

