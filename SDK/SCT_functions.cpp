#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SCT

#include "Basic.hpp"

#include "SCT_classes.hpp"
#include "SCT_parameters.hpp"


namespace SDK
{

// Function SCT.AccelByteUtilsFunctionLibrary.CreateCustomizationPacket
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class ACustomizationOptions*            Options                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerCustomizationType                Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudCustomizationPayload       Payload                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCloudCustomizationPacket        ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCloudCustomizationPacket UAccelByteUtilsFunctionLibrary::CreateCustomizationPacket(class ACustomizationOptions* Options, EPlayerCustomizationType Category, const struct FCloudCustomizationPayload& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AccelByteUtilsFunctionLibrary", "CreateCustomizationPacket");

	Params::AccelByteUtilsFunctionLibrary_CreateCustomizationPacket Parms{};

	Parms.Options = Options;
	Parms.Category = Category;
	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AccelByteUtilsFunctionLibrary.FormatAccelByteDateTimeToUnrealDateTime
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           InConvertToDateTime                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UAccelByteUtilsFunctionLibrary::FormatAccelByteDateTimeToUnrealDateTime(const class FString& InConvertToDateTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AccelByteUtilsFunctionLibrary", "FormatAccelByteDateTimeToUnrealDateTime");

	Params::AccelByteUtilsFunctionLibrary_FormatAccelByteDateTimeToUnrealDateTime Parms{};

	Parms.InConvertToDateTime = std::move(InConvertToDateTime);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AbilitySystemComponentSCT.CancelAllAbilities
// (Final, Native, Public, BlueprintCallable)

void UAbilitySystemComponentSCT::CancelAllAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentSCT", "CancelAllAbilities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AbilitySystemComponentSCT.RemoveGameplayEffectsUsingType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffect>      EffectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySystemComponentSCT::RemoveGameplayEffectsUsingType(TSubclassOf<class UGameplayEffect> EffectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentSCT", "RemoveGameplayEffectsUsingType");

	Params::AbilitySystemComponentSCT_RemoveGameplayEffectsUsingType Parms{};

	Parms.EffectType = EffectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AbilitySystemComponentSCT.GetEffectInstigator
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UAbilitySystemComponentSCT::GetEffectInstigator(const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentSCT", "GetEffectInstigator");

	Params::AbilitySystemComponentSCT_GetEffectInstigator Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AgendaGenericEvent.Call
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAgendaGenericEvent::Call(class AActor* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaGenericEvent", "Call");

	Params::AgendaGenericEvent_Call Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomGameSettingsComponent.OnRep_UserSettings
// (Final, Native, Private)

void UCustomGameSettingsComponent::OnRep_UserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsComponent", "OnRep_UserSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTGetBlockedPlayerListCallbackProxy.GetBlockedPlayerList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTGetBlockedPlayerListCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetBlockedPlayerListCallbackProxy* UFCTGetBlockedPlayerListCallbackProxy::GetBlockedPlayerList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetBlockedPlayerListCallbackProxy", "GetBlockedPlayerList");

	Params::FCTGetBlockedPlayerListCallbackProxy_GetBlockedPlayerList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AbilitySystemUtility.SendGameplayEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          Target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     EventTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayEventData               Payload                                                (Parm, NativeAccessSpecifierPublic)

void UAbilitySystemUtility::SendGameplayEvent(class UAbilitySystemComponent* Target, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilitySystemUtility", "SendGameplayEvent");

	Params::AbilitySystemUtility_SendGameplayEvent Parms{};

	Parms.Target = Target;
	Parms.EventTag = std::move(EventTag);
	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CharacterSCT.CancelPowers
// (Final, Native, Public, BlueprintCallable)

void ACharacterSCT::CancelPowers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "CancelPowers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CharacterSCT.ClientInitializeContextSensors
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void ACharacterSCT::ClientInitializeContextSensors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "ClientInitializeContextSensors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CharacterSCT.DisableCameraRotationForDuration
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterSCT::DisableCameraRotationForDuration(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "DisableCameraRotationForDuration");

	Params::CharacterSCT_DisableCameraRotationForDuration Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CharacterSCT.DisableMovementForFrames
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Frames                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterSCT::DisableMovementForFrames(int32 Frames)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "DisableMovementForFrames");

	Params::CharacterSCT_DisableMovementForFrames Parms{};

	Parms.Frames = Frames;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CharacterSCT.IsUsingPower
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterSCT::IsUsingPower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "IsUsingPower");

	Params::CharacterSCT_IsUsingPower Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CharacterSCT.K2_FellOutOfWorld
// (Event, Protected, BlueprintEvent)

void ACharacterSCT::K2_FellOutOfWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "K2_FellOutOfWorld");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.CharacterSCT.K2_OnNameChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           NewName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterSCT::K2_OnNameChanged(const class FString& NewName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "K2_OnNameChanged");

	Params::CharacterSCT_K2_OnNameChanged Parms{};

	Parms.NewName = std::move(NewName);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CharacterSCT.K2_OnRepPlayerState
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    IsValid                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterSCT::K2_OnRepPlayerState(const bool IsValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "K2_OnRepPlayerState");

	Params::CharacterSCT_K2_OnRepPlayerState Parms{};

	Parms.IsValid = IsValid;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CharacterSCT.K2_OnSetCustomization
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           PlayerAccelByteID                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterSCT::K2_OnSetCustomization(const class FString& PlayerAccelByteID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "K2_OnSetCustomization");

	Params::CharacterSCT_K2_OnSetCustomization Parms{};

	Parms.PlayerAccelByteID = std::move(PlayerAccelByteID);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CharacterSCT.OnDamaged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DamageAmount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       HitInfo                                                (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            DamageTags                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class ACharacterSCT*                    InstigatorCharacter                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           DamageCauser                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterSCT::OnDamaged(float DamageAmount, const struct FHitResult& HitInfo, const struct FGameplayTagContainer& DamageTags, class ACharacterSCT* InstigatorCharacter, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "OnDamaged");

	Params::CharacterSCT_OnDamaged Parms{};

	Parms.DamageAmount = DamageAmount;
	Parms.HitInfo = std::move(HitInfo);
	Parms.DamageTags = std::move(DamageTags);
	Parms.InstigatorCharacter = InstigatorCharacter;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CharacterSCT.OnHealthChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DeltaValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ACharacterSCT::OnHealthChanged(float DeltaValue, const struct FGameplayTagContainer& EventTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "OnHealthChanged");

	Params::CharacterSCT_OnHealthChanged Parms{};

	Parms.DeltaValue = DeltaValue;
	Parms.EventTags = std::move(EventTags);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CharacterSCT.OnManaChanged
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// float                                   DeltaValue                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ACharacterSCT::OnManaChanged(float DeltaValue, const struct FGameplayTagContainer& EventTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "OnManaChanged");

	Params::CharacterSCT_OnManaChanged Parms{};

	Parms.DeltaValue = DeltaValue;
	Parms.EventTags = std::move(EventTags);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CharacterSCT.OnMoveSpeedChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   MovementSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterSCT::OnMoveSpeedChanged(float MovementSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "OnMoveSpeedChanged");

	Params::CharacterSCT_OnMoveSpeedChanged Parms{};

	Parms.MovementSpeed = MovementSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CharacterSCT.OnNameChanged
// (Final, Native, Protected)
// Parameters:
// class FString                           NewName                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterSCT::OnNameChanged(const class FString& NewName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "OnNameChanged");

	Params::CharacterSCT_OnNameChanged Parms{};

	Parms.NewName = std::move(NewName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CharacterSCT.OnPreServerTravel
// (Final, Native, Public)

void ACharacterSCT::OnPreServerTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "OnPreServerTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CharacterSCT.OnRep_AccelByteID
// (Final, Native, Public)

void ACharacterSCT::OnRep_AccelByteID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "OnRep_AccelByteID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CharacterSCT.ServerCancelPowers
// (Net, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void ACharacterSCT::ServerCancelPowers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "ServerCancelPowers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CharacterSCT.Silence
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterSCT::Silence(float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "Silence");

	Params::CharacterSCT_Silence Parms{};

	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CharacterSCT.CanRotateCamera
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterSCT::CanRotateCamera() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "CanRotateCamera");

	Params::CharacterSCT_CanRotateCamera Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CharacterSCT.CanRotateCharacter
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterSCT::CanRotateCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "CanRotateCharacter");

	Params::CharacterSCT_CanRotateCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CharacterSCT.GetCharacerLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ACharacterSCT::GetCharacerLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "GetCharacerLevel");

	Params::CharacterSCT_GetCharacerLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CharacterSCT.GetFate
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EFate                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFate ACharacterSCT::GetFate() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "GetFate");

	Params::CharacterSCT_GetFate Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CharacterSCT.GetSCTPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASCTPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASCTPlayerState* ACharacterSCT::GetSCTPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "GetSCTPlayerState");

	Params::CharacterSCT_GetSCTPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CharacterSCT.IsAlive
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterSCT::IsAlive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "IsAlive");

	Params::CharacterSCT_IsAlive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CharacterSCT.IsFateKnown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterSCT::IsFateKnown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "IsFateKnown");

	Params::CharacterSCT_IsFateKnown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CharacterSCT.IsImmovable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterSCT::IsImmovable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "IsImmovable");

	Params::CharacterSCT_IsImmovable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CharacterSCT.IsInactive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterSCT::IsInactive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "IsInactive");

	Params::CharacterSCT_IsInactive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CharacterSCT.K2_CanCrouch
// (Event, Public, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ACharacterSCT::K2_CanCrouch() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCT", "K2_CanCrouch");

	Params::CharacterSCT_K2_CanCrouch Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SCT.AfterlifeCharacter.HideSpectatorHUD
// (Final, Native, Protected, BlueprintCallable)

void AAfterlifeCharacter::HideSpectatorHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AfterlifeCharacter", "HideSpectatorHUD");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AfterlifeCharacter.ShowSpectatorHUD
// (Final, Native, Protected, BlueprintCallable)

void AAfterlifeCharacter::ShowSpectatorHUD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AfterlifeCharacter", "ShowSpectatorHUD");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.AddNewAchievementToQueue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFCTAchievement*                  NewAchievement                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccelByteGIS::AddNewAchievementToQueue(class UFCTAchievement* NewAchievement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "AddNewAchievementToQueue");

	Params::AccelByteGIS_AddNewAchievementToQueue Parms{};

	Parms.NewAchievement = NewAchievement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.AnimateAchievementPopUpFadeIn
// (Final, Native, Private)

void UAccelByteGIS::AnimateAchievementPopUpFadeIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "AnimateAchievementPopUpFadeIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.AnimateAchievementPopUpFadeOut
// (Final, Native, Private)

void UAccelByteGIS::AnimateAchievementPopUpFadeOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "AnimateAchievementPopUpFadeOut");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.CachePlayedWithLastMatchUser
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccelByteGIS::CachePlayedWithLastMatchUser(const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "CachePlayedWithLastMatchUser");

	Params::AccelByteGIS_CachePlayedWithLastMatchUser Parms{};

	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.CancelClientLogin
// (Final, Native, Public, BlueprintCallable)

void UAccelByteGIS::CancelClientLogin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "CancelClientLogin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.ClearCrossPlayJoinErrorMessage
// (Final, Native, Public, BlueprintCallable)

void UAccelByteGIS::ClearCrossPlayJoinErrorMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "ClearCrossPlayJoinErrorMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.ClearPendingConsoleLaunchIntent
// (Final, Native, Public, BlueprintCallable)

void UAccelByteGIS::ClearPendingConsoleLaunchIntent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "ClearPendingConsoleLaunchIntent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.ClearPendingConsoleLaunchMultiplayerIntent
// (Final, Native, Public, BlueprintCallable)

void UAccelByteGIS::ClearPendingConsoleLaunchMultiplayerIntent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "ClearPendingConsoleLaunchMultiplayerIntent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.ClearPendingConsoleSessionInvite
// (Final, Native, Public, BlueprintCallable)

void UAccelByteGIS::ClearPendingConsoleSessionInvite()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "ClearPendingConsoleSessionInvite");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.ClearPlayedWithLastMatchUserCache
// (Final, Native, Public, BlueprintCallable)

void UAccelByteGIS::ClearPlayedWithLastMatchUserCache()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "ClearPlayedWithLastMatchUserCache");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.ClientLoginFailed
// (Final, Native, Private)

void UAccelByteGIS::ClientLoginFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "ClientLoginFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.GetCachedLastMatchUsers
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FFCTRecentlyPlayedWithPayload    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FFCTRecentlyPlayedWithPayload UAccelByteGIS::GetCachedLastMatchUsers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "GetCachedLastMatchUsers");

	Params::AccelByteGIS_GetCachedLastMatchUsers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AccelByteGIS.GetGameCrossplayEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAccelByteGIS::GetGameCrossplayEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "GetGameCrossplayEnabled");

	Params::AccelByteGIS_GetGameCrossplayEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AccelByteGIS.GetPlatformPlayerNickname
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAccelByteGIS::GetPlatformPlayerNickname()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "GetPlatformPlayerNickname");

	Params::AccelByteGIS_GetPlatformPlayerNickname Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AccelByteGIS.GetSyncPlatformPurchasesRateLimited
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAccelByteGIS::GetSyncPlatformPurchasesRateLimited()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "GetSyncPlatformPurchasesRateLimited");

	Params::AccelByteGIS_GetSyncPlatformPurchasesRateLimited Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AccelByteGIS.GetXboxCrossPlayRestricted
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAccelByteGIS::GetXboxCrossPlayRestricted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "GetXboxCrossPlayRestricted");

	Params::AccelByteGIS_GetXboxCrossPlayRestricted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AccelByteGIS.HasPendingConsoleLaunchIntent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAccelByteGIS::HasPendingConsoleLaunchIntent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "HasPendingConsoleLaunchIntent");

	Params::AccelByteGIS_HasPendingConsoleLaunchIntent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AccelByteGIS.HasPendingConsoleLaunchMultiplayerIntent
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAccelByteGIS::HasPendingConsoleLaunchMultiplayerIntent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "HasPendingConsoleLaunchMultiplayerIntent");

	Params::AccelByteGIS_HasPendingConsoleLaunchMultiplayerIntent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AccelByteGIS.HasPendingConsoleSessionInvite
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAccelByteGIS::HasPendingConsoleSessionInvite()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "HasPendingConsoleSessionInvite");

	Params::AccelByteGIS_HasPendingConsoleSessionInvite Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AccelByteGIS.IsLoggedIn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAccelByteGIS::IsLoggedIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "IsLoggedIn");

	Params::AccelByteGIS_IsLoggedIn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AccelByteGIS.LoginClient
// (Final, Native, Public, BlueprintCallable)

void UAccelByteGIS::LoginClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "LoginClient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.LoginClientWithDelay
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Delay                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccelByteGIS::LoginClientWithDelay(float Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "LoginClientWithDelay");

	Params::AccelByteGIS_LoginClientWithDelay Parms{};

	Parms.Delay = Delay;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.OnAchievementPopUpCreated
// (Final, Native, Private)
// Parameters:
// class UTexture2DDynamic*                IconTexture                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccelByteGIS::OnAchievementPopUpCreated(class UTexture2DDynamic* IconTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "OnAchievementPopUpCreated");

	Params::AccelByteGIS_OnAchievementPopUpCreated Parms{};

	Parms.IconTexture = IconTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.ReopenConsoleSession
// (Final, Native, Public, BlueprintCallable)

void UAccelByteGIS::ReopenConsoleSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "ReopenConsoleSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.RequestCrossPlayJoinErrorMessage
// (Final, Native, Public, BlueprintCallable)

void UAccelByteGIS::RequestCrossPlayJoinErrorMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "RequestCrossPlayJoinErrorMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.ResetLoginForNewUser
// (Final, Native, Public, BlueprintCallable)

void UAccelByteGIS::ResetLoginForNewUser()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "ResetLoginForNewUser");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.SetGameCrossplayEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInEnabled                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccelByteGIS::SetGameCrossplayEnabled(bool bInEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "SetGameCrossplayEnabled");

	Params::AccelByteGIS_SetGameCrossplayEnabled Parms{};

	Parms.bInEnabled = bInEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.SetXboxCrossPlayRestricted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInRestricted                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccelByteGIS::SetXboxCrossPlayRestricted(bool bInRestricted)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "SetXboxCrossPlayRestricted");

	Params::AccelByteGIS_SetXboxCrossPlayRestricted Parms{};

	Parms.bInRestricted = bInRestricted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.StartTelemetryMatchTimer
// (Final, Native, Public, BlueprintCallable)

void UAccelByteGIS::StartTelemetryMatchTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "StartTelemetryMatchTimer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.UnbindEvents
// (Final, Native, Public, BlueprintCallable)

void UAccelByteGIS::UnbindEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "UnbindEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AccelByteGIS.UpdatePlatformAchievementProgress
// (Final, Native, Public)
// Parameters:
// class FString                           AchievementID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAccelByteGIS::UpdatePlatformAchievementProgress(const class FString& AchievementID, float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AccelByteGIS", "UpdatePlatformAchievementProgress");

	Params::AccelByteGIS_UpdatePlatformAchievementProgress Parms{};

	Parms.AchievementID = std::move(AchievementID);
	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ProgressionObject.K2_Initialize
// (Event, Public, BlueprintEvent)

void UProgressionObject::K2_Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionObject", "K2_Initialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.ProgressionObject.GetCharacter
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ACharacterSCT*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ACharacterSCT* UProgressionObject::GetCharacter() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionObject", "GetCharacter");

	Params::ProgressionObject_GetCharacter Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ProgressionObject.GetController
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASCTPlayerController*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASCTPlayerController* UProgressionObject::GetController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionObject", "GetController");

	Params::ProgressionObject_GetController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ProgressionObject.GetGameState
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASCTGameState*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASCTGameState* UProgressionObject::GetGameState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionObject", "GetGameState");

	Params::ProgressionObject_GetGameState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ProgressionObject.GetMaxNumberOfPlayers
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UProgressionObject::GetMaxNumberOfPlayers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionObject", "GetMaxNumberOfPlayers");

	Params::ProgressionObject_GetMaxNumberOfPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ProgressionObject.GetPlayerState
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASCTPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASCTPlayerState* UProgressionObject::GetPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionObject", "GetPlayerState");

	Params::ProgressionObject_GetPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ProgressionObject.GetRandomOtherPlayer
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ASCTPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASCTPlayerState* UProgressionObject::GetRandomOtherPlayer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionObject", "GetRandomOtherPlayer");

	Params::ProgressionObject_GetRandomOtherPlayer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ProgressionObject.GetRandomPlayer
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class APlayerState*>             Ignore                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class ASCTPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASCTPlayerState* UProgressionObject::GetRandomPlayer(const TArray<class APlayerState*>& Ignore) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionObject", "GetRandomPlayer");

	Params::ProgressionObject_GetRandomPlayer Parms{};

	Parms.Ignore = std::move(Ignore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ProgressionObject.GetWorldContextObject
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UProgressionObject::GetWorldContextObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionObject", "GetWorldContextObject");

	Params::ProgressionObject_GetWorldContextObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ProgressionObject.IsControllerSelf
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UProgressionObject::IsControllerSelf(class APlayerController* Other) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionObject", "IsControllerSelf");

	Params::ProgressionObject_IsControllerSelf Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ProgressionObject.IsPlayerStateSelf
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerState*                     Other                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UProgressionObject::IsPlayerStateSelf(class APlayerState* Other) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProgressionObject", "IsPlayerStateSelf");

	Params::ProgressionObject_IsPlayerStateSelf Parms{};

	Parms.Other = Other;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomizationScrollBoxUserWidgetBase.SwapItemCardSelectedStates
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           NewItemRowName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationScrollBoxUserWidgetBase::SwapItemCardSelectedStates(const class FString& NewItemRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationScrollBoxUserWidgetBase", "SwapItemCardSelectedStates");

	Params::CustomizationScrollBoxUserWidgetBase_SwapItemCardSelectedStates Parms{};

	Parms.NewItemRowName = std::move(NewItemRowName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationScrollBoxUserWidgetBase.SwapItemCardSelectedStatesByGrid
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGridPanel*                       Grid                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CurrentItemRowName                                     (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewItemRowName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationScrollBoxUserWidgetBase::SwapItemCardSelectedStatesByGrid(class UGridPanel* Grid, class FString& CurrentItemRowName, const class FString& NewItemRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationScrollBoxUserWidgetBase", "SwapItemCardSelectedStatesByGrid");

	Params::CustomizationScrollBoxUserWidgetBase_SwapItemCardSelectedStatesByGrid Parms{};

	Parms.Grid = Grid;
	Parms.CurrentItemRowName = std::move(CurrentItemRowName);
	Parms.NewItemRowName = std::move(NewItemRowName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	CurrentItemRowName = std::move(Parms.CurrentItemRowName);
}


// Function SCT.CustomizationScrollBoxUserWidgetBase.UpdateCategoryVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGridPanel*                       CategoryGrid                                           (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationScrollBoxUserWidgetBase::UpdateCategoryVisibility(class UGridPanel* CategoryGrid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationScrollBoxUserWidgetBase", "UpdateCategoryVisibility");

	Params::CustomizationScrollBoxUserWidgetBase_UpdateCategoryVisibility Parms{};

	Parms.CategoryGrid = CategoryGrid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationScrollBoxUserWidgetBase.UpdateVisibilityForAllCategories
// (Final, Native, Public, BlueprintCallable)

void UCustomizationScrollBoxUserWidgetBase::UpdateVisibilityForAllCategories()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationScrollBoxUserWidgetBase", "UpdateVisibilityForAllCategories");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationScrollBoxUserWidgetBase.VerticalBoundaryHit
// (Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUINavigation                           InNavigation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UCustomizationScrollBoxUserWidgetBase::VerticalBoundaryHit(EUINavigation InNavigation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationScrollBoxUserWidgetBase", "VerticalBoundaryHit");

	Params::CustomizationScrollBoxUserWidgetBase_VerticalBoundaryHit Parms{};

	Parms.InNavigation = InNavigation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomizationScrollBoxUserWidget.AppearanceVerticalBoundaryHit
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUINavigation                           InNavigation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UCustomizationScrollBoxUserWidget::AppearanceVerticalBoundaryHit(EUINavigation InNavigation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationScrollBoxUserWidget", "AppearanceVerticalBoundaryHit");

	Params::CustomizationScrollBoxUserWidget_AppearanceVerticalBoundaryHit Parms{};

	Parms.InNavigation = InNavigation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomizationScrollBoxUserWidget.HorizontalBoundaryHit
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUINavigation                           InNavigation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UCustomizationScrollBoxUserWidget::HorizontalBoundaryHit(EUINavigation InNavigation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationScrollBoxUserWidget", "HorizontalBoundaryHit");

	Params::CustomizationScrollBoxUserWidget_HorizontalBoundaryHit Parms{};

	Parms.InNavigation = InNavigation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomizationScrollBoxUserWidget.K2_UpdateEyeMaterial
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationScrollBoxUserWidget::K2_UpdateEyeMaterial(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationScrollBoxUserWidget", "K2_UpdateEyeMaterial");

	Params::CustomizationScrollBoxUserWidget_K2_UpdateEyeMaterial Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CustomizationScrollBoxUserWidget.K2_UpdateHairColor
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationScrollBoxUserWidget::K2_UpdateHairColor(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationScrollBoxUserWidget", "K2_UpdateHairColor");

	Params::CustomizationScrollBoxUserWidget_K2_UpdateHairColor Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CustomizationScrollBoxUserWidget.K2_UpdatePreset
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationScrollBoxUserWidget::K2_UpdatePreset(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationScrollBoxUserWidget", "K2_UpdatePreset");

	Params::CustomizationScrollBoxUserWidget_K2_UpdatePreset Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CustomizationScrollBoxUserWidget.K2_UpdateSkinMaterial
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationScrollBoxUserWidget::K2_UpdateSkinMaterial(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationScrollBoxUserWidget", "K2_UpdateSkinMaterial");

	Params::CustomizationScrollBoxUserWidget_K2_UpdateSkinMaterial Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.PartyLobbyWidget.GetDebugPartyMembers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UPartyLobbyWidget::GetDebugPartyMembers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartyLobbyWidget", "GetDebugPartyMembers");

	Params::PartyLobbyWidget_GetDebugPartyMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PartyLobbyWidget.IsDebugMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPartyLobbyWidget::IsDebugMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartyLobbyWidget", "IsDebugMode");

	Params::PartyLobbyWidget_IsDebugMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PartyLobbyWidget.OnInviteToParty
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsPartyGetInvitedNoticeNotification                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPartyLobbyWidget::OnInviteToParty(const struct FAccelByteModelsPartyGetInvitedNotice& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartyLobbyWidget", "OnInviteToParty");

	Params::PartyLobbyWidget_OnInviteToParty Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PartyLobbyWidget.OnJoinParty
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsPartyJoinResponseResponse                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPartyLobbyWidget::OnJoinParty(const struct FAccelByteModelsPartyJoinResponse& Response)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartyLobbyWidget", "OnJoinParty");

	Params::PartyLobbyWidget_OnJoinParty Parms{};

	Parms.Response = std::move(Response);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PartyLobbyWidget.OnKickedFromParty
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsGotKickedFromPartyNoticeNotification                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPartyLobbyWidget::OnKickedFromParty(const struct FAccelByteModelsGotKickedFromPartyNotice& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartyLobbyWidget", "OnKickedFromParty");

	Params::PartyLobbyWidget_OnKickedFromParty Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PartyLobbyWidget.OnLeaveParty
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsLeavePartyNotice Notification                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPartyLobbyWidget::OnLeaveParty(const struct FAccelByteModelsLeavePartyNotice& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartyLobbyWidget", "OnLeaveParty");

	Params::PartyLobbyWidget_OnLeaveParty Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PartyLobbyWidget.OnNewMemberJoinedParty
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsPartyJoinNotice  Notification                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPartyLobbyWidget::OnNewMemberJoinedParty(const struct FAccelByteModelsPartyJoinNotice& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartyLobbyWidget", "OnNewMemberJoinedParty");

	Params::PartyLobbyWidget_OnNewMemberJoinedParty Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AchievementObject.GrantAchievement
// (Final, Native, Protected, BlueprintCallable, Const)

void UAchievementObject::GrantAchievement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementObject", "GrantAchievement");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AgendaCoopKillEvent.Call
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Grabber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAgendaCoopKillEvent::Call(class APlayerController* Grabber, class APlayerController* Killer, class APlayerController* Victim)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaCoopKillEvent", "Call");

	Params::AgendaCoopKillEvent_Call Parms{};

	Parms.Grabber = Grabber;
	Parms.Killer = Killer;
	Parms.Victim = Victim;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AgendaCoopKillEvent.CallWithWorldContextObject
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Grabber                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                Killer                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                Victim                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAgendaCoopKillEvent::CallWithWorldContextObject(class APlayerController* Grabber, class APlayerController* Killer, class APlayerController* Victim, class AActor* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaCoopKillEvent", "CallWithWorldContextObject");

	Params::AgendaCoopKillEvent_CallWithWorldContextObject Parms{};

	Parms.Grabber = Grabber;
	Parms.Killer = Killer;
	Parms.Victim = Victim;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Activateable.Activate
// (Event, Public, BlueprintEvent)

void IActivateable::Activate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Activateable", "Activate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.Activateable.Cancel
// (Event, Public, BlueprintEvent)

void IActivateable::Cancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Activateable", "Cancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.Activateable.Deactivate
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    WasCancelled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IActivateable::Deactivate(bool WasCancelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Activateable", "Deactivate");

	Params::Activateable_Deactivate Parms{};

	Parms.WasCancelled = WasCancelled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.AgendaControllerEvent.Call
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAgendaControllerEvent::Call(class APlayerController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaControllerEvent", "Call");

	Params::AgendaControllerEvent_Call Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AgendaControllerEvent.CallWithWorldContextObject
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAgendaControllerEvent::CallWithWorldContextObject(class APlayerController* Controller, class AActor* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaControllerEvent", "CallWithWorldContextObject");

	Params::AgendaControllerEvent_CallWithWorldContextObject Parms{};

	Parms.Controller = Controller;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AgendaControllerPowerEvent.Call
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UPower>               Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAgendaControllerPowerEvent::Call(class APlayerController* Controller, TSubclassOf<class UPower> Power)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaControllerPowerEvent", "Call");

	Params::AgendaControllerPowerEvent_Call Parms{};

	Parms.Controller = Controller;
	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AgendaControllerPowerEvent.CallWithWorldContextObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UPower>               Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAgendaControllerPowerEvent::CallWithWorldContextObject(class APlayerController* Controller, TSubclassOf<class UPower> Power, class AActor* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaControllerPowerEvent", "CallWithWorldContextObject");

	Params::AgendaControllerPowerEvent_CallWithWorldContextObject Parms{};

	Parms.Controller = Controller;
	Parms.Power = Power;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AgendaCoopPowerEvent.Call
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InstigatorController                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                TargetController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UPower>               PowerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAgendaCoopPowerEvent::Call(class APlayerController* InstigatorController, class APlayerController* TargetController, TSubclassOf<class UPower> PowerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaCoopPowerEvent", "Call");

	Params::AgendaCoopPowerEvent_Call Parms{};

	Parms.InstigatorController = InstigatorController;
	Parms.TargetController = TargetController;
	Parms.PowerType = PowerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AgendaCoopPowerEvent.CallWithWorldContextObject
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InstigatorController                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                TargetController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UPower>               PowerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAgendaCoopPowerEvent::CallWithWorldContextObject(class APlayerController* InstigatorController, class APlayerController* TargetController, TSubclassOf<class UPower> PowerType, class AActor* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaCoopPowerEvent", "CallWithWorldContextObject");

	Params::AgendaCoopPowerEvent_CallWithWorldContextObject Parms{};

	Parms.InstigatorController = InstigatorController;
	Parms.TargetController = TargetController;
	Parms.PowerType = PowerType;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AgendaObject.GiveScore
// (Final, Native, Protected, BlueprintCallable)

void UAgendaObject::GiveScore()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaObject", "GiveScore");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AgendaObject.SetState
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// EAgendaObjectState                      State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAgendaObject::SetState(EAgendaObjectState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaObject", "SetState");

	Params::AgendaObject_SetState Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AgendaObject.UpdateDescription
// (Final, Native, Protected, BlueprintCallable)

void UAgendaObject::UpdateDescription()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaObject", "UpdateDescription");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AgendaObject.UpdateProgression
// (Final, Native, Protected, BlueprintCallable)

void UAgendaObject::UpdateProgression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaObject", "UpdateProgression");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.AgendaObject.GetDescription
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAgendaObject::GetDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaObject", "GetDescription");

	Params::AgendaObject_GetDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AgendaObject.GetProgression
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAgendaObject::GetProgression() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaObject", "GetProgression");

	Params::AgendaObject_GetProgression Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AgendaObject.GetState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EAgendaObjectState                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAgendaObjectState UAgendaObject::GetState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaObject", "GetState");

	Params::AgendaObject_GetState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AgendaObject.HasFailed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAgendaObject::HasFailed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaObject", "HasFailed");

	Params::AgendaObject_HasFailed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AgendaObject.HasGivenScore
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAgendaObject::HasGivenScore() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaObject", "HasGivenScore");

	Params::AgendaObject_HasGivenScore Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AgendaObject.HasSucceeded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAgendaObject::HasSucceeded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaObject", "HasSucceeded");

	Params::AgendaObject_HasSucceeded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AgendaObject.IsInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAgendaObject::IsInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AgendaObject", "IsInProgress");

	Params::AgendaObject_IsInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AppearanceCustomizationSettings.GetBodyCustomizationList
// (Event, Public, BlueprintEvent)

void AAppearanceCustomizationSettings::GetBodyCustomizationList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceCustomizationSettings", "GetBodyCustomizationList");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.AppearanceCustomizationSettings.GetFeetCustomizationList
// (Event, Public, BlueprintEvent)

void AAppearanceCustomizationSettings::GetFeetCustomizationList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceCustomizationSettings", "GetFeetCustomizationList");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.AppearanceCustomizationSettings.GetHeadCustomizationList
// (Event, Public, BlueprintEvent)

void AAppearanceCustomizationSettings::GetHeadCustomizationList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceCustomizationSettings", "GetHeadCustomizationList");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.AppearanceCustomizationSettings.GetLegsCustomizationList
// (Event, Public, BlueprintEvent)

void AAppearanceCustomizationSettings::GetLegsCustomizationList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AppearanceCustomizationSettings", "GetLegsCustomizationList");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.AsyncTaskAttributeChanged.ListenForAttributeChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent_0                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAttribute               Attribute                                              (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskAttributeChanged*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskAttributeChanged* UAsyncTaskAttributeChanged::ListenForAttributeChange(class UAbilitySystemComponent* AbilitySystemComponent_0, const struct FGameplayAttribute& Attribute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskAttributeChanged", "ListenForAttributeChange");

	Params::AsyncTaskAttributeChanged_ListenForAttributeChange Parms{};

	Parms.AbilitySystemComponent_0 = AbilitySystemComponent_0;
	Parms.Attribute = std::move(Attribute);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AsyncTaskAttributeChanged.ListenForAttributesChange
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent_0                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayAttribute>       Attributes                                             (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UAsyncTaskAttributeChanged*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskAttributeChanged* UAsyncTaskAttributeChanged::ListenForAttributesChange(class UAbilitySystemComponent* AbilitySystemComponent_0, const TArray<struct FGameplayAttribute>& Attributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskAttributeChanged", "ListenForAttributesChange");

	Params::AsyncTaskAttributeChanged_ListenForAttributesChange Parms{};

	Parms.AbilitySystemComponent_0 = AbilitySystemComponent_0;
	Parms.Attributes = std::move(Attributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintConsolePrivilegeCheckerCallbackProxy.CheckConsoleCommunicationPrivilege
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlueprintConsolePrivilegeCheckerCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlueprintConsolePrivilegeCheckerCallbackProxy* UBlueprintConsolePrivilegeCheckerCallbackProxy::CheckConsoleCommunicationPrivilege(class UObject* WorldContextObject, class APlayerController* InPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintConsolePrivilegeCheckerCallbackProxy", "CheckConsoleCommunicationPrivilege");

	Params::BlueprintConsolePrivilegeCheckerCallbackProxy_CheckConsoleCommunicationPrivilege Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintConsolePrivilegeCheckerCallbackProxy.CheckConsoleCrossplayPrivilege
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlueprintConsolePrivilegeCheckerCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlueprintConsolePrivilegeCheckerCallbackProxy* UBlueprintConsolePrivilegeCheckerCallbackProxy::CheckConsoleCrossplayPrivilege(class UObject* WorldContextObject, class APlayerController* InPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintConsolePrivilegeCheckerCallbackProxy", "CheckConsoleCrossplayPrivilege");

	Params::BlueprintConsolePrivilegeCheckerCallbackProxy_CheckConsoleCrossplayPrivilege Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintConsolePrivilegeCheckerCallbackProxy.CheckConsoleOnlinePrivilege
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlueprintConsolePrivilegeCheckerCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlueprintConsolePrivilegeCheckerCallbackProxy* UBlueprintConsolePrivilegeCheckerCallbackProxy::CheckConsoleOnlinePrivilege(class UObject* WorldContextObject, class APlayerController* InPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintConsolePrivilegeCheckerCallbackProxy", "CheckConsoleOnlinePrivilege");

	Params::BlueprintConsolePrivilegeCheckerCallbackProxy_CheckConsoleOnlinePrivilege Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintConsoleQueryBlockListCallbackProxy.QueryConsoleBlockList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlueprintConsoleQueryBlockListCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlueprintConsoleQueryBlockListCallbackProxy* UBlueprintConsoleQueryBlockListCallbackProxy::QueryConsoleBlockList(class UObject* WorldContextObject, class APlayerController* InPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintConsoleQueryBlockListCallbackProxy", "QueryConsoleBlockList");

	Params::BlueprintConsoleQueryBlockListCallbackProxy_QueryConsoleBlockList Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.AddChildMenuToMenuController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      Menu                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ParentMenu                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SetFocus                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NonInteractable                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCTGameInstance*                 GameInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPanelSlot*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPanelSlot* UBlueprintFunctionLibrarySCT::AddChildMenuToMenuController(class UObject* WorldContextObject, class UUserWidget* Menu, class UUserWidget* ParentMenu, bool SetFocus, bool NonInteractable, class USCTGameInstance* GameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "AddChildMenuToMenuController");

	Params::BlueprintFunctionLibrarySCT_AddChildMenuToMenuController Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Menu = Menu;
	Parms.ParentMenu = ParentMenu;
	Parms.SetFocus = SetFocus;
	Parms.NonInteractable = NonInteractable;
	Parms.GameInstance = GameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.AddMenuToMenuController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      Menu                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ZOrder                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NonInteractable                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SetFocus                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCTGameInstance*                 GameInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::AddMenuToMenuController(class UObject* WorldContextObject, class UUserWidget* Menu, int32 ZOrder, bool NonInteractable, bool SetFocus, class USCTGameInstance* GameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "AddMenuToMenuController");

	Params::BlueprintFunctionLibrarySCT_AddMenuToMenuController Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Menu = Menu;
	Parms.ZOrder = ZOrder;
	Parms.NonInteractable = NonInteractable;
	Parms.SetFocus = SetFocus;
	Parms.GameInstance = GameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.AddWorldOxygenLevel
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::AddWorldOxygenLevel(class UObject* WorldContextObject, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "AddWorldOxygenLevel");

	Params::BlueprintFunctionLibrarySCT_AddWorldOxygenLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.BlockModalsDuringEmergencyMeeting
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::BlockModalsDuringEmergencyMeeting(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "BlockModalsDuringEmergencyMeeting");

	Params::BlueprintFunctionLibrarySCT_BlockModalsDuringEmergencyMeeting Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.CanReviewPS5Match
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::CanReviewPS5Match(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "CanReviewPS5Match");

	Params::BlueprintFunctionLibrarySCT_CanReviewPS5Match Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.ClearBlockedModalsDuringEmergencyMeeting
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::ClearBlockedModalsDuringEmergencyMeeting(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "ClearBlockedModalsDuringEmergencyMeeting");

	Params::BlueprintFunctionLibrarySCT_ClearBlockedModalsDuringEmergencyMeeting Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.ColorToHex
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FLinearColor                     Color                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintFunctionLibrarySCT::ColorToHex(const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "ColorToHex");

	Params::BlueprintFunctionLibrarySCT_ColorToHex Parms{};

	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.CreateEndData
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EEndConditions                          EndCondition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayerInfoGIS*                   PlayerInfo                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchEndData                    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchEndData UBlueprintFunctionLibrarySCT::CreateEndData(EEndConditions EndCondition, class UPlayerInfoGIS* PlayerInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "CreateEndData");

	Params::BlueprintFunctionLibrarySCT_CreateEndData Parms{};

	Parms.EndCondition = EndCondition;
	Parms.PlayerInfo = PlayerInfo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.CreateOrganizedWidget
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UWidgetSCT>           WidgetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   behaviour                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserWidget* UBlueprintFunctionLibrarySCT::CreateOrganizedWidget(TSubclassOf<class UWidgetSCT> WidgetType, int32 behaviour, class AActor* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "CreateOrganizedWidget");

	Params::BlueprintFunctionLibrarySCT_CreateOrganizedWidget Parms{};

	Parms.WidgetType = WidgetType;
	Parms.behaviour = behaviour;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.CreateShuffledIndexArrayWithSelection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SelectedIndex                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UBlueprintFunctionLibrarySCT::CreateShuffledIndexArrayWithSelection(int32 Seed, int32 Count, int32* SelectedIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "CreateShuffledIndexArrayWithSelection");

	Params::BlueprintFunctionLibrarySCT_CreateShuffledIndexArrayWithSelection Parms{};

	Parms.Seed = Seed;
	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SelectedIndex != nullptr)
		*SelectedIndex = Parms.SelectedIndex;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.DisableLocalCharacterMovementBriefly
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::DisableLocalCharacterMovementBriefly(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "DisableLocalCharacterMovementBriefly");

	Params::BlueprintFunctionLibrarySCT_DisableLocalCharacterMovementBriefly Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetAgendaProgressionColor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAgendaObjectState                      State                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateColor                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FSlateColor UBlueprintFunctionLibrarySCT::GetAgendaProgressionColor(EAgendaObjectState State)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetAgendaProgressionColor");

	Params::BlueprintFunctionLibrarySCT_GetAgendaProgressionColor Parms{};

	Parms.State = State;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetColoredCharacterText
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintFunctionLibrarySCT::GetColoredCharacterText(class UObject* WorldContextObject, int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetColoredCharacterText");

	Params::BlueprintFunctionLibrarySCT_GetColoredCharacterText Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetControllerConnectionState
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutConnected                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OutControllerID                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::GetControllerConnectionState(class APlayerController* InPlayerController, bool* OutConnected, int32* OutControllerID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetControllerConnectionState");

	Params::BlueprintFunctionLibrarySCT_GetControllerConnectionState Parms{};

	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutConnected != nullptr)
		*OutConnected = Parms.OutConnected;

	if (OutControllerID != nullptr)
		*OutControllerID = Parms.OutControllerID;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetDeathEffectDetails
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        Handle                                                 (Parm, NativeAccessSpecifierPublic)
// struct FDeathEffectDetails              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FDeathEffectDetails UBlueprintFunctionLibrarySCT::GetDeathEffectDetails(const struct FGameplayEffectSpecHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetDeathEffectDetails");

	Params::BlueprintFunctionLibrarySCT_GetDeathEffectDetails Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetExecutionSource
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectCustomExecutionParametersExecutionParams                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilitySystemComponent* UBlueprintFunctionLibrarySCT::GetExecutionSource(const struct FGameplayEffectCustomExecutionParameters& ExecutionParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetExecutionSource");

	Params::BlueprintFunctionLibrarySCT_GetExecutionSource Parms{};

	Parms.ExecutionParams = std::move(ExecutionParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetExecutionTarget
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectCustomExecutionParametersExecutionParams                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilitySystemComponent* UBlueprintFunctionLibrarySCT::GetExecutionTarget(const struct FGameplayEffectCustomExecutionParameters& ExecutionParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetExecutionTarget");

	Params::BlueprintFunctionLibrarySCT_GetExecutionTarget Parms{};

	Parms.ExecutionParams = std::move(ExecutionParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetFilterdHighestFromActorToIntMap
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TMap<class AActor*, int32>              UnfilteredActorToInt                                   (Parm, NativeAccessSpecifierPublic)
// bool                                    DuplicateFound                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class AActor*, int32>              OutFilteredActorToInt                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::GetFilterdHighestFromActorToIntMap(const TMap<class AActor*, int32>& UnfilteredActorToInt, bool* DuplicateFound, TMap<class AActor*, int32>* OutFilteredActorToInt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetFilterdHighestFromActorToIntMap");

	Params::BlueprintFunctionLibrarySCT_GetFilterdHighestFromActorToIntMap Parms{};

	Parms.UnfilteredActorToInt = std::move(UnfilteredActorToInt);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DuplicateFound != nullptr)
		*DuplicateFound = Parms.DuplicateFound;

	if (OutFilteredActorToInt != nullptr)
		*OutFilteredActorToInt = std::move(Parms.OutFilteredActorToInt);
}


// Function SCT.BlueprintFunctionLibrarySCT.GetGlobalObject
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UObject>              ObjectType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UBlueprintFunctionLibrarySCT::GetGlobalObject(class UObject* WorldContextObject, TSubclassOf<class UObject> ObjectType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetGlobalObject");

	Params::BlueprintFunctionLibrarySCT_GetGlobalObject Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ObjectType = ObjectType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetIntermediateLevelsFromProjectSettings
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TMap<int32, class FString>              Levels                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::GetIntermediateLevelsFromProjectSettings(TMap<int32, class FString>* Levels)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetIntermediateLevelsFromProjectSettings");

	Params::BlueprintFunctionLibrarySCT_GetIntermediateLevelsFromProjectSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Levels != nullptr)
		*Levels = std::move(Parms.Levels);
}


// Function SCT.BlueprintFunctionLibrarySCT.GetKeyFromCharacterInput
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECharacterInput                         Input                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputActionKeyMapping           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInputActionKeyMapping UBlueprintFunctionLibrarySCT::GetKeyFromCharacterInput(const class UObject* WorldContextObject, ECharacterInput Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetKeyFromCharacterInput");

	Params::BlueprintFunctionLibrarySCT_GetKeyFromCharacterInput Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Input = Input;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetLastControllerType
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESCTControllerType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESCTControllerType UBlueprintFunctionLibrarySCT::GetLastControllerType(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetLastControllerType");

	Params::BlueprintFunctionLibrarySCT_GetLastControllerType Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetLevelVoteData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FLevelVoteData>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLevelVoteData> UBlueprintFunctionLibrarySCT::GetLevelVoteData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetLevelVoteData");

	Params::BlueprintFunctionLibrarySCT_GetLevelVoteData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetLevelVoteManager
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULevelVoteComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULevelVoteComponent* UBlueprintFunctionLibrarySCT::GetLevelVoteManager(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetLevelVoteManager");

	Params::BlueprintFunctionLibrarySCT_GetLevelVoteManager Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetLoadingScreenTexture
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           TargetLevelURL                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UBlueprintFunctionLibrarySCT::GetLoadingScreenTexture(const class FString& TargetLevelURL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetLoadingScreenTexture");

	Params::BlueprintFunctionLibrarySCT_GetLoadingScreenTexture Parms{};

	Parms.TargetLevelURL = std::move(TargetLevelURL);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetLocalSkillcheckController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkillcheckController*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkillcheckController* UBlueprintFunctionLibrarySCT::GetLocalSkillcheckController(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetLocalSkillcheckController");

	Params::BlueprintFunctionLibrarySCT_GetLocalSkillcheckController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetMainMenuPlayerController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AClientEntryPC*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AClientEntryPC* UBlueprintFunctionLibrarySCT::GetMainMenuPlayerController(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetMainMenuPlayerController");

	Params::BlueprintFunctionLibrarySCT_GetMainMenuPlayerController Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetMaxOxygen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlueprintFunctionLibrarySCT::GetMaxOxygen(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetMaxOxygen");

	Params::BlueprintFunctionLibrarySCT_GetMaxOxygen Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetNumberOfPersonoids
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintFunctionLibrarySCT::GetNumberOfPersonoids(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetNumberOfPersonoids");

	Params::BlueprintFunctionLibrarySCT_GetNumberOfPersonoids Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetNumberOfResidents
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintFunctionLibrarySCT::GetNumberOfResidents(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetNumberOfResidents");

	Params::BlueprintFunctionLibrarySCT_GetNumberOfResidents Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetPlayerController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PrintError                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASCTPlayerController*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASCTPlayerController* UBlueprintFunctionLibrarySCT::GetPlayerController(class AActor* Actor, bool PrintError)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetPlayerController");

	Params::BlueprintFunctionLibrarySCT_GetPlayerController Parms{};

	Parms.Actor = Actor;
	Parms.PrintError = PrintError;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetPlayerFaction
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerFaction                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerFaction UBlueprintFunctionLibrarySCT::GetPlayerFaction(class UObject* WorldContextObject, int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetPlayerFaction");

	Params::BlueprintFunctionLibrarySCT_GetPlayerFaction Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetProjectVersionHumanReadableName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintFunctionLibrarySCT::GetProjectVersionHumanReadableName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetProjectVersionHumanReadableName");

	Params::BlueprintFunctionLibrarySCT_GetProjectVersionHumanReadableName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetSelfFaction
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerFaction                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerFaction UBlueprintFunctionLibrarySCT::GetSelfFaction(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetSelfFaction");

	Params::BlueprintFunctionLibrarySCT_GetSelfFaction Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetSteamAvatarFromPlayerID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UBlueprintFunctionLibrarySCT::GetSteamAvatarFromPlayerID(class UObject* WorldContextObject, int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetSteamAvatarFromPlayerID");

	Params::BlueprintFunctionLibrarySCT_GetSteamAvatarFromPlayerID Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetSteamAvatarFromPlayerState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASCTPlayerState*                  PlayerState                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UBlueprintFunctionLibrarySCT::GetSteamAvatarFromPlayerState(class UObject* WorldContextObject, const class ASCTPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetSteamAvatarFromPlayerState");

	Params::BlueprintFunctionLibrarySCT_GetSteamAvatarFromPlayerState Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetSteamAvatarFromSteamID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SteamID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UBlueprintFunctionLibrarySCT::GetSteamAvatarFromSteamID(class UObject* WorldContextObject, const class FString& SteamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetSteamAvatarFromSteamID");

	Params::BlueprintFunctionLibrarySCT_GetSteamAvatarFromSteamID Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SteamID = std::move(SteamID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetTimeUntilFullyDrained
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlueprintFunctionLibrarySCT::GetTimeUntilFullyDrained(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetTimeUntilFullyDrained");

	Params::BlueprintFunctionLibrarySCT_GetTimeUntilFullyDrained Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetWidgetOrganizer
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetOrganizer*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetOrganizer* UBlueprintFunctionLibrarySCT::GetWidgetOrganizer(class AActor* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetWidgetOrganizer");

	Params::BlueprintFunctionLibrarySCT_GetWidgetOrganizer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetWolrdOxygenPercent
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlueprintFunctionLibrarySCT::GetWolrdOxygenPercent(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetWolrdOxygenPercent");

	Params::BlueprintFunctionLibrarySCT_GetWolrdOxygenPercent Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetWorldOxygenLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlueprintFunctionLibrarySCT::GetWorldOxygenLevel(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetWorldOxygenLevel");

	Params::BlueprintFunctionLibrarySCT_GetWorldOxygenLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.GetWorldSettingsSCT
// (Final, Native, Static, Private)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AWorldSettingsSCT*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWorldSettingsSCT* UBlueprintFunctionLibrarySCT::GetWorldSettingsSCT(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "GetWorldSettingsSCT");

	Params::BlueprintFunctionLibrarySCT_GetWorldSettingsSCT Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.HasReplicatedLocalPlayerStateSCT
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::HasReplicatedLocalPlayerStateSCT(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "HasReplicatedLocalPlayerStateSCT");

	Params::BlueprintFunctionLibrarySCT_HasReplicatedLocalPlayerStateSCT Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.HasWorldOxygen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::HasWorldOxygen(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "HasWorldOxygen");

	Params::BlueprintFunctionLibrarySCT_HasWorldOxygen Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.IDToPlayerState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASCTPlayerState*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ASCTPlayerState* UBlueprintFunctionLibrarySCT::IDToPlayerState(class UObject* WorldContextObject, int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "IDToPlayerState");

	Params::BlueprintFunctionLibrarySCT_IDToPlayerState Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.InitialLoadComplete
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCTGameInstance*                 GameInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::InitialLoadComplete(class UObject* WorldContextObject, class USCTGameInstance* GameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "InitialLoadComplete");

	Params::BlueprintFunctionLibrarySCT_InitialLoadComplete Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.GameInstance = GameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.IntegerToHex
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinDigits                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintFunctionLibrarySCT::IntegerToHex(const int32 Value, int32 MinDigits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "IntegerToHex");

	Params::BlueprintFunctionLibrarySCT_IntegerToHex Parms{};

	Parms.Value = Value;
	Parms.MinDigits = MinDigits;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.IsAlive
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EFate                                   Fate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::IsAlive(EFate Fate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "IsAlive");

	Params::BlueprintFunctionLibrarySCT_IsAlive Parms{};

	Parms.Fate = Fate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.IsPlayerPersonoid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::IsPlayerPersonoid(class UObject* WorldContextObject, int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "IsPlayerPersonoid");

	Params::BlueprintFunctionLibrarySCT_IsPlayerPersonoid Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.IsPlayerResident
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::IsPlayerResident(class UObject* WorldContextObject, int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "IsPlayerResident");

	Params::BlueprintFunctionLibrarySCT_IsPlayerResident Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.IsSelfPersonoid
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::IsSelfPersonoid(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "IsSelfPersonoid");

	Params::BlueprintFunctionLibrarySCT_IsSelfPersonoid Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.IsSelfResident
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::IsSelfResident(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "IsSelfResident");

	Params::BlueprintFunctionLibrarySCT_IsSelfResident Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.IsUsingControllerOnPC
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::IsUsingControllerOnPC(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "IsUsingControllerOnPC");

	Params::BlueprintFunctionLibrarySCT_IsUsingControllerOnPC Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.IsValidPlayerID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::IsValidPlayerID(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "IsValidPlayerID");

	Params::BlueprintFunctionLibrarySCT_IsValidPlayerID Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.IsWidgetInActiveMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::IsWidgetInActiveMenu(class UObject* WorldContextObject, class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "IsWidgetInActiveMenu");

	Params::BlueprintFunctionLibrarySCT_IsWidgetInActiveMenu Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.IsWidgetInAnyMenu
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::IsWidgetInAnyMenu(class UObject* WorldContextObject, class UWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "IsWidgetInAnyMenu");

	Params::BlueprintFunctionLibrarySCT_IsWidgetInAnyMenu Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.KeyToText
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UBlueprintFunctionLibrarySCT::KeyToText(const struct FKey& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "KeyToText");

	Params::BlueprintFunctionLibrarySCT_KeyToText Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.LoadGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCTGameInstance*                 GameInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USaveGame* UBlueprintFunctionLibrarySCT::LoadGame(class UObject* WorldContextObject, const class FString& SlotName, class USCTGameInstance* GameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "LoadGame");

	Params::BlueprintFunctionLibrarySCT_LoadGame Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SlotName = std::move(SlotName);
	Parms.GameInstance = GameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.PrintMissingTagsToScreen
// (Final, Native, Static, Public, BlueprintCallable)

void UBlueprintFunctionLibrarySCT::PrintMissingTagsToScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "PrintMissingTagsToScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.RemoveBlockedModalsDuringEmergencyMeeting
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::RemoveBlockedModalsDuringEmergencyMeeting(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "RemoveBlockedModalsDuringEmergencyMeeting");

	Params::BlueprintFunctionLibrarySCT_RemoveBlockedModalsDuringEmergencyMeeting Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.RemoveMenuFromMenuController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      Menu                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCTGameInstance*                 GameInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::RemoveMenuFromMenuController(class UObject* WorldContextObject, class UUserWidget* Menu, class USCTGameInstance* GameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "RemoveMenuFromMenuController");

	Params::BlueprintFunctionLibrarySCT_RemoveMenuFromMenuController Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Menu = Menu;
	Parms.GameInstance = GameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.ResetWorldOxygenLevel
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::ResetWorldOxygenLevel(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "ResetWorldOxygenLevel");

	Params::BlueprintFunctionLibrarySCT_ResetWorldOxygenLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.SaveGame
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        SaveGame_0                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCTGameInstance*                 GameInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::SaveGame(class UObject* WorldContextObject, const class FString& SlotName, class USaveGame* SaveGame_0, class USCTGameInstance* GameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "SaveGame");

	Params::BlueprintFunctionLibrarySCT_SaveGame Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SlotName = std::move(SlotName);
	Parms.SaveGame_0 = SaveGame_0;
	Parms.GameInstance = GameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.SaveGameWithMetaData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USaveGame*                        SaveGame                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             DisplayName                                            (Parm, NativeAccessSpecifierPublic)
// class FText                             DisplaySubtitle                                        (Parm, NativeAccessSpecifierPublic)
// class FText                             DisplayDescription                                     (Parm, NativeAccessSpecifierPublic)
// class FString                           IconPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxBytes                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    KeepMetaData                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCTGameInstance*                 GameInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::SaveGameWithMetaData(class UObject* WorldContextObject, const class FString& SlotName, class USaveGame* SaveGame, const class FText& DisplayName, const class FText& DisplaySubtitle, const class FText& DisplayDescription, const class FString& IconPath, int32 MaxBytes, bool KeepMetaData, class USCTGameInstance* GameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "SaveGameWithMetaData");

	Params::BlueprintFunctionLibrarySCT_SaveGameWithMetaData Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SlotName = std::move(SlotName);
	Parms.SaveGame = SaveGame;
	Parms.DisplayName = std::move(DisplayName);
	Parms.DisplaySubtitle = std::move(DisplaySubtitle);
	Parms.DisplayDescription = std::move(DisplayDescription);
	Parms.IconPath = std::move(IconPath);
	Parms.MaxBytes = MaxBytes;
	Parms.KeepMetaData = KeepMetaData;
	Parms.GameInstance = GameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.SetDownedEffect
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          Target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::SetDownedEffect(class UAbilitySystemComponent* Target, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "SetDownedEffect");

	Params::BlueprintFunctionLibrarySCT_SetDownedEffect Parms{};

	Parms.Target = Target;
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.SetOverlayDialogForMenuController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UUserWidget*                      Menu                                                   (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ZOrder                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    NonInteractable                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCTGameInstance*                 GameInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::SetOverlayDialogForMenuController(class UObject* WorldContextObject, class UUserWidget* Menu, int32 ZOrder, bool NonInteractable, class USCTGameInstance* GameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "SetOverlayDialogForMenuController");

	Params::BlueprintFunctionLibrarySCT_SetOverlayDialogForMenuController Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Menu = Menu;
	Parms.ZOrder = ZOrder;
	Parms.NonInteractable = NonInteractable;
	Parms.GameInstance = GameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.SetSaveGameMetaData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SlotName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             DisplayName                                            (Parm, NativeAccessSpecifierPublic)
// class FText                             DisplaySubtitle                                        (Parm, NativeAccessSpecifierPublic)
// class FText                             DisplayDescription                                     (Parm, NativeAccessSpecifierPublic)
// class FString                           IconPath                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxBytes                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USCTGameInstance*                 GameInstance                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::SetSaveGameMetaData(class UObject* WorldContextObject, const class FString& SlotName, const class FText& DisplayName, const class FText& DisplaySubtitle, const class FText& DisplayDescription, const class FString& IconPath, int32 MaxBytes, class USCTGameInstance* GameInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "SetSaveGameMetaData");

	Params::BlueprintFunctionLibrarySCT_SetSaveGameMetaData Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SlotName = std::move(SlotName);
	Parms.DisplayName = std::move(DisplayName);
	Parms.DisplaySubtitle = std::move(DisplaySubtitle);
	Parms.DisplayDescription = std::move(DisplayDescription);
	Parms.IconPath = std::move(IconPath);
	Parms.MaxBytes = MaxBytes;
	Parms.GameInstance = GameInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.SetWorldOxygenLevel
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::SetWorldOxygenLevel(class UObject* WorldContextObject, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "SetWorldOxygenLevel");

	Params::BlueprintFunctionLibrarySCT_SetWorldOxygenLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.ShouldDisableAirlockInEditor
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::ShouldDisableAirlockInEditor(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "ShouldDisableAirlockInEditor");

	Params::BlueprintFunctionLibrarySCT_ShouldDisableAirlockInEditor Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.ShouldDisableIntroSequence
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibrarySCT::ShouldDisableIntroSequence(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "ShouldDisableIntroSequence");

	Params::BlueprintFunctionLibrarySCT_ShouldDisableIntroSequence Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.ShowSystemInviteDialog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::ShowSystemInviteDialog(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "ShowSystemInviteDialog");

	Params::BlueprintFunctionLibrarySCT_ShowSystemInviteDialog Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.ShowSystemMatchReviewDialog
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::ShowSystemMatchReviewDialog(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "ShowSystemMatchReviewDialog");

	Params::BlueprintFunctionLibrarySCT_ShowSystemMatchReviewDialog Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.ShowSystemProfileForFriend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           AccelByteId                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::ShowSystemProfileForFriend(class UObject* WorldContextObject, const class FString& AccelByteId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "ShowSystemProfileForFriend");

	Params::BlueprintFunctionLibrarySCT_ShowSystemProfileForFriend Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.AccelByteId = std::move(AccelByteId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.ShowSystemProfileForPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::ShowSystemProfileForPlayer(class UObject* WorldContextObject, class AActor* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "ShowSystemProfileForPlayer");

	Params::BlueprintFunctionLibrarySCT_ShowSystemProfileForPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.ShowSystemProfileWithPlatformID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlatformId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::ShowSystemProfileWithPlatformID(class UObject* WorldContextObject, const class FString& PlatformId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "ShowSystemProfileWithPlatformID");

	Params::BlueprintFunctionLibrarySCT_ShowSystemProfileWithPlatformID Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlatformId = std::move(PlatformId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.SortFloatArray
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<float>                           ToSort                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<float> UBlueprintFunctionLibrarySCT::SortFloatArray(const TArray<float>& ToSort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "SortFloatArray");

	Params::BlueprintFunctionLibrarySCT_SortFloatArray Parms{};

	Parms.ToSort = std::move(ToSort);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.SortIntegerArray
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<int32>                           ToSort                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UBlueprintFunctionLibrarySCT::SortIntegerArray(const TArray<int32>& ToSort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "SortIntegerArray");

	Params::BlueprintFunctionLibrarySCT_SortIntegerArray Parms{};

	Parms.ToSort = std::move(ToSort);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintFunctionLibrarySCT.SubtractWorldOxygenLevel
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibrarySCT::SubtractWorldOxygenLevel(class UObject* WorldContextObject, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "SubtractWorldOxygenLevel");

	Params::BlueprintFunctionLibrarySCT_SubtractWorldOxygenLevel Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintFunctionLibrarySCT.ToBitMask
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintFunctionLibrarySCT::ToBitMask(int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibrarySCT", "ToBitMask");

	Params::BlueprintFunctionLibrarySCT_ToBitMask Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BlueprintXboxUserSwitcherCallbackProxy.XboxUserSwitch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlueprintXboxUserSwitcherCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlueprintXboxUserSwitcherCallbackProxy* UBlueprintXboxUserSwitcherCallbackProxy::XboxUserSwitch(class UObject* WorldContextObject, class APlayerController* InPlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintXboxUserSwitcherCallbackProxy", "XboxUserSwitch");

	Params::BlueprintXboxUserSwitcherCallbackProxy_XboxUserSwitch Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPlayerController = InPlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.GlobalEvent.GetBaseDebugString
// (Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGlobalEvent::GetBaseDebugString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEvent", "GetBaseDebugString");

	Params::GlobalEvent_GetBaseDebugString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.GlobalEvent.GetDebugString
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UGlobalEvent::GetDebugString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEvent", "GetDebugString");

	Params::GlobalEvent_GetDebugString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.GlobalEventVoid.Broadcast
// (Final, Native, Public, BlueprintCallable, Const)

void UGlobalEventVoid::Broadcast() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEventVoid", "Broadcast");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.ActivateEquipablePower
// (Final, Native, Protected, BlueprintCallable)

void UPower::ActivateEquipablePower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "ActivateEquipablePower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.CancelCurrentAbility
// (Final, Native, Public, BlueprintCallable)

void UPower::CancelCurrentAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "CancelCurrentAbility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.CancelEquipablePower
// (Final, Native, Protected, BlueprintCallable)

void UPower::CancelEquipablePower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "CancelEquipablePower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.CancelInteraction
// (Final, Native, Protected, BlueprintCallable)

void UPower::CancelInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "CancelInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.ClientCancelInteraction
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UPower::ClientCancelInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "ClientCancelInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.ClientEndInteraction
// (Final, Net, NetReliable, Native, Event, Private, NetClient)

void UPower::ClientEndInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "ClientEndInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.CommitGlobalCooldown
// (Final, Native, Protected, BlueprintCallable)

void UPower::CommitGlobalCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "CommitGlobalCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.CommitLocalCooldown
// (Final, Native, Protected, BlueprintCallable)

void UPower::CommitLocalCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "CommitLocalCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.CommitPowerCooldown
// (Final, Native, Protected, BlueprintCallable)

void UPower::CommitPowerCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "CommitPowerCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.CommitStacks
// (Final, Native, Protected, BlueprintCallable)

void UPower::CommitStacks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "CommitStacks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.ContextStaticMeshAdded
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UContextStaticMeshComponent*      NewContextStaticMeshComponent                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPower::ContextStaticMeshAdded(class UContextStaticMeshComponent* NewContextStaticMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "ContextStaticMeshAdded");

	Params::Power_ContextStaticMeshAdded Parms{};

	Parms.NewContextStaticMeshComponent = NewContextStaticMeshComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.Power.ContextStaticMeshRemoved
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UContextStaticMeshComponent*      RemovedContextStaticMeshComponent                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPower::ContextStaticMeshRemoved(class UContextStaticMeshComponent* RemovedContextStaticMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "ContextStaticMeshRemoved");

	Params::Power_ContextStaticMeshRemoved Parms{};

	Parms.RemovedContextStaticMeshComponent = RemovedContextStaticMeshComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.Power.DeactivateEquipablePower
// (Final, Native, Protected, BlueprintCallable)

void UPower::DeactivateEquipablePower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "DeactivateEquipablePower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.DestroyEquipablePower
// (Final, Native, Protected, BlueprintCallable)

void UPower::DestroyEquipablePower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "DestroyEquipablePower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.Drop
// (Final, Native, Public, BlueprintCallable)

void UPower::Drop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "Drop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.EndCurrentAbility
// (Final, Native, Public, BlueprintCallable)

void UPower::EndCurrentAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "EndCurrentAbility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.EndInteraction
// (Final, Native, Protected, BlueprintCallable)

void UPower::EndInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "EndInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.GetActiveContextDescription
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPower::GetActiveContextDescription()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetActiveContextDescription");

	Params::Power_GetActiveContextDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetContextDescription
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPower::GetContextDescription()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetContextDescription");

	Params::Power_GetContextDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetCooldownContextDescription
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPower::GetCooldownContextDescription()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetCooldownContextDescription");

	Params::Power_GetCooldownContextDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetDefaultContextDescriptionImplementation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPower::GetDefaultContextDescriptionImplementation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetDefaultContextDescriptionImplementation");

	Params::Power_GetDefaultContextDescriptionImplementation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetInactiveContextDescription
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPower::GetInactiveContextDescription()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetInactiveContextDescription");

	Params::Power_GetInactiveContextDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.HideEquipablePower
// (Final, Native, Protected, BlueprintCallable)

void UPower::HideEquipablePower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "HideEquipablePower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.K2_OnRep_EquipablePower
// (Event, Protected, BlueprintEvent)

void UPower::K2_OnRep_EquipablePower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "K2_OnRep_EquipablePower");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.Power.OnAdded
// (Event, Public, BlueprintEvent)

void UPower::OnAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "OnAdded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.Power.OnInputReleased
// (Native, Protected)
// Parameters:
// float                                   Heldtime                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPower::OnInputReleased(float Heldtime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "OnInputReleased");

	Params::Power_OnInputReleased Parms{};

	Parms.Heldtime = Heldtime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.OnRemoved
// (Event, Public, BlueprintEvent)

void UPower::OnRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "OnRemoved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.Power.OnRep_CurrentStackSize
// (Final, Native, Private)

void UPower::OnRep_CurrentStackSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "OnRep_CurrentStackSize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.OnRep_EquipablePower
// (Final, Native, Protected)

void UPower::OnRep_EquipablePower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "OnRep_EquipablePower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.ShowEquipablePower
// (Final, Native, Protected, BlueprintCallable)

void UPower::ShowEquipablePower()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "ShowEquipablePower");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.StartInteraction
// (Final, Native, Protected, BlueprintCallable)

void UPower::StartInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "StartInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Power.CanActivateAbility
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::CanActivateAbility() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "CanActivateAbility");

	Params::Power_CanActivateAbility Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.CanAddMoreStacks
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::CanAddMoreStacks() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "CanAddMoreStacks");

	Params::Power_CanAddMoreStacks Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.CreatePayload
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInteractionPayload              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FInteractionPayload UPower::CreatePayload() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "CreatePayload");

	Params::Power_CreatePayload Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetCooldownTotalDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPower::GetCooldownTotalDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetCooldownTotalDuration");

	Params::Power_GetCooldownTotalDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetDetails
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPowerDetails              ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FPowerDetails UPower::GetDetails() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetDetails");

	Params::Power_GetDetails Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetDropLocation
// (Native, Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPower::GetDropLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetDropLocation");

	Params::Power_GetDropLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetGlobalCooldownEndTime
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPower::GetGlobalCooldownEndTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetGlobalCooldownEndTime");

	Params::Power_GetGlobalCooldownEndTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetGlobalCooldownTotalDuration
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPower::GetGlobalCooldownTotalDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetGlobalCooldownTotalDuration");

	Params::Power_GetGlobalCooldownTotalDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetKeyMapping
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FInputActionKeyMapping           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInputActionKeyMapping UPower::GetKeyMapping() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetKeyMapping");

	Params::Power_GetKeyMapping Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetLastExecutionTime
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPower::GetLastExecutionTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetLastExecutionTime");

	Params::Power_GetLastExecutionTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetLocalCooldownEndTime
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPower::GetLocalCooldownEndTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetLocalCooldownEndTime");

	Params::Power_GetLocalCooldownEndTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetLocalCooldownEndTimeNative
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPower::GetLocalCooldownEndTimeNative() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetLocalCooldownEndTimeNative");

	Params::Power_GetLocalCooldownEndTimeNative Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetLocalCooldownTotalDuration
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPower::GetLocalCooldownTotalDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetLocalCooldownTotalDuration");

	Params::Power_GetLocalCooldownTotalDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetLocalCooldownTotalDurationNative
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPower::GetLocalCooldownTotalDurationNative() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetLocalCooldownTotalDurationNative");

	Params::Power_GetLocalCooldownTotalDurationNative Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetNetTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPower::GetNetTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetNetTime");

	Params::Power_GetNetTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.GetPowerCooldownEndTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPower::GetPowerCooldownEndTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "GetPowerCooldownEndTime");

	Params::Power_GetPowerCooldownEndTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.HasContextInteractionComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::HasContextInteractionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "HasContextInteractionComponent");

	Params::Power_HasContextInteractionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.HasContextStaticMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::HasContextStaticMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "HasContextStaticMesh");

	Params::Power_HasContextStaticMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.IsAnyPowerInUse
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::IsAnyPowerInUse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "IsAnyPowerInUse");

	Params::Power_IsAnyPowerInUse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.IsNetAuthority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::IsNetAuthority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "IsNetAuthority");

	Params::Power_IsNetAuthority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.IsOnCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::IsOnCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "IsOnCooldown");

	Params::Power_IsOnCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.IsOnGlobalCooldown
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::IsOnGlobalCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "IsOnGlobalCooldown");

	Params::Power_IsOnGlobalCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.IsOnLocalCooldown
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::IsOnLocalCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "IsOnLocalCooldown");

	Params::Power_IsOnLocalCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.IsOnLocalCooldownNative
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::IsOnLocalCooldownNative() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "IsOnLocalCooldownNative");

	Params::Power_IsOnLocalCooldownNative Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.IsPretendAction
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::IsPretendAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "IsPretendAction");

	Params::Power_IsPretendAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.K2_CanUseContextSpec
// (Native, Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// struct FContextSpec                     Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::K2_CanUseContextSpec(const struct FContextSpec& Spec) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "K2_CanUseContextSpec");

	Params::Power_K2_CanUseContextSpec Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.K2_GetInteractionComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionComponent* UPower::K2_GetInteractionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "K2_GetInteractionComponent");

	Params::Power_K2_GetInteractionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Power.K2_IsPretendAction
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::K2_IsPretendAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "K2_IsPretendAction");

	Params::Power_K2_IsPretendAction Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SCT.Power.ShouldShowContextUI
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPower::ShouldShowContextUI() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Power", "ShouldShowContextUI");

	Params::Power_ShouldShowContextUI Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Item.GetItemDetails
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FItemDetails               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FItemDetails UItem::GetItemDetails() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Item", "GetItemDetails");

	Params::Item_GetItemDetails Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CharacterOxygenStateManager.OnOxygenChanged
// (Final, Native, Private)
// Parameters:
// float                                   OxygenValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterOxygenStateManager::OnOxygenChanged(float OxygenValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOxygenStateManager", "OnOxygenChanged");

	Params::CharacterOxygenStateManager_OnOxygenChanged Parms{};

	Parms.OxygenValue = OxygenValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CharacterOxygenStateManager.OnRep_CurrentState
// (Final, Native, Private)

void UCharacterOxygenStateManager::OnRep_CurrentState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOxygenStateManager", "OnRep_CurrentState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CharacterOxygenStateManager.GetHumanoidOwner
// (Final, Native, Private, Const)
// Parameters:
// class AHumanoidCharacter*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AHumanoidCharacter* UCharacterOxygenStateManager::GetHumanoidOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterOxygenStateManager", "GetHumanoidOwner");

	Params::CharacterOxygenStateManager_GetHumanoidOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CharacterSCTEvent.Broadcast
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ACharacterSCT*                    NewCharacter                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterSCTEvent::Broadcast(class ACharacterSCT* NewCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterSCTEvent", "Broadcast");

	Params::CharacterSCTEvent_Broadcast Parms{};

	Parms.NewCharacter = NewCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ListAllAbilities
// (Final, Native, Public)

void UCheatComponent::ListAllAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ListAllAbilities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.OutputSpec
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayAbilitySpec             Spec                                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void UCheatComponent::OutputSpec(struct FGameplayAbilitySpec* Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "OutputSpec");

	Params::CheatComponent_OutputSpec Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Spec != nullptr)
		*Spec = std::move(Parms.Spec);
}


// Function SCT.CheatComponent.ServerAddPower
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TSubclassOf<class UPower>               PowerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ACharacterSCT*                    SourceCharacter                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StacksToAdd                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatComponent::ServerAddPower(TSubclassOf<class UPower> PowerType, class ACharacterSCT* SourceCharacter, int32 StacksToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerAddPower");

	Params::CheatComponent_ServerAddPower Parms{};

	Parms.PowerType = PowerType;
	Parms.SourceCharacter = SourceCharacter;
	Parms.StacksToAdd = StacksToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerAssignToSlot
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UPower*                           Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventorySlotID                        SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatComponent::ServerAssignToSlot(class UPower* Power, EInventorySlotID SlotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerAssignToSlot");

	Params::CheatComponent_ServerAssignToSlot Parms{};

	Parms.Power = Power;
	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerChangeLevel
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FSoftObjectPath                  ObjPath                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatComponent::ServerChangeLevel(const struct FSoftObjectPath& ObjPath)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerChangeLevel");

	Params::CheatComponent_ServerChangeLevel Parms{};

	Parms.ObjPath = std::move(ObjPath);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerClearInventory
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void UCheatComponent::ServerClearInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerClearInventory");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerClearSlot
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EInventorySlotID                        SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatComponent::ServerClearSlot(EInventorySlotID SlotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerClearSlot");

	Params::CheatComponent_ServerClearSlot Parms{};

	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerEndMatch
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void UCheatComponent::ServerEndMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerEndMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerForcePostSeamlessTravel
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void UCheatComponent::ServerForcePostSeamlessTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerForcePostSeamlessTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerForcePreSeamlessTravel
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void UCheatComponent::ServerForcePreSeamlessTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerForcePreSeamlessTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerKillSelf
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void UCheatComponent::ServerKillSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerKillSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerListAllAbilities
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void UCheatComponent::ServerListAllAbilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerListAllAbilities");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerRemoveEffectsWithTag
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class UAbilitySystemComponent*          Target                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            Container                                              (Parm, NativeAccessSpecifierPublic)

void UCheatComponent::ServerRemoveEffectsWithTag(class UAbilitySystemComponent* Target, const struct FGameplayTagContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerRemoveEffectsWithTag");

	Params::CheatComponent_ServerRemoveEffectsWithTag Parms{};

	Parms.Target = Target;
	Parms.Container = std::move(Container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerRemovePower
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TSubclassOf<class UPower>               PowerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StacksToRemove                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatComponent::ServerRemovePower(TSubclassOf<class UPower> PowerType, int32 StacksToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerRemovePower");

	Params::CheatComponent_ServerRemovePower Parms{};

	Parms.PowerType = PowerType;
	Parms.StacksToRemove = StacksToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerResurrectSelf
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void UCheatComponent::ServerResurrectSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerResurrectSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerSetOxygen
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatComponent::ServerSetOxygen(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerSetOxygen");

	Params::CheatComponent_ServerSetOxygen Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerSpawnInWorld
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// TSubclassOf<class AActor>               ActorType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCheatComponent::ServerSpawnInWorld(TSubclassOf<class AActor> ActorType, const struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerSpawnInWorld");

	Params::CheatComponent_ServerSpawnInWorld Parms{};

	Parms.ActorType = ActorType;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerTeleportToLocation
// (Net, NetReliable, Native, Event, Public, NetServer, HasDefaults, NetValidate)
// Parameters:
// struct FTransform                       Transform                                              (ConstParm, Parm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UCheatComponent::ServerTeleportToLocation(const struct FTransform& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerTeleportToLocation");

	Params::CheatComponent_ServerTeleportToLocation Parms{};

	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerToggleGodlungs
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void UCheatComponent::ServerToggleGodlungs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerToggleGodlungs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CheatComponent.ServerToggleImmunity
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)

void UCheatComponent::ServerToggleImmunity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CheatComponent", "ServerToggleImmunity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.AddSubComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IInteractionSubComponentInterface>Component                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UInteractionComponent::AddSubComponent(TScriptInterface<class IInteractionSubComponentInterface> Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "AddSubComponent");

	Params::InteractionComponent_AddSubComponent Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.CancelInteraction
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInteractionComponent::CancelInteraction(const struct FInteractionPayload& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "CancelInteraction");

	Params::InteractionComponent_CancelInteraction Parms{};

	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.CancelInteractionSelf
// (Final, Native, Public, BlueprintCallable)

void UInteractionComponent::CancelInteractionSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "CancelInteractionSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.CommitCooldown
// (Final, Native, Public, BlueprintCallable)

void UInteractionComponent::CommitCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "CommitCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.CommitInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void UInteractionComponent::CommitInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "CommitInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.ConsumeExecution
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UInteractionComponent::ConsumeExecution()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "ConsumeExecution");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.EndInteraction
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    WasCancelled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::EndInteraction(const struct FInteractionPayload& Payload, bool WasCancelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "EndInteraction");

	Params::InteractionComponent_EndInteraction Parms{};

	Parms.Payload = std::move(Payload);
	Parms.WasCancelled = WasCancelled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.EndInteractionSelf
// (Final, Native, Public, BlueprintCallable)

void UInteractionComponent::EndInteractionSelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "EndInteractionSelf");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.EndTimerFinished
// (Final, Native, Private)

void UInteractionComponent::EndTimerFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "EndTimerFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.InteractionCancelled
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInteractionComponent::InteractionCancelled(const struct FInteractionPayload& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "InteractionCancelled");

	Params::InteractionComponent_InteractionCancelled Parms{};

	Parms.Payload = std::move(Payload);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.InteractionComponent.InteractionEnded
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    WasCancelled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::InteractionEnded(const struct FInteractionPayload& Payload, bool WasCancelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "InteractionEnded");

	Params::InteractionComponent_InteractionEnded Parms{};

	Parms.Payload = std::move(Payload);
	Parms.WasCancelled = WasCancelled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.InteractionStarted
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInteractionComponent::InteractionStarted(const struct FInteractionPayload& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "InteractionStarted");

	Params::InteractionComponent_InteractionStarted Parms{};

	Parms.Payload = std::move(Payload);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.InteractionComponent.InteractionSuccessful
// (Event, Protected, BlueprintEvent)

void UInteractionComponent::InteractionSuccessful()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "InteractionSuccessful");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.InteractionComponent.MulticastSuccessfulInteraction
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void UInteractionComponent::MulticastSuccessfulInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "MulticastSuccessfulInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.OnIsVisibleChanged
// (Event, Protected, BlueprintEvent)

void UInteractionComponent::OnIsVisibleChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "OnIsVisibleChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.InteractionComponent.OnRep_IsVisible
// (Final, Native, Private)

void UInteractionComponent::OnRep_IsVisible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "OnRep_IsVisible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.RemoveInteractingActor
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::RemoveInteractingActor(const class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "RemoveInteractingActor");

	Params::InteractionComponent_RemoveInteractingActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.RemoveSubComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class IInteractionSubComponentInterface>Component                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)

void UInteractionComponent::RemoveSubComponent(TScriptInterface<class IInteractionSubComponentInterface> Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "RemoveSubComponent");

	Params::InteractionComponent_RemoveSubComponent Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.SetActiveContextDescription
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             Description                                            (Parm, NativeAccessSpecifierPublic)

void UInteractionComponent::SetActiveContextDescription(const class FText& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "SetActiveContextDescription");

	Params::InteractionComponent_SetActiveContextDescription Parms{};

	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.SetAllowMultiplayerInteraction
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::SetAllowMultiplayerInteraction(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "SetAllowMultiplayerInteraction");

	Params::InteractionComponent_SetAllowMultiplayerInteraction Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.SetCooldownContextDescription
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             Description                                            (Parm, NativeAccessSpecifierPublic)

void UInteractionComponent::SetCooldownContextDescription(const class FText& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "SetCooldownContextDescription");

	Params::InteractionComponent_SetCooldownContextDescription Parms{};

	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.SetInactiveContextDescription
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             Description                                            (Parm, NativeAccessSpecifierPublic)

void UInteractionComponent::SetInactiveContextDescription(const class FText& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "SetInactiveContextDescription");

	Params::InteractionComponent_SetInactiveContextDescription Parms{};

	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.SetInProgressContextDescription
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class FText                             Description                                            (Parm, NativeAccessSpecifierPublic)

void UInteractionComponent::SetInProgressContextDescription(const class FText& Description)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "SetInProgressContextDescription");

	Params::InteractionComponent_SetInProgressContextDescription Parms{};

	Parms.Description = std::move(Description);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.SetInteractionEnabled
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::SetInteractionEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "SetInteractionEnabled");

	Params::InteractionComponent_SetInteractionEnabled Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.StartInteraction
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UInteractionComponent::StartInteraction(const struct FInteractionPayload& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "StartInteraction");

	Params::InteractionComponent_StartInteraction Parms{};

	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.SuccessfulInteraction
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UInteractionComponent::SuccessfulInteraction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "SuccessfulInteraction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.ToggleIsVisible
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enabled                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionComponent::ToggleIsVisible(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "ToggleIsVisible");

	Params::InteractionComponent_ToggleIsVisible Parms{};

	Parms.Enabled = Enabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponent.CanActivate
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionComponent::CanActivate(const struct FInteractionPayload& Payload) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "CanActivate");

	Params::InteractionComponent_CanActivate Parms{};

	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionComponent.GetActiveContextDescription
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UInteractionComponent::GetActiveContextDescription(const struct FInteractionPayload& Payload) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "GetActiveContextDescription");

	Params::InteractionComponent_GetActiveContextDescription Parms{};

	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionComponent.GetContextDescription
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UInteractionComponent::GetContextDescription(const struct FInteractionPayload& Payload) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "GetContextDescription");

	Params::InteractionComponent_GetContextDescription Parms{};

	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionComponent.GetCooldownContextDescription
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UInteractionComponent::GetCooldownContextDescription(const struct FInteractionPayload& Payload) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "GetCooldownContextDescription");

	Params::InteractionComponent_GetCooldownContextDescription Parms{};

	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionComponent.GetCooldownEndTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionComponent::GetCooldownEndTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "GetCooldownEndTime");

	Params::InteractionComponent_GetCooldownEndTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionComponent.GetCooldownTotalDuration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UInteractionComponent::GetCooldownTotalDuration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "GetCooldownTotalDuration");

	Params::InteractionComponent_GetCooldownTotalDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionComponent.GetInactiveContextDescription
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UInteractionComponent::GetInactiveContextDescription(const struct FInteractionPayload& Payload) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "GetInactiveContextDescription");

	Params::InteractionComponent_GetInactiveContextDescription Parms{};

	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionComponent.GetInProgressContextDescription
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UInteractionComponent::GetInProgressContextDescription(const struct FInteractionPayload& Payload) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "GetInProgressContextDescription");

	Params::InteractionComponent_GetInProgressContextDescription Parms{};

	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionComponent.IsAnyPayloadControlled
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionComponent::IsAnyPayloadControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "IsAnyPayloadControlled");

	Params::InteractionComponent_IsAnyPayloadControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionComponent.IsInteractionActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionComponent::IsInteractionActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "IsInteractionActive");

	Params::InteractionComponent_IsInteractionActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionComponent.IsOnCooldown
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionComponent::IsOnCooldown() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "IsOnCooldown");

	Params::InteractionComponent_IsOnCooldown Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionComponent.IsVisible
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionComponent::IsVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "IsVisible");

	Params::InteractionComponent_IsVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionComponent.ShouldLockCharacterRotation
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionComponent::ShouldLockCharacterRotation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponent", "ShouldLockCharacterRotation");

	Params::InteractionComponent_ShouldLockCharacterRotation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ClientInfoCacheGIS.Clear
// (Final, Native, Public, BlueprintCallable)

void UClientInfoCacheGIS::Clear()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "Clear");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ClientInfoCacheGIS.GetIdentificationColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UClientInfoCacheGIS::GetIdentificationColor(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "GetIdentificationColor");

	Params::ClientInfoCacheGIS_GetIdentificationColor Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ClientInfoCacheGIS.GetPSNID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UClientInfoCacheGIS::GetPSNID(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "GetPSNID");

	Params::ClientInfoCacheGIS_GetPSNID Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ClientInfoCacheGIS.GetRunningOnPS5
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClientInfoCacheGIS::GetRunningOnPS5(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "GetRunningOnPS5");

	Params::ClientInfoCacheGIS_GetRunningOnPS5 Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ClientInfoCacheGIS.GetSteamID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UClientInfoCacheGIS::GetSteamID(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "GetSteamID");

	Params::ClientInfoCacheGIS_GetSteamID Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ClientInfoCacheGIS.GetXboxLiveID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UClientInfoCacheGIS::GetXboxLiveID(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "GetXboxLiveID");

	Params::ClientInfoCacheGIS_GetXboxLiveID Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ClientInfoCacheGIS.SetHasBeenReported
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    HasBeenReported                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UClientInfoCacheGIS::SetHasBeenReported(int32 PlayerId, bool HasBeenReported)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "SetHasBeenReported");

	Params::ClientInfoCacheGIS_SetHasBeenReported Parms{};

	Parms.PlayerId = PlayerId;
	Parms.HasBeenReported = HasBeenReported;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ClientInfoCacheGIS.GetAllPlayerInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FClientPlayerInfo>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FClientPlayerInfo> UClientInfoCacheGIS::GetAllPlayerInfo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "GetAllPlayerInfo");

	Params::ClientInfoCacheGIS_GetAllPlayerInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ClientInfoCacheGIS.GetPlayerInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FClientPlayerInfo                ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FClientPlayerInfo UClientInfoCacheGIS::GetPlayerInfo(int32 PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "GetPlayerInfo");

	Params::ClientInfoCacheGIS_GetPlayerInfo Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ClientInfoCacheGIS.HasIdentificationColor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClientInfoCacheGIS::HasIdentificationColor(int32 PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "HasIdentificationColor");

	Params::ClientInfoCacheGIS_HasIdentificationColor Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ClientInfoCacheGIS.HasPlayerInfo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClientInfoCacheGIS::HasPlayerInfo(int32 PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "HasPlayerInfo");

	Params::ClientInfoCacheGIS_HasPlayerInfo Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ClientInfoCacheGIS.HasPSNID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClientInfoCacheGIS::HasPSNID(int32 PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "HasPSNID");

	Params::ClientInfoCacheGIS_HasPSNID Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ClientInfoCacheGIS.HasRunningOnPS5
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClientInfoCacheGIS::HasRunningOnPS5(int32 PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "HasRunningOnPS5");

	Params::ClientInfoCacheGIS_HasRunningOnPS5 Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ClientInfoCacheGIS.HasSteamID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClientInfoCacheGIS::HasSteamID(int32 PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "HasSteamID");

	Params::ClientInfoCacheGIS_HasSteamID Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ClientInfoCacheGIS.HasXboxLiveID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClientInfoCacheGIS::HasXboxLiveID(int32 PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientInfoCacheGIS", "HasXboxLiveID");

	Params::ClientInfoCacheGIS_HasXboxLiveID Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ContextPowerManager.AbilitySpecRemoved
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayAbilitySpec             Spec                                                   (Parm, OutParm, NativeAccessSpecifierPublic)

void UContextPowerManager::AbilitySpecRemoved(struct FGameplayAbilitySpec* Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextPowerManager", "AbilitySpecRemoved");

	Params::ContextPowerManager_AbilitySpecRemoved Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Spec != nullptr)
		*Spec = std::move(Parms.Spec);
}


// Function SCT.ContextPowerManager.CheckForIncompatibleTags
// (Final, Native, Private)

void UContextPowerManager::CheckForIncompatibleTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextPowerManager", "CheckForIncompatibleTags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextPowerManager.DisableManager
// (Final, Native, Public)

void UContextPowerManager::DisableManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextPowerManager", "DisableManager");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextPowerManager.EnableManager
// (Final, Native, Public)

void UContextPowerManager::EnableManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextPowerManager", "EnableManager");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextPowerManager.HighestPriorityCleared
// (Final, Native, Private)
// Parameters:
// class UPowerChannel*                    Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPower*                           ClearedPower                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextPowerManager::HighestPriorityCleared(class UPowerChannel* Channel, class UPower* ClearedPower)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextPowerManager", "HighestPriorityCleared");

	Params::ContextPowerManager_HighestPriorityCleared Parms{};

	Parms.Channel = Channel;
	Parms.ClearedPower = ClearedPower;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextPowerManager.HighestPrioritySet
// (Final, Native, Private)
// Parameters:
// class UPowerChannel*                    Channel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextPowerManager::HighestPrioritySet(class UPowerChannel* Channel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextPowerManager", "HighestPrioritySet");

	Params::ContextPowerManager_HighestPrioritySet Parms{};

	Parms.Channel = Channel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextPowerManager.SensorEnabledStateChanged
// (Final, Native, Private)
// Parameters:
// bool                                    SensorEnabled                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextPowerManager::SensorEnabledStateChanged(bool SensorEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextPowerManager", "SensorEnabledStateChanged");

	Params::ContextPowerManager_SensorEnabledStateChanged Parms{};

	Parms.SensorEnabled = SensorEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextPowerManager.SensorUpdate
// (Final, Native, Private)

void UContextPowerManager::SensorUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextPowerManager", "SensorUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextPowerManager.ServerSetPowerContextData
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class UPower*                           Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UContextStaticMeshComponent*      ContextStaticMeshComponent                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextPowerManager::ServerSetPowerContextData(class UPower* Power, class UContextStaticMeshComponent* ContextStaticMeshComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextPowerManager", "ServerSetPowerContextData");

	Params::ContextPowerManager_ServerSetPowerContextData Parms{};

	Parms.Power = Power;
	Parms.ContextStaticMeshComponent = ContextStaticMeshComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextSensor.DisableSensor
// (Final, Native, Public)

void UContextSensor::DisableSensor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextSensor", "DisableSensor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextSensor.EnableSensor
// (Final, Native, Public)

void UContextSensor::EnableSensor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextSensor", "EnableSensor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextSensor.ForceCheckVision
// (Final, Native, Public, BlueprintCallable)

void UContextSensor::ForceCheckVision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextSensor", "ForceCheckVision");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextSensor.OnOwnerTagsChanged
// (Final, Native, Private)

void UContextSensor::OnOwnerTagsChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextSensor", "OnOwnerTagsChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextSensor.OnSenseBegin
// (Final, Native, Private, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult                       SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UContextSensor::OnSenseBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextSensor", "OnSenseBegin");

	Params::ContextSensor_OnSenseBegin Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextSensor.OnSenseEnd
// (Final, Native, Private)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UContextSensor::OnSenseEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextSensor", "OnSenseEnd");

	Params::ContextSensor_OnSenseEnd Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextSensor.AnyHaveTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            Container                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UContextSensor::AnyHaveTag(struct FGameplayTagContainer* Container) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextSensor", "AnyHaveTag");

	Params::ContextSensor_AnyHaveTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Container != nullptr)
		*Container = std::move(Parms.Container);

	return Parms.ReturnValue;
}


// Function SCT.ContextSensor.GetAllSpecs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FContextSpec>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FContextSpec> UContextSensor::GetAllSpecs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextSensor", "GetAllSpecs");

	Params::ContextSensor_GetAllSpecs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ContextSensor.GetAllSpecsFromTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            Container                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// TArray<struct FContextSpec>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FContextSpec> UContextSensor::GetAllSpecsFromTag(struct FGameplayTagContainer* Container) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextSensor", "GetAllSpecsFromTag");

	Params::ContextSensor_GetAllSpecsFromTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Container != nullptr)
		*Container = std::move(Parms.Container);

	return Parms.ReturnValue;
}


// Function SCT.ContextSensor.GetLineOfSightWorldPosition
// (Final, Native, Public, HasDefaults, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UContextSensor::GetLineOfSightWorldPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextSensor", "GetLineOfSightWorldPosition");

	Params::ContextSensor_GetLineOfSightWorldPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ContextSensor.GetSpecFromTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            Container                                              (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FContextSpec                     ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FContextSpec UContextSensor::GetSpecFromTag(struct FGameplayTagContainer* Container) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextSensor", "GetSpecFromTag");

	Params::ContextSensor_GetSpecFromTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Container != nullptr)
		*Container = std::move(Parms.Container);

	return Parms.ReturnValue;
}


// Function SCT.Skill.GetSkillDetails
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FSkillDetails              ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FSkillDetails USkill::GetSkillDetails() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Skill", "GetSkillDetails");

	Params::Skill_GetSkillDetails Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ContextStaticMeshComponent.ConstructLineOfSightLocalPoints
// (Final, Native, Private)

void UContextStaticMeshComponent::ConstructLineOfSightLocalPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextStaticMeshComponent", "ConstructLineOfSightLocalPoints");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextStaticMeshComponent.K2_OnRep_ComponentGameplayTags
// (Event, Protected, BlueprintEvent)

void UContextStaticMeshComponent::K2_OnRep_ComponentGameplayTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextStaticMeshComponent", "K2_OnRep_ComponentGameplayTags");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.ContextStaticMeshComponent.OnRep_ComponentGameplayTags
// (Final, Native, Protected)

void UContextStaticMeshComponent::OnRep_ComponentGameplayTags()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextStaticMeshComponent", "OnRep_ComponentGameplayTags");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ContextStaticMeshComponent.GetAbilitySystemComponentFromOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UAbilitySystemComponentSCT*       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilitySystemComponentSCT* UContextStaticMeshComponent::GetAbilitySystemComponentFromOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextStaticMeshComponent", "GetAbilitySystemComponentFromOwner");

	Params::ContextStaticMeshComponent_GetAbilitySystemComponentFromOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ContextStaticMeshComponent.GetAbilitySystemComponentTagsFromOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UContextStaticMeshComponent::GetAbilitySystemComponentTagsFromOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextStaticMeshComponent", "GetAbilitySystemComponentTagsFromOwner");

	Params::ContextStaticMeshComponent_GetAbilitySystemComponentTagsFromOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ContextStaticMeshComponent.GetContextWidgetWorldPosition
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UContextStaticMeshComponent::GetContextWidgetWorldPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextStaticMeshComponent", "GetContextWidgetWorldPosition");

	Params::ContextStaticMeshComponent_GetContextWidgetWorldPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ContextStaticMeshComponent.HasValidInteractionComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UContextStaticMeshComponent::HasValidInteractionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextStaticMeshComponent", "HasValidInteractionComponent");

	Params::ContextStaticMeshComponent_HasValidInteractionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ContextStaticMeshComponent.IsHighestPriority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UContextStaticMeshComponent::IsHighestPriority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextStaticMeshComponent", "IsHighestPriority");

	Params::ContextStaticMeshComponent_IsHighestPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ContextStaticMeshComponent.K2_GetInteractionComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionComponent* UContextStaticMeshComponent::K2_GetInteractionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ContextStaticMeshComponent", "K2_GetInteractionComponent");

	Params::ContextStaticMeshComponent_K2_GetInteractionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ControllerDisconnectWidget.OnButtonAPressed
// (Event, Public, BlueprintEvent)

void UControllerDisconnectWidget::OnButtonAPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerDisconnectWidget", "OnButtonAPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.ControllerDisconnectWidget.WaitForButtonPress
// (Final, Native, Public, BlueprintCallable)

void UControllerDisconnectWidget::WaitForButtonPress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerDisconnectWidget", "WaitForButtonPress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerHapticsComponent.Play
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UControllerHapticsData*           HapticsData                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundAttenuation*                SpatialAttenuation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UControllerHapticsComponent::Play(const class UControllerHapticsData* HapticsData, class USoundAttenuation* SpatialAttenuation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerHapticsComponent", "Play");

	Params::ControllerHapticsComponent_Play Parms{};

	Parms.HapticsData = HapticsData;
	Parms.SpatialAttenuation = SpatialAttenuation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerHapticsComponent.ResetUseKeyHaptics
// (Final, Native, Public, BlueprintCallable)

void UControllerHapticsComponent::ResetUseKeyHaptics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerHapticsComponent", "ResetUseKeyHaptics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerHapticsComponent.ResistUseKeyPress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   PressRangeStart                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PressRangeEnd                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UControllerHapticsComponent::ResistUseKeyPress(float PressRangeStart, float PressRangeEnd, float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerHapticsComponent", "ResistUseKeyPress");

	Params::ControllerHapticsComponent_ResistUseKeyPress Parms{};

	Parms.PressRangeStart = PressRangeStart;
	Parms.PressRangeEnd = PressRangeEnd;
	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerHapticsComponent.Stop
// (Final, Native, Public, BlueprintCallable)

void UControllerHapticsComponent::Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerHapticsComponent", "Stop");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerIconData.GetControllerIconForKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FKey                             Key                                                    (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESCTControllerType                      ControllerType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OverridePlatformSetting                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UControllerIconData::GetControllerIconForKey(const struct FKey& Key, ESCTControllerType ControllerType, bool OverridePlatformSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerIconData", "GetControllerIconForKey");

	Params::ControllerIconData_GetControllerIconForKey Parms{};

	Parms.Key = std::move(Key);
	Parms.ControllerType = ControllerType;
	Parms.OverridePlatformSetting = OverridePlatformSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ControllerIconWidget.OnRefreshDisplay
// (Final, Native, Private)

void UControllerIconWidget::OnRefreshDisplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerIconWidget", "OnRefreshDisplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerIconWidget.RefreshDisplay
// (Final, Native, Public, BlueprintCallable)

void UControllerIconWidget::RefreshDisplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerIconWidget", "RefreshDisplay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerIconWidget.ResetDisplay
// (Event, Protected, BlueprintEvent)

void UControllerIconWidget::ResetDisplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerIconWidget", "ResetDisplay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.ControllerIconWidget.ShowGamepadDisplay
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       ButtonIcon                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UControllerIconWidget::ShowGamepadDisplay(class UTexture2D* ButtonIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerIconWidget", "ShowGamepadDisplay");

	Params::ControllerIconWidget_ShowGamepadDisplay Parms{};

	Parms.ButtonIcon = ButtonIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.ControllerIconWidget.ShowKeyboardDisplay
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             KeyDisplayText                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UControllerIconWidget::ShowKeyboardDisplay(const class FText& KeyDisplayText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerIconWidget", "ShowKeyboardDisplay");

	Params::ControllerIconWidget_ShowKeyboardDisplay Parms{};

	Parms.KeyDisplayText = std::move(KeyDisplayText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.ControllerIconWidget.ShowMouseDisplay
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UTexture2D*                       MouseIcon                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UControllerIconWidget::ShowMouseDisplay(class UTexture2D* MouseIcon)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerIconWidget", "ShowMouseDisplay");

	Params::ControllerIconWidget_ShowMouseDisplay Parms{};

	Parms.MouseIcon = MouseIcon;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.ControllerIconWidget.GetCurrentKeyText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UControllerIconWidget::GetCurrentKeyText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerIconWidget", "GetCurrentKeyText");

	Params::ControllerIconWidget_GetCurrentKeyText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ControllerInputWidget.ListenForInputActionByPSNRegion
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInputEvent                             EventType                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bConsume                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Callback                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)

void UControllerInputWidget::ListenForInputActionByPSNRegion(const class FName ActionName, const EInputEvent EventType, const bool bConsume, const TDelegate<void()> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerInputWidget", "ListenForInputActionByPSNRegion");

	Params::ControllerInputWidget_ListenForInputActionByPSNRegion Parms{};

	Parms.ActionName = ActionName;
	Parms.EventType = EventType;
	Parms.bConsume = bConsume;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerInputWidget.GetPressedInputActionName
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UControllerInputWidget::GetPressedInputActionName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerInputWidget", "GetPressedInputActionName");

	Params::ControllerInputWidget_GetPressedInputActionName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ControllerSelectionStateWidget.K2_EventOnSelectionPressed
// (Event, Public, BlueprintEvent)

void UControllerSelectionStateWidget::K2_EventOnSelectionPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "K2_EventOnSelectionPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.ControllerSelectionStateWidget.K2_EventOnSelectionReleased
// (Event, Public, BlueprintEvent)

void UControllerSelectionStateWidget::K2_EventOnSelectionReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "K2_EventOnSelectionReleased");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.ControllerSelectionStateWidget.K2_EventOnSetHoveredCosmetics
// (Event, Public, BlueprintEvent)

void UControllerSelectionStateWidget::K2_EventOnSetHoveredCosmetics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "K2_EventOnSetHoveredCosmetics");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.ControllerSelectionStateWidget.K2_EventOnSetNormalCosmetics
// (Event, Public, BlueprintEvent)

void UControllerSelectionStateWidget::K2_EventOnSetNormalCosmetics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "K2_EventOnSetNormalCosmetics");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.ControllerSelectionStateWidget.K2_EventOnSetPressedCosmetics
// (Event, Public, BlueprintEvent)

void UControllerSelectionStateWidget::K2_EventOnSetPressedCosmetics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "K2_EventOnSetPressedCosmetics");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.ControllerSelectionStateWidget.K2_EventOnSetSelectedCosmetics
// (Event, Public, BlueprintEvent)

void UControllerSelectionStateWidget::K2_EventOnSetSelectedCosmetics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "K2_EventOnSetSelectedCosmetics");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.ControllerSelectionStateWidget.OnButtonHovered
// (Final, Native, Public, BlueprintCallable)

void UControllerSelectionStateWidget::OnButtonHovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "OnButtonHovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerSelectionStateWidget.OnButtonPressed
// (Final, Native, Public)

void UControllerSelectionStateWidget::OnButtonPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "OnButtonPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerSelectionStateWidget.OnButtonReleased
// (Final, Native, Public)

void UControllerSelectionStateWidget::OnButtonReleased()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "OnButtonReleased");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerSelectionStateWidget.OnButtonUnhovered
// (Final, Native, Public, BlueprintCallable)

void UControllerSelectionStateWidget::OnButtonUnhovered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "OnButtonUnhovered");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerSelectionStateWidget.SetHoveredCosmetics
// (Native, Public, BlueprintCallable)

void UControllerSelectionStateWidget::SetHoveredCosmetics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "SetHoveredCosmetics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerSelectionStateWidget.SetNormalCosmetics
// (Native, Public, BlueprintCallable)

void UControllerSelectionStateWidget::SetNormalCosmetics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "SetNormalCosmetics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerSelectionStateWidget.SetPressedCosmetics
// (Native, Public, BlueprintCallable)

void UControllerSelectionStateWidget::SetPressedCosmetics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "SetPressedCosmetics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ControllerSelectionStateWidget.SetSelectedCosmetics
// (Native, Public, BlueprintCallable)

void UControllerSelectionStateWidget::SetSelectedCosmetics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ControllerSelectionStateWidget", "SetSelectedCosmetics");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomGameSettingsGIS.ArePersonoidsHidden
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameSettingsGIS::ArePersonoidsHidden()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "ArePersonoidsHidden");

	Params::CustomGameSettingsGIS_ArePersonoidsHidden Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.CacheHostSettings
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FCustomGameSettings              Settings                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UCustomGameSettingsGIS::CacheHostSettings(const struct FCustomGameSettings& Settings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "CacheHostSettings");

	Params::CustomGameSettingsGIS_CacheHostSettings Parms{};

	Parms.Settings = std::move(Settings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomGameSettingsGIS.ClearHostSettings
// (Final, Native, Public, BlueprintCallable)

void UCustomGameSettingsGIS::ClearHostSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "ClearHostSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomGameSettingsGIS.GetAmountOfSyringes
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameSettingsGIS::GetAmountOfSyringes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "GetAmountOfSyringes");

	Params::CustomGameSettingsGIS_GetAmountOfSyringes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.GetCustomGameSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FCustomGameSettings              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCustomGameSettings UCustomGameSettingsGIS::GetCustomGameSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "GetCustomGameSettings");

	Params::CustomGameSettingsGIS_GetCustomGameSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.GetIntermediateLevels
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameSettingsGIS::GetIntermediateLevels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "GetIntermediateLevels");

	Params::CustomGameSettingsGIS_GetIntermediateLevels Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.GetMaxPersonoids
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameSettingsGIS::GetMaxPersonoids()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "GetMaxPersonoids");

	Params::CustomGameSettingsGIS_GetMaxPersonoids Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.GetMinPersonoids
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UCustomGameSettingsGIS::GetMinPersonoids()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "GetMinPersonoids");

	Params::CustomGameSettingsGIS_GetMinPersonoids Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.GetOxygenCanisterMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameSettingsGIS::GetOxygenCanisterMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "GetOxygenCanisterMultiplier");

	Params::CustomGameSettingsGIS_GetOxygenCanisterMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.GetOxygenGeneratorFailedMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameSettingsGIS::GetOxygenGeneratorFailedMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "GetOxygenGeneratorFailedMultiplier");

	Params::CustomGameSettingsGIS_GetOxygenGeneratorFailedMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.GetOxygenGeneratorRepairMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameSettingsGIS::GetOxygenGeneratorRepairMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "GetOxygenGeneratorRepairMultiplier");

	Params::CustomGameSettingsGIS_GetOxygenGeneratorRepairMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.GetOxygenGeneratorSabotageMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameSettingsGIS::GetOxygenGeneratorSabotageMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "GetOxygenGeneratorSabotageMultiplier");

	Params::CustomGameSettingsGIS_GetOxygenGeneratorSabotageMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.GetOxygenMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameSettingsGIS::GetOxygenMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "GetOxygenMultiplier");

	Params::CustomGameSettingsGIS_GetOxygenMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.GetOxygenOutletSabotageMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameSettingsGIS::GetOxygenOutletSabotageMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "GetOxygenOutletSabotageMultiplier");

	Params::CustomGameSettingsGIS_GetOxygenOutletSabotageMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.GetPassengerLogSpawnMultiplier
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UCustomGameSettingsGIS::GetPassengerLogSpawnMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "GetPassengerLogSpawnMultiplier");

	Params::CustomGameSettingsGIS_GetPassengerLogSpawnMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.HasGameSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameSettingsGIS::HasGameSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "HasGameSettings");

	Params::CustomGameSettingsGIS_HasGameSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.IsCatastropheEventEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameSettingsGIS::IsCatastropheEventEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "IsCatastropheEventEnabled");

	Params::CustomGameSettingsGIS_IsCatastropheEventEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomGameSettingsGIS.HasHostSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCustomGameSettingsGIS::HasHostSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomGameSettingsGIS", "HasHostSettings");

	Params::CustomGameSettingsGIS_HasHostSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomizationGenderUserWidget.Init
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class ACustomizationOptions>OptionsClass                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCloudCustomizationPayload       RecordPayload                                          (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCustomizationGenderUserWidget::Init(TSubclassOf<class ACustomizationOptions> OptionsClass, struct FCloudCustomizationPayload& RecordPayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationGenderUserWidget", "Init");

	Params::CustomizationGenderUserWidget_Init Parms{};

	Parms.OptionsClass = OptionsClass;
	Parms.RecordPayload = std::move(RecordPayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	RecordPayload = std::move(Parms.RecordPayload);
}


// Function SCT.CustomizationGenderUserWidget.K2_UpdateEyeMaterial
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationGenderUserWidget::K2_UpdateEyeMaterial(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationGenderUserWidget", "K2_UpdateEyeMaterial");

	Params::CustomizationGenderUserWidget_K2_UpdateEyeMaterial Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CustomizationGenderUserWidget.K2_UpdateHairColor
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationGenderUserWidget::K2_UpdateHairColor(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationGenderUserWidget", "K2_UpdateHairColor");

	Params::CustomizationGenderUserWidget_K2_UpdateHairColor Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CustomizationGenderUserWidget.K2_UpdatePreset
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationGenderUserWidget::K2_UpdatePreset(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationGenderUserWidget", "K2_UpdatePreset");

	Params::CustomizationGenderUserWidget_K2_UpdatePreset Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CustomizationGenderUserWidget.K2_UpdatePrimaryPatternMaterial
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationGenderUserWidget::K2_UpdatePrimaryPatternMaterial(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationGenderUserWidget", "K2_UpdatePrimaryPatternMaterial");

	Params::CustomizationGenderUserWidget_K2_UpdatePrimaryPatternMaterial Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CustomizationGenderUserWidget.K2_UpdateSecondaryPatternMaterial
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationGenderUserWidget::K2_UpdateSecondaryPatternMaterial(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationGenderUserWidget", "K2_UpdateSecondaryPatternMaterial");

	Params::CustomizationGenderUserWidget_K2_UpdateSecondaryPatternMaterial Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CustomizationGenderUserWidget.K2_UpdateSkinMaterial
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationGenderUserWidget::K2_UpdateSkinMaterial(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationGenderUserWidget", "K2_UpdateSkinMaterial");

	Params::CustomizationGenderUserWidget_K2_UpdateSkinMaterial Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CustomizationGenderUserWidget.ValidateCustomizationRecord
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FCloudCustomizationPayload       UnverifiedRecord                                       (Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UCustomizationGenderUserWidget::ValidateCustomizationRecord(struct FCloudCustomizationPayload& UnverifiedRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationGenderUserWidget", "ValidateCustomizationRecord");

	Params::CustomizationGenderUserWidget_ValidateCustomizationRecord Parms{};

	Parms.UnverifiedRecord = std::move(UnverifiedRecord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	UnverifiedRecord = std::move(Parms.UnverifiedRecord);
}


// Function SCT.VruumbaCustomizationScrollBoxUserWidget.HorizontalBoundaryHit
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EUINavigation                           InNavigation                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidget* UVruumbaCustomizationScrollBoxUserWidget::HorizontalBoundaryHit(EUINavigation InNavigation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VruumbaCustomizationScrollBoxUserWidget", "HorizontalBoundaryHit");

	Params::VruumbaCustomizationScrollBoxUserWidget_HorizontalBoundaryHit Parms{};

	Parms.InNavigation = InNavigation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.VruumbaCustomizationScrollBoxUserWidget.K2_UpdateAntenna
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVruumbaCustomizationScrollBoxUserWidget::K2_UpdateAntenna(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VruumbaCustomizationScrollBoxUserWidget", "K2_UpdateAntenna");

	Params::VruumbaCustomizationScrollBoxUserWidget_K2_UpdateAntenna Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.VruumbaCustomizationScrollBoxUserWidget.K2_UpdateBody
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVruumbaCustomizationScrollBoxUserWidget::K2_UpdateBody(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VruumbaCustomizationScrollBoxUserWidget", "K2_UpdateBody");

	Params::VruumbaCustomizationScrollBoxUserWidget_K2_UpdateBody Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.VruumbaCustomizationScrollBoxUserWidget.K2_UpdateExhaust
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVruumbaCustomizationScrollBoxUserWidget::K2_UpdateExhaust(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VruumbaCustomizationScrollBoxUserWidget", "K2_UpdateExhaust");

	Params::VruumbaCustomizationScrollBoxUserWidget_K2_UpdateExhaust Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.VruumbaCustomizationScrollBoxUserWidget.K2_UpdateFan
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVruumbaCustomizationScrollBoxUserWidget::K2_UpdateFan(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VruumbaCustomizationScrollBoxUserWidget", "K2_UpdateFan");

	Params::VruumbaCustomizationScrollBoxUserWidget_K2_UpdateFan Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.VruumbaCustomizationScrollBoxUserWidget.K2_UpdateFlag
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVruumbaCustomizationScrollBoxUserWidget::K2_UpdateFlag(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VruumbaCustomizationScrollBoxUserWidget", "K2_UpdateFlag");

	Params::VruumbaCustomizationScrollBoxUserWidget_K2_UpdateFlag Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.VruumbaCustomizationScrollBoxUserWidget.K2_UpdateParticleEffect
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           Selected                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UVruumbaCustomizationScrollBoxUserWidget::K2_UpdateParticleEffect(const class FString& Selected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("VruumbaCustomizationScrollBoxUserWidget", "K2_UpdateParticleEffect");

	Params::VruumbaCustomizationScrollBoxUserWidget_K2_UpdateParticleEffect Parms{};

	Parms.Selected = std::move(Selected);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CustomizationOptions.AddEyeColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     ThumbnailColor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*                SkinMaterial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACustomizationOptions::AddEyeColor(const struct FLinearColor& ThumbnailColor, class UMaterialInstance* SkinMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "AddEyeColor");

	Params::CustomizationOptions_AddEyeColor Parms{};

	Parms.ThumbnailColor = std::move(ThumbnailColor);
	Parms.SkinMaterial = SkinMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationOptions.AddPreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       IconThumbnail                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<class FString, float>              MorphTargets                                           (Parm, NativeAccessSpecifierPublic)

void ACustomizationOptions::AddPreset(class UTexture2D* IconThumbnail, const TMap<class FString, float>& MorphTargets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "AddPreset");

	Params::CustomizationOptions_AddPreset Parms{};

	Parms.IconThumbnail = IconThumbnail;
	Parms.MorphTargets = std::move(MorphTargets);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationOptions.AddSkinTone
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     ThumbnailColor                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UMaterialInstance*                SkinMaterial                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACustomizationOptions::AddSkinTone(const struct FLinearColor& ThumbnailColor, class UMaterialInstance* SkinMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "AddSkinTone");

	Params::CustomizationOptions_AddSkinTone Parms{};

	Parms.ThumbnailColor = std::move(ThumbnailColor);
	Parms.SkinMaterial = SkinMaterial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationOptions.AddWardrobeOption
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ECustomizationOption                    Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       IconThumbnail                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStreamableRenderAsset*           Mesh                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UMaterialInstance*>        PrimaryPatterns                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UMaterialInstance*>        SecondaryPatterns                                      (Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// TArray<int32>                           PatternCost                                            (Parm, ZeroConstructor, AdvancedDisplay, NativeAccessSpecifierPublic)
// int32                                   UnlockLevel                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2D*                       CharacterMask                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DoMaskLegs                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACustomizationOptions::AddWardrobeOption(ECustomizationOption Type, class UTexture2D* IconThumbnail, class UStreamableRenderAsset* Mesh, const TArray<class UMaterialInstance*>& PrimaryPatterns, const TArray<class UMaterialInstance*>& SecondaryPatterns, const TArray<int32>& PatternCost, int32 UnlockLevel, class UTexture2D* CharacterMask, bool DoMaskLegs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "AddWardrobeOption");

	Params::CustomizationOptions_AddWardrobeOption Parms{};

	Parms.Type = Type;
	Parms.IconThumbnail = IconThumbnail;
	Parms.Mesh = Mesh;
	Parms.PrimaryPatterns = std::move(PrimaryPatterns);
	Parms.SecondaryPatterns = std::move(SecondaryPatterns);
	Parms.PatternCost = std::move(PatternCost);
	Parms.UnlockLevel = UnlockLevel;
	Parms.CharacterMask = CharacterMask;
	Parms.DoMaskLegs = DoMaskLegs;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationOptions.CreateCustomizationOptions
// (Final, Native, Public, BlueprintCallable)

void ACustomizationOptions::CreateCustomizationOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "CreateCustomizationOptions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationOptions.K2_CreateBodyAppearanceOptions
// (Event, Public, BlueprintEvent)

void ACustomizationOptions::K2_CreateBodyAppearanceOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "K2_CreateBodyAppearanceOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.CustomizationOptions.K2_CreateCharacterPresetOptions
// (Event, Public, BlueprintEvent)

void ACustomizationOptions::K2_CreateCharacterPresetOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "K2_CreateCharacterPresetOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.CustomizationOptions.K2_CreateCharacterSkinToneOptions
// (Event, Public, BlueprintEvent)

void ACustomizationOptions::K2_CreateCharacterSkinToneOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "K2_CreateCharacterSkinToneOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.CustomizationOptions.K2_CreateEntitlementsLists
// (Event, Public, BlueprintEvent)

void ACustomizationOptions::K2_CreateEntitlementsLists()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "K2_CreateEntitlementsLists");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.CustomizationOptions.K2_CreateEyeColorOptions
// (Event, Public, BlueprintEvent)

void ACustomizationOptions::K2_CreateEyeColorOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "K2_CreateEyeColorOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.CustomizationOptions.K2_CreateEyewearAppearanceOptions
// (Event, Public, BlueprintEvent)

void ACustomizationOptions::K2_CreateEyewearAppearanceOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "K2_CreateEyewearAppearanceOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.CustomizationOptions.K2_CreateFeetAppearanceOptions
// (Event, Public, BlueprintEvent)

void ACustomizationOptions::K2_CreateFeetAppearanceOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "K2_CreateFeetAppearanceOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.CustomizationOptions.K2_CreateHeadAppearanceOptions
// (Event, Public, BlueprintEvent)

void ACustomizationOptions::K2_CreateHeadAppearanceOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "K2_CreateHeadAppearanceOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.CustomizationOptions.K2_CreateLegsAppearanceOptions
// (Event, Public, BlueprintEvent)

void ACustomizationOptions::K2_CreateLegsAppearanceOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationOptions", "K2_CreateLegsAppearanceOptions");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.CustomizationMenuUserWidget.InitializeMenuTabs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsMale                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationMenuUserWidget::InitializeMenuTabs(bool IsMale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationMenuUserWidget", "InitializeMenuTabs");

	Params::CustomizationMenuUserWidget_InitializeMenuTabs Parms{};

	Parms.IsMale = IsMale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationMenuUserWidget.SwitchToFemaleMenu
// (Final, Native, Public, BlueprintCallable)

void UCustomizationMenuUserWidget::SwitchToFemaleMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationMenuUserWidget", "SwitchToFemaleMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationMenuUserWidget.SwitchToMaleMenu
// (Final, Native, Public, BlueprintCallable)

void UCustomizationMenuUserWidget::SwitchToMaleMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationMenuUserWidget", "SwitchToMaleMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationMenuUserWidget.UpdateGenderTabStates
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UButton*                          FocusedGenderButton                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UButton*                          UnfocusedGenderButton                                  (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationMenuUserWidget::UpdateGenderTabStates(class UButton* FocusedGenderButton, class UButton* UnfocusedGenderButton)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationMenuUserWidget", "UpdateGenderTabStates");

	Params::CustomizationMenuUserWidget_UpdateGenderTabStates Parms{};

	Parms.FocusedGenderButton = FocusedGenderButton;
	Parms.UnfocusedGenderButton = UnfocusedGenderButton;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationMenuUserWidget.ZoomInOnCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPlayerCustomizationType                Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationMenuUserWidget::ZoomInOnCharacter(EPlayerCustomizationType Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationMenuUserWidget", "ZoomInOnCharacter");

	Params::CustomizationMenuUserWidget_ZoomInOnCharacter Parms{};

	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationMenuUserWidget.ZoomOutOfCharacter
// (Final, Native, Public, BlueprintCallable)

void UCustomizationMenuUserWidget::ZoomOutOfCharacter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationMenuUserWidget", "ZoomOutOfCharacter");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationRowUserWidget.AddCustomizationItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FPlayerCustomizationItem         Item                                                   (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class UCustomizationSlotUserWidget>SlotClass                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCustomizationSlotUserWidget*     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCustomizationSlotUserWidget* UCustomizationRowUserWidget::AddCustomizationItem(const struct FPlayerCustomizationItem& Item, TSubclassOf<class UCustomizationSlotUserWidget> SlotClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationRowUserWidget", "AddCustomizationItem");

	Params::CustomizationRowUserWidget_AddCustomizationItem Parms{};

	Parms.Item = std::move(Item);
	Parms.SlotClass = SlotClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomizationRowUserWidget.UpdateUIImmediately
// (Final, Native, Private)

void UCustomizationRowUserWidget::UpdateUIImmediately()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationRowUserWidget", "UpdateUIImmediately");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationRowUserWidget.UpdateUIOverTime
// (Final, Native, Private)

void UCustomizationRowUserWidget::UpdateUIOverTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationRowUserWidget", "UpdateUIOverTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ItemCardUserWidget.BindToNewItemSelected
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomizationScrollBoxUserWidgetBase*CustomizationScrollBoxBase                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemCardUserWidget::BindToNewItemSelected(class UCustomizationScrollBoxUserWidgetBase* CustomizationScrollBoxBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemCardUserWidget", "BindToNewItemSelected");

	Params::ItemCardUserWidget_BindToNewItemSelected Parms{};

	Parms.CustomizationScrollBoxBase = CustomizationScrollBoxBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ItemCardUserWidget.SetCheckboxVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ESlateVisibility                        NewVisibility                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UItemCardUserWidget::SetCheckboxVisibility(ESlateVisibility NewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ItemCardUserWidget", "SetCheckboxVisibility");

	Params::ItemCardUserWidget_SetCheckboxVisibility Parms{};

	Parms.NewVisibility = NewVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationMaterialButtonUserWidget.BindToUpdateEyeMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomizationScrollBoxUserWidget*CustomizationScrollBox                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationMaterialButtonUserWidget::BindToUpdateEyeMaterial(class UCustomizationScrollBoxUserWidget* CustomizationScrollBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationMaterialButtonUserWidget", "BindToUpdateEyeMaterial");

	Params::CustomizationMaterialButtonUserWidget_BindToUpdateEyeMaterial Parms{};

	Parms.CustomizationScrollBox = CustomizationScrollBox;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationMaterialButtonUserWidget.BindToUpdateHairColor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomizationScrollBoxUserWidget*CustomizationScrollBox                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationMaterialButtonUserWidget::BindToUpdateHairColor(class UCustomizationScrollBoxUserWidget* CustomizationScrollBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationMaterialButtonUserWidget", "BindToUpdateHairColor");

	Params::CustomizationMaterialButtonUserWidget_BindToUpdateHairColor Parms{};

	Parms.CustomizationScrollBox = CustomizationScrollBox;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationMaterialButtonUserWidget.BindToUpdateSkinMaterial
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomizationScrollBoxUserWidget*CustomizationScrollBox                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationMaterialButtonUserWidget::BindToUpdateSkinMaterial(class UCustomizationScrollBoxUserWidget* CustomizationScrollBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationMaterialButtonUserWidget", "BindToUpdateSkinMaterial");

	Params::CustomizationMaterialButtonUserWidget_BindToUpdateSkinMaterial Parms{};

	Parms.CustomizationScrollBox = CustomizationScrollBox;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintXboxUserPrivilegeCheckerCallbackProxy.CheckCommunicationPrivilege
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InXboxLiveUserID                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInForceUpdate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlueprintXboxUserPrivilegeCheckerCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlueprintXboxUserPrivilegeCheckerCallbackProxy* UBlueprintXboxUserPrivilegeCheckerCallbackProxy::CheckCommunicationPrivilege(class UObject* WorldContextObject, class APlayerController* InPlayerController, const class FString& InXboxLiveUserID, bool bInForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintXboxUserPrivilegeCheckerCallbackProxy", "CheckCommunicationPrivilege");

	Params::BlueprintXboxUserPrivilegeCheckerCallbackProxy_CheckCommunicationPrivilege Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPlayerController = InPlayerController;
	Parms.InXboxLiveUserID = std::move(InXboxLiveUserID);
	Parms.bInForceUpdate = bInForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CustomizationPresetSlotUserWidget.BindToUpdatePreset
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UCustomizationScrollBoxUserWidget*CustomizationScrollBox                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationPresetSlotUserWidget::BindToUpdatePreset(class UCustomizationScrollBoxUserWidget* CustomizationScrollBox)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationPresetSlotUserWidget", "BindToUpdatePreset");

	Params::CustomizationPresetSlotUserWidget_BindToUpdatePreset Parms{};

	Parms.CustomizationScrollBox = CustomizationScrollBox;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationSlotUserWidget.ChangePlayerClothing_Skeletal
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PrimaryMaterialIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SecondaryMaterialIndex                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSlotUserWidget::ChangePlayerClothing_Skeletal(class UMeshComponent* MeshComponent, int32 PrimaryMaterialIndex, int32 SecondaryMaterialIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSlotUserWidget", "ChangePlayerClothing_Skeletal");

	Params::CustomizationSlotUserWidget_ChangePlayerClothing_Skeletal Parms{};

	Parms.MeshComponent = MeshComponent;
	Parms.PrimaryMaterialIndex = PrimaryMaterialIndex;
	Parms.SecondaryMaterialIndex = SecondaryMaterialIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationSlotUserWidget.ChangePlayerClothing_Static
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UMeshComponent*                   MeshComponent                                          (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PrimaryMaterialIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SecondaryMaterialIndex                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSlotUserWidget::ChangePlayerClothing_Static(class UMeshComponent* MeshComponent, int32 PrimaryMaterialIndex, int32 SecondaryMaterialIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSlotUserWidget", "ChangePlayerClothing_Static");

	Params::CustomizationSlotUserWidget_ChangePlayerClothing_Static Parms{};

	Parms.MeshComponent = MeshComponent;
	Parms.PrimaryMaterialIndex = PrimaryMaterialIndex;
	Parms.SecondaryMaterialIndex = SecondaryMaterialIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.CustomizationSlotUserWidget.OnUpdateHorizontalPaddingOverTime
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   TargetValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSlotUserWidget::OnUpdateHorizontalPaddingOverTime(float TargetValue, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSlotUserWidget", "OnUpdateHorizontalPaddingOverTime");

	Params::CustomizationSlotUserWidget_OnUpdateHorizontalPaddingOverTime Parms{};

	Parms.TargetValue = TargetValue;
	Parms.InterpSpeed = InterpSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CustomizationSlotUserWidget.OnUpdateOpacityOverTime
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   TargetValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSlotUserWidget::OnUpdateOpacityOverTime(float TargetValue, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSlotUserWidget", "OnUpdateOpacityOverTime");

	Params::CustomizationSlotUserWidget_OnUpdateOpacityOverTime Parms{};

	Parms.TargetValue = TargetValue;
	Parms.InterpSpeed = InterpSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CustomizationSlotUserWidget.OnUpdateSizeOverTime
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   TargetValue                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InterpSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSlotUserWidget::OnUpdateSizeOverTime(float TargetValue, float InterpSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSlotUserWidget", "OnUpdateSizeOverTime");

	Params::CustomizationSlotUserWidget_OnUpdateSizeOverTime Parms{};

	Parms.TargetValue = TargetValue;
	Parms.InterpSpeed = InterpSpeed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.CustomizationSlotUserWidget.OnUpdateUIImmediately
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   TargetSize                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetOpacity                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TargetHorizontalPadding                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCustomizationSlotUserWidget::OnUpdateUIImmediately(float TargetSize, float TargetOpacity, float TargetHorizontalPadding)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CustomizationSlotUserWidget", "OnUpdateUIImmediately");

	Params::CustomizationSlotUserWidget_OnUpdateUIImmediately Parms{};

	Parms.TargetSize = TargetSize;
	Parms.TargetOpacity = TargetOpacity;
	Parms.TargetHorizontalPadding = TargetHorizontalPadding;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.EquipablePower.DoHide
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void AEquipablePower::DoHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower", "DoHide");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.EquipablePower.DoShow
// (Native, Event, Protected, BlueprintCallable, BlueprintEvent)

void AEquipablePower::DoShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower", "DoShow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.EquipablePower.Initialize
// (Native, Event, Protected, BlueprintEvent)

void AEquipablePower::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower", "Initialize");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.EquipablePower.K2_OnHide
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AEquipablePower::K2_OnHide()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower", "K2_OnHide");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.EquipablePower.K2_OnShow
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void AEquipablePower::K2_OnShow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower", "K2_OnShow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.EquipablePower.OnEquip
// (Native, Event, Protected, BlueprintEvent)

void AEquipablePower::OnEquip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower", "OnEquip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.EquipablePower.OnInventorySlotAssigned
// (Final, Native, Protected)
// Parameters:
// class UPower*                           PowerChanged                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventorySlotID                        SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEquipablePower::OnInventorySlotAssigned(class UPower* PowerChanged, EInventorySlotID SlotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower", "OnInventorySlotAssigned");

	Params::EquipablePower_OnInventorySlotAssigned Parms{};

	Parms.PowerChanged = PowerChanged;
	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.EquipablePower.OnInventorySlotCleared
// (Final, Native, Protected)
// Parameters:
// class UPower*                           PowerChanged                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventorySlotID                        SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEquipablePower::OnInventorySlotCleared(class UPower* PowerChanged, EInventorySlotID SlotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower", "OnInventorySlotCleared");

	Params::EquipablePower_OnInventorySlotCleared Parms{};

	Parms.PowerChanged = PowerChanged;
	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.EquipablePower.OnRep_Visible
// (Final, Native, Protected)

void AEquipablePower::OnRep_Visible()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower", "OnRep_Visible");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.EquipablePower.OnUnequip
// (Native, Event, Protected, BlueprintEvent)

void AEquipablePower::OnUnequip()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower", "OnUnequip");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.EquipablePower.IsLocallyControlled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AEquipablePower::IsLocallyControlled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipablePower", "IsLocallyControlled");

	Params::EquipablePower_IsLocallyControlled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FactionInfoInterface.GetFaction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EPlayerFaction                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerFaction IFactionInfoInterface::GetFaction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionInfoInterface", "GetFaction");

	Params::FactionInfoInterface_GetFaction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FactionInfoInterface.IsPersonoid
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IFactionInfoInterface::IsPersonoid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionInfoInterface", "IsPersonoid");

	Params::FactionInfoInterface_IsPersonoid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FactionInfoInterface.IsResident
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IFactionInfoInterface::IsResident() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FactionInfoInterface", "IsResident");

	Params::FactionInfoInterface_IsResident Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteAnalytics.CaptureEndOfLevelTelemetry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMapName                                Map                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayersKilledInLevel                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    MatchEnded                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTAccelByteAnalytics::CaptureEndOfLevelTelemetry(EMapName Map, int32 PlayersKilledInLevel, bool MatchEnded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteAnalytics", "CaptureEndOfLevelTelemetry");

	Params::FCTAccelByteAnalytics_CaptureEndOfLevelTelemetry Parms{};

	Parms.Map = Map;
	Parms.PlayersKilledInLevel = PlayersKilledInLevel;
	Parms.MatchEnded = MatchEnded;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccelByteAnalytics.CaptureEndOfMatchTelemetry
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EEndConditions                          EndCondition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        StartTime                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EWinningFaction                         WinningFaction                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTAccelByteAnalytics::CaptureEndOfMatchTelemetry(EEndConditions EndCondition, const struct FDateTime& StartTime, EWinningFaction WinningFaction)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteAnalytics", "CaptureEndOfMatchTelemetry");

	Params::FCTAccelByteAnalytics_CaptureEndOfMatchTelemetry Parms{};

	Parms.EndCondition = EndCondition;
	Parms.StartTime = std::move(StartTime);
	Parms.WinningFaction = WinningFaction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccelByteAnalytics.CaptureFriendlyKillTelemetry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMapName                                Map                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsResident                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsServer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTAccelByteAnalytics::CaptureFriendlyKillTelemetry(EMapName Map, bool IsResident, bool IsServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteAnalytics", "CaptureFriendlyKillTelemetry");

	Params::FCTAccelByteAnalytics_CaptureFriendlyKillTelemetry Parms{};

	Parms.Map = Map;
	Parms.IsResident = IsResident;
	Parms.IsServer = IsServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccelByteAnalytics.CaptureItemInteractionTelemetry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ItemName                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EItemAction                             ItemAction                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMapName                                Map                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsResident                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsServer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTAccelByteAnalytics::CaptureItemInteractionTelemetry(const class FString& UserId, const class FString& ItemName, EItemAction ItemAction, EMapName Map, bool IsResident, bool IsServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteAnalytics", "CaptureItemInteractionTelemetry");

	Params::FCTAccelByteAnalytics_CaptureItemInteractionTelemetry Parms{};

	Parms.UserId = std::move(UserId);
	Parms.ItemName = std::move(ItemName);
	Parms.ItemAction = ItemAction;
	Parms.Map = Map;
	Parms.IsResident = IsResident;
	Parms.IsServer = IsServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccelByteAnalytics.CapturePassengerLogTelemetry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EMapName                                Map                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PassengerLogType                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsResident                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsServer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTAccelByteAnalytics::CapturePassengerLogTelemetry(EMapName Map, const class FString& PassengerLogType, bool IsResident, bool IsServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteAnalytics", "CapturePassengerLogTelemetry");

	Params::FCTAccelByteAnalytics_CapturePassengerLogTelemetry Parms{};

	Parms.Map = Map;
	Parms.PassengerLogType = std::move(PassengerLogType);
	Parms.IsResident = IsResident;
	Parms.IsServer = IsServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccelByteAnalytics.CapturePlayerDeathTelemetry
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EMapName                                Map                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFate                                   Fate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsResident                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsServer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTAccelByteAnalytics::CapturePlayerDeathTelemetry(EMapName Map, EFate Fate, const struct FVector& Location, bool IsResident, bool IsServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteAnalytics", "CapturePlayerDeathTelemetry");

	Params::FCTAccelByteAnalytics_CapturePlayerDeathTelemetry Parms{};

	Parms.Map = Map;
	Parms.Fate = Fate;
	Parms.Location = std::move(Location);
	Parms.IsResident = IsResident;
	Parms.IsServer = IsServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccelByteAnalytics.CapturePlayerEndOfMatchTelemetry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFate                                   Fate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ExperienceEarned                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsResident                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsServer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTAccelByteAnalytics::CapturePlayerEndOfMatchTelemetry(const class FString& UserId, EFate Fate, int32 ExperienceEarned, bool IsResident, bool IsServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteAnalytics", "CapturePlayerEndOfMatchTelemetry");

	Params::FCTAccelByteAnalytics_CapturePlayerEndOfMatchTelemetry Parms{};

	Parms.UserId = std::move(UserId);
	Parms.Fate = Fate;
	Parms.ExperienceEarned = ExperienceEarned;
	Parms.IsResident = IsResident;
	Parms.IsServer = IsServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccelByteAnalytics.CaptureSkillCheckTelemetry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    SkillcheckSuccessful                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PlayerAIsResident                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PlayerBIsResident                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsServer                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTAccelByteAnalytics::CaptureSkillCheckTelemetry(bool SkillcheckSuccessful, bool PlayerAIsResident, bool PlayerBIsResident, bool IsServer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteAnalytics", "CaptureSkillCheckTelemetry");

	Params::FCTAccelByteAnalytics_CaptureSkillCheckTelemetry Parms{};

	Parms.SkillcheckSuccessful = SkillcheckSuccessful;
	Parms.PlayerAIsResident = PlayerAIsResident;
	Parms.PlayerBIsResident = PlayerBIsResident;
	Parms.IsServer = IsServer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccelByteLinkAccountsCallbackProxy.ForceLinkHeadlessWithVersusEvilAccount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTAccelByteLinkAccountsCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteLinkAccountsCallbackProxy* UFCTAccelByteLinkAccountsCallbackProxy::ForceLinkHeadlessWithVersusEvilAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteLinkAccountsCallbackProxy", "ForceLinkHeadlessWithVersusEvilAccount");

	Params::FCTAccelByteLinkAccountsCallbackProxy_ForceLinkHeadlessWithVersusEvilAccount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteLinkAccountsCallbackProxy.LoginAndLinkPlatformAccount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Email                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Password                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteLinkAccountsCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteLinkAccountsCallbackProxy* UFCTAccelByteLinkAccountsCallbackProxy::LoginAndLinkPlatformAccount(const class FString& Email, const class FString& Password)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteLinkAccountsCallbackProxy", "LoginAndLinkPlatformAccount");

	Params::FCTAccelByteLinkAccountsCallbackProxy_LoginAndLinkPlatformAccount Parms{};

	Parms.Email = std::move(Email);
	Parms.Password = std::move(Password);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteLinkAccountsCallbackProxy.LogIntoVersusEvilAccount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Email                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Password                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteLinkAccountsCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteLinkAccountsCallbackProxy* UFCTAccelByteLinkAccountsCallbackProxy::LogIntoVersusEvilAccount(const class FString& Email, const class FString& Password)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteLinkAccountsCallbackProxy", "LogIntoVersusEvilAccount");

	Params::FCTAccelByteLinkAccountsCallbackProxy_LogIntoVersusEvilAccount Parms{};

	Parms.Email = std::move(Email);
	Parms.Password = std::move(Password);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteLinkAccountsCallbackProxy.RegisterAndLinkPlatformAccount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Email                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Password                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DisplayName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Country                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DateOfBirth                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteLinkAccountsCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteLinkAccountsCallbackProxy* UFCTAccelByteLinkAccountsCallbackProxy::RegisterAndLinkPlatformAccount(const class FString& Email, const class FString& Password, const class FString& DisplayName, const class FString& Country, const class FString& DateOfBirth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteLinkAccountsCallbackProxy", "RegisterAndLinkPlatformAccount");

	Params::FCTAccelByteLinkAccountsCallbackProxy_RegisterAndLinkPlatformAccount Parms{};

	Parms.Email = std::move(Email);
	Parms.Password = std::move(Password);
	Parms.DisplayName = std::move(DisplayName);
	Parms.Country = std::move(Country);
	Parms.DateOfBirth = std::move(DateOfBirth);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteLinkAccountsCallbackProxy.UnlinkCurrentPlatformFromVersusEvilAccount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTAccelByteLinkAccountsCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteLinkAccountsCallbackProxy* UFCTAccelByteLinkAccountsCallbackProxy::UnlinkCurrentPlatformFromVersusEvilAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteLinkAccountsCallbackProxy", "UnlinkCurrentPlatformFromVersusEvilAccount");

	Params::FCTAccelByteLinkAccountsCallbackProxy_UnlinkCurrentPlatformFromVersusEvilAccount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteLinkPlatformCallbackProxy.LinkCurrentPlatform
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Email                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Password                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteLinkPlatformCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteLinkPlatformCallbackProxy* UFCTAccelByteLinkPlatformCallbackProxy::LinkCurrentPlatform(const class FString& Email, const class FString& Password)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteLinkPlatformCallbackProxy", "LinkCurrentPlatform");

	Params::FCTAccelByteLinkPlatformCallbackProxy_LinkCurrentPlatform Parms{};

	Parms.Email = std::move(Email);
	Parms.Password = std::move(Password);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAuthLogoutCallbackProxy.Logout
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTAuthLogoutCallbackProxy*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAuthLogoutCallbackProxy* UFCTAuthLogoutCallbackProxy::Logout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAuthLogoutCallbackProxy", "Logout");

	Params::FCTAuthLogoutCallbackProxy_Logout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAuthUpgradeAccountCallbackProxy.UpgradeHeadlessAccount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Email                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Password                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAuthUpgradeAccountCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAuthUpgradeAccountCallbackProxy* UFCTAuthUpgradeAccountCallbackProxy::UpgradeHeadlessAccount(const class FString& Email, const class FString& Password)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAuthUpgradeAccountCallbackProxy", "UpgradeHeadlessAccount");

	Params::FCTAuthUpgradeAccountCallbackProxy_UpgradeHeadlessAccount Parms{};

	Parms.Email = std::move(Email);
	Parms.Password = std::move(Password);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAuthUpgradeAccountCallbackProxy.UpgradeHeadlessAccountAndVerify
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Email                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Password                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           VerificationCode                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAuthUpgradeAccountCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAuthUpgradeAccountCallbackProxy* UFCTAuthUpgradeAccountCallbackProxy::UpgradeHeadlessAccountAndVerify(const class FString& Email, const class FString& Password, const class FString& VerificationCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAuthUpgradeAccountCallbackProxy", "UpgradeHeadlessAccountAndVerify");

	Params::FCTAuthUpgradeAccountCallbackProxy_UpgradeHeadlessAccountAndVerify Parms{};

	Parms.Email = std::move(Email);
	Parms.Password = std::move(Password);
	Parms.VerificationCode = std::move(VerificationCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAuthSendVerificationCodeCallbackProxy.SendVerificationCodeForAccount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTAuthSendVerificationCodeCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAuthSendVerificationCodeCallbackProxy* UFCTAuthSendVerificationCodeCallbackProxy::SendVerificationCodeForAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAuthSendVerificationCodeCallbackProxy", "SendVerificationCodeForAccount");

	Params::FCTAuthSendVerificationCodeCallbackProxy_SendVerificationCodeForAccount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAuthSendVerificationCodeCallbackProxy.SendVerificationCodeForUpgrade
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Email                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAuthSendVerificationCodeCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAuthSendVerificationCodeCallbackProxy* UFCTAuthSendVerificationCodeCallbackProxy::SendVerificationCodeForUpgrade(const class FString& Email)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAuthSendVerificationCodeCallbackProxy", "SendVerificationCodeForUpgrade");

	Params::FCTAuthSendVerificationCodeCallbackProxy_SendVerificationCodeForUpgrade Parms{};

	Parms.Email = std::move(Email);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTForgotPasswordCallbackProxy.ResetPassword
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           VerificationCode                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Email                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewPassword                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReEnteredPassword                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTForgotPasswordCallbackProxy*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTForgotPasswordCallbackProxy* UFCTForgotPasswordCallbackProxy::ResetPassword(const class FString& VerificationCode, const class FString& Email, const class FString& NewPassword, const class FString& ReEnteredPassword)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTForgotPasswordCallbackProxy", "ResetPassword");

	Params::FCTForgotPasswordCallbackProxy_ResetPassword Parms{};

	Parms.VerificationCode = std::move(VerificationCode);
	Parms.Email = std::move(Email);
	Parms.NewPassword = std::move(NewPassword);
	Parms.ReEnteredPassword = std::move(ReEnteredPassword);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTForgotPasswordCallbackProxy.SendResetPasswordRequest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Email                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTForgotPasswordCallbackProxy*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTForgotPasswordCallbackProxy* UFCTForgotPasswordCallbackProxy::SendResetPasswordRequest(const class FString& Email)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTForgotPasswordCallbackProxy", "SendResetPasswordRequest");

	Params::FCTForgotPasswordCallbackProxy_SendResetPasswordRequest Parms{};

	Parms.Email = std::move(Email);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAuthVerifyAccountCallbackProxy.VerifyExistingAccount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           VerificationCode                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAuthVerifyAccountCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAuthVerifyAccountCallbackProxy* UFCTAuthVerifyAccountCallbackProxy::VerifyExistingAccount(const class FString& VerificationCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAuthVerifyAccountCallbackProxy", "VerifyExistingAccount");

	Params::FCTAuthVerifyAccountCallbackProxy_VerifyExistingAccount Parms{};

	Parms.VerificationCode = std::move(VerificationCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAuthVerifyAccountCallbackProxy.VerifyUpgradedAccount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Email                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Password                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           VerificationCode                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAuthVerifyAccountCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAuthVerifyAccountCallbackProxy* UFCTAuthVerifyAccountCallbackProxy::VerifyUpgradedAccount(const class FString& Email, const class FString& Password, const class FString& VerificationCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAuthVerifyAccountCallbackProxy", "VerifyUpgradedAccount");

	Params::FCTAuthVerifyAccountCallbackProxy_VerifyUpgradedAccount Parms{};

	Parms.Email = std::move(Email);
	Parms.Password = std::move(Password);
	Parms.VerificationCode = std::move(VerificationCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTQueryLegalEligibilitiesCallbackProxy.QueryVersusEvilLegalEligibilities
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTQueryLegalEligibilitiesCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTQueryLegalEligibilitiesCallbackProxy* UFCTQueryLegalEligibilitiesCallbackProxy::QueryVersusEvilLegalEligibilities()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTQueryLegalEligibilitiesCallbackProxy", "QueryVersusEvilLegalEligibilities");

	Params::FCTQueryLegalEligibilitiesCallbackProxy_QueryVersusEvilLegalEligibilities Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTQueryLegalEligibilitiesCallbackProxy.QueryVersusEvilLegalEligibilitiesByCountry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CultureCode                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTQueryLegalEligibilitiesCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTQueryLegalEligibilitiesCallbackProxy* UFCTQueryLegalEligibilitiesCallbackProxy::QueryVersusEvilLegalEligibilitiesByCountry(const class FString& CultureCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTQueryLegalEligibilitiesCallbackProxy", "QueryVersusEvilLegalEligibilitiesByCountry");

	Params::FCTQueryLegalEligibilitiesCallbackProxy_QueryVersusEvilLegalEligibilitiesByCountry Parms{};

	Parms.CultureCode = std::move(CultureCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.UserSettingsGIS.ClearAll
// (Final, Native, Public, BlueprintCallable)

void UUserSettingsGIS::ClearAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserSettingsGIS", "ClearAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.UserSettingsGIS.GetSetting
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSubclassOf<class USettingsObject>      ClassType                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USettingsObject*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USettingsObject* UUserSettingsGIS::GetSetting(const TSubclassOf<class USettingsObject>& ClassType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserSettingsGIS", "GetSetting");

	Params::UserSettingsGIS_GetSetting Parms{};

	Parms.ClassType = ClassType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.UserSettingsGIS.SaveAll
// (Final, Native, Public, BlueprintCallable)

void UUserSettingsGIS::SaveAll()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserSettingsGIS", "SaveAll");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAcceptLegalPolicyCallbackProxy.AcceptVersusEvilPolict
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           LocalizedVersionId                                     (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAcceptLegalPolicyCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAcceptLegalPolicyCallbackProxy* UFCTAcceptLegalPolicyCallbackProxy::AcceptVersusEvilPolict(const class FString& LocalizedVersionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAcceptLegalPolicyCallbackProxy", "AcceptVersusEvilPolict");

	Params::FCTAcceptLegalPolicyCallbackProxy_AcceptVersusEvilPolict Parms{};

	Parms.LocalizedVersionId = std::move(LocalizedVersionId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteAuthenticationWidget.PasswordIsValid
// (Final, Native, Private, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Password                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ConfirmedPassword                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Code                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFCTAccelByteAuthenticationWidget::PasswordIsValid(const class FString& Password, const class FString& ConfirmedPassword, int32* Code)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCTAccelByteAuthenticationWidget", "PasswordIsValid");

	Params::FCTAccelByteAuthenticationWidget_PasswordIsValid Parms{};

	Parms.Password = std::move(Password);
	Parms.ConfirmedPassword = std::move(ConfirmedPassword);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Code != nullptr)
		*Code = Parms.Code;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteAvatarCacheGIS.GetCachedAvatar
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InAccelByteID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture2DDynamic*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2DDynamic* UFCTAccelByteAvatarCacheGIS::GetCachedAvatar(const class FString& InAccelByteID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCTAccelByteAvatarCacheGIS", "GetCachedAvatar");

	Params::FCTAccelByteAvatarCacheGIS_GetCachedAvatar Parms{};

	Parms.InAccelByteID = std::move(InAccelByteID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AccelByteAvatarCacheCallbackProxy.GetCachedAvatarAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InAccelByteID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAccelByteAvatarCacheCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAccelByteAvatarCacheCallbackProxy* UAccelByteAvatarCacheCallbackProxy::GetCachedAvatarAsync(class UObject* WorldContextObject, const class FString& InAccelByteID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AccelByteAvatarCacheCallbackProxy", "GetCachedAvatarAsync");

	Params::AccelByteAvatarCacheCallbackProxy_GetCachedAvatarAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InAccelByteID = std::move(InAccelByteID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.AccelByteAvatarCacheCallbackProxy.GetCachedAvatarForPrimaryUserAsync
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAccelByteAvatarCacheCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAccelByteAvatarCacheCallbackProxy* UAccelByteAvatarCacheCallbackProxy::GetCachedAvatarForPrimaryUserAsync(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AccelByteAvatarCacheCallbackProxy", "GetCachedAvatarForPrimaryUserAsync");

	Params::AccelByteAvatarCacheCallbackProxy_GetCachedAvatarForPrimaryUserAsync Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTClaimCampaignEntitlementCallbackProxy.RedeemCode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Code                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTClaimCampaignEntitlementCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTClaimCampaignEntitlementCallbackProxy* UFCTClaimCampaignEntitlementCallbackProxy::RedeemCode(const class FString& Code)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTClaimCampaignEntitlementCallbackProxy", "RedeemCode");

	Params::FCTClaimCampaignEntitlementCallbackProxy_RedeemCode Parms{};

	Parms.Code = std::move(Code);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SkillcheckWidget.K2_Initialize
// (Event, Protected, BlueprintEvent)

void USkillcheckWidget::K2_Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillcheckWidget", "K2_Initialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SkillcheckWidget.SkillcheckFailed
// (Final, Native, Protected, BlueprintCallable)

void USkillcheckWidget::SkillcheckFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillcheckWidget", "SkillcheckFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SkillcheckWidget.SkillcheckSucceeded
// (Final, Native, Protected, BlueprintCallable)

void USkillcheckWidget::SkillcheckSucceeded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillcheckWidget", "SkillcheckSucceeded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SkillcheckWidget.StartSkillcheck
// (Event, Public, BlueprintEvent)

void USkillcheckWidget::StartSkillcheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillcheckWidget", "StartSkillcheck");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.FCTRedeemCodeCallbackProxy.RedeemCode
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Code                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTRedeemCodeCallbackProxy*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTRedeemCodeCallbackProxy* UFCTRedeemCodeCallbackProxy::RedeemCode(const class FString& Code)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTRedeemCodeCallbackProxy", "RedeemCode");

	Params::FCTRedeemCodeCallbackProxy_RedeemCode Parms{};

	Parms.Code = std::move(Code);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetWalletCallbackProxy.GetWallet
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EPremiumCurrency                        Currency                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTGetWalletCallbackProxy*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetWalletCallbackProxy* UFCTGetWalletCallbackProxy::GetWallet(EPremiumCurrency Currency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetWalletCallbackProxy", "GetWallet");

	Params::FCTGetWalletCallbackProxy_GetWallet Parms{};

	Parms.Currency = Currency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTQueryEntitlementsCallbackProxy.QueryUserEntitlementByItemID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ItemId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTQueryEntitlementsCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTQueryEntitlementsCallbackProxy* UFCTQueryEntitlementsCallbackProxy::QueryUserEntitlementByItemID(const class FString& ItemId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTQueryEntitlementsCallbackProxy", "QueryUserEntitlementByItemID");

	Params::FCTQueryEntitlementsCallbackProxy_QueryUserEntitlementByItemID Parms{};

	Parms.ItemId = std::move(ItemId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTQueryEntitlementsCallbackProxy.QueryUserEntitlements
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTQueryEntitlementsCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTQueryEntitlementsCallbackProxy* UFCTQueryEntitlementsCallbackProxy::QueryUserEntitlements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTQueryEntitlementsCallbackProxy", "QueryUserEntitlements");

	Params::FCTQueryEntitlementsCallbackProxy_QueryUserEntitlements Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetBulkDLCPacksCallbackProxy.GetBulkDLCPacks
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           CultureCode                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTGetBulkDLCPacksCallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetBulkDLCPacksCallbackProxy* UFCTGetBulkDLCPacksCallbackProxy::GetBulkDLCPacks(const class FString& CultureCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetBulkDLCPacksCallbackProxy", "GetBulkDLCPacks");

	Params::FCTGetBulkDLCPacksCallbackProxy_GetBulkDLCPacks Parms{};

	Parms.CultureCode = std::move(CultureCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTSyncPlatformPurchases.SyncPlatformPurchases
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    bInForceSync                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTSyncPlatformPurchases*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTSyncPlatformPurchases* UFCTSyncPlatformPurchases::SyncPlatformPurchases(bool bInForceSync)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTSyncPlatformPurchases", "SyncPlatformPurchases");

	Params::FCTSyncPlatformPurchases_SyncPlatformPurchases Parms{};

	Parms.bInForceSync = bInForceSync;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetTexturesFromUrlCallbackProxy.GetDLCTextures
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FBulkDLCPacksData                BulkDLCData                                            (Parm, NativeAccessSpecifierPublic)
// class UFCTGetTexturesFromUrlCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetTexturesFromUrlCallbackProxy* UFCTGetTexturesFromUrlCallbackProxy::GetDLCTextures(const struct FBulkDLCPacksData& BulkDLCData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetTexturesFromUrlCallbackProxy", "GetDLCTextures");

	Params::FCTGetTexturesFromUrlCallbackProxy_GetDLCTextures Parms{};

	Parms.BulkDLCData = std::move(BulkDLCData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetFriendsListAsyncProxy.GetFriendsList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTGetFriendsListAsyncProxy*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetFriendsListAsyncProxy* UFCTGetFriendsListAsyncProxy::GetFriendsList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetFriendsListAsyncProxy", "GetFriendsList");

	Params::FCTGetFriendsListAsyncProxy_GetFriendsList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetFriendsListAsyncProxy.GetIncomingList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTGetFriendsListAsyncProxy*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetFriendsListAsyncProxy* UFCTGetFriendsListAsyncProxy::GetIncomingList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetFriendsListAsyncProxy", "GetIncomingList");

	Params::FCTGetFriendsListAsyncProxy_GetIncomingList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetFriendsListAsyncProxy.GetOnlineUsersRequest
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTGetFriendsListAsyncProxy*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetFriendsListAsyncProxy* UFCTGetFriendsListAsyncProxy::GetOnlineUsersRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetFriendsListAsyncProxy", "GetOnlineUsersRequest");

	Params::FCTGetFriendsListAsyncProxy_GetOnlineUsersRequest Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetFriendsListAsyncProxy.GetOutgoingList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTGetFriendsListAsyncProxy*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetFriendsListAsyncProxy* UFCTGetFriendsListAsyncProxy::GetOutgoingList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetFriendsListAsyncProxy", "GetOutgoingList");

	Params::FCTGetFriendsListAsyncProxy_GetOutgoingList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetFriendsListAsyncProxy.GetRecentList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTGetFriendsListAsyncProxy*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetFriendsListAsyncProxy* UFCTGetFriendsListAsyncProxy::GetRecentList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetFriendsListAsyncProxy", "GetRecentList");

	Params::FCTGetFriendsListAsyncProxy_GetRecentList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetFriendsListAsyncProxy.SearchForUser
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Username                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTGetFriendsListAsyncProxy*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetFriendsListAsyncProxy* UFCTGetFriendsListAsyncProxy::SearchForUser(const class FString& Username)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetFriendsListAsyncProxy", "SearchForUser");

	Params::FCTGetFriendsListAsyncProxy_SearchForUser Parms{};

	Parms.Username = std::move(Username);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetFriendProfileAsyncProxy.GetFriendProfileById
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FriendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTGetFriendProfileAsyncProxy*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetFriendProfileAsyncProxy* UFCTGetFriendProfileAsyncProxy::GetFriendProfileById(const class FString& FriendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetFriendProfileAsyncProxy", "GetFriendProfileById");

	Params::FCTGetFriendProfileAsyncProxy_GetFriendProfileById Parms{};

	Parms.FriendId = std::move(FriendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetRecentlyPlayedWithListAsyncProxy.AddPlayerToRecentlyPlayedWithList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTGetRecentlyPlayedWithListAsyncProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetRecentlyPlayedWithListAsyncProxy* UFCTGetRecentlyPlayedWithListAsyncProxy::AddPlayerToRecentlyPlayedWithList(const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetRecentlyPlayedWithListAsyncProxy", "AddPlayerToRecentlyPlayedWithList");

	Params::FCTGetRecentlyPlayedWithListAsyncProxy_AddPlayerToRecentlyPlayedWithList Parms{};

	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetRecentlyPlayedWithListAsyncProxy.CacheMostRecentlyPlayedWith
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAccelByteGIS*                    AccelByteGIS                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTGetRecentlyPlayedWithListAsyncProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetRecentlyPlayedWithListAsyncProxy* UFCTGetRecentlyPlayedWithListAsyncProxy::CacheMostRecentlyPlayedWith(class UAccelByteGIS* AccelByteGIS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetRecentlyPlayedWithListAsyncProxy", "CacheMostRecentlyPlayedWith");

	Params::FCTGetRecentlyPlayedWithListAsyncProxy_CacheMostRecentlyPlayedWith Parms{};

	Parms.AccelByteGIS = AccelByteGIS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetRecentlyPlayedWithListAsyncProxy.GetRecentlyPlayedWithList
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTGetRecentlyPlayedWithListAsyncProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetRecentlyPlayedWithListAsyncProxy* UFCTGetRecentlyPlayedWithListAsyncProxy::GetRecentlyPlayedWithList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetRecentlyPlayedWithListAsyncProxy", "GetRecentlyPlayedWithList");

	Params::FCTGetRecentlyPlayedWithListAsyncProxy_GetRecentlyPlayedWithList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTFriendRelationshipAsyncProxy.GetFriendRelationshipStatus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTFriendRelationshipAsyncProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTFriendRelationshipAsyncProxy* UFCTFriendRelationshipAsyncProxy::GetFriendRelationshipStatus(const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTFriendRelationshipAsyncProxy", "GetFriendRelationshipStatus");

	Params::FCTFriendRelationshipAsyncProxy_GetFriendRelationshipStatus Parms{};

	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTFriendManagementAsyncProxy.AcceptInviteFriend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FriendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTFriendManagementAsyncProxy*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTFriendManagementAsyncProxy* UFCTFriendManagementAsyncProxy::AcceptInviteFriend(const class FString& FriendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTFriendManagementAsyncProxy", "AcceptInviteFriend");

	Params::FCTFriendManagementAsyncProxy_AcceptInviteFriend Parms{};

	Parms.FriendId = std::move(FriendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTFriendManagementAsyncProxy.CancelInviteFriend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FriendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTFriendManagementAsyncProxy*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTFriendManagementAsyncProxy* UFCTFriendManagementAsyncProxy::CancelInviteFriend(const class FString& FriendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTFriendManagementAsyncProxy", "CancelInviteFriend");

	Params::FCTFriendManagementAsyncProxy_CancelInviteFriend Parms{};

	Parms.FriendId = std::move(FriendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTFriendManagementAsyncProxy.InviteFriend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FriendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTFriendManagementAsyncProxy*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTFriendManagementAsyncProxy* UFCTFriendManagementAsyncProxy::InviteFriend(const class FString& FriendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTFriendManagementAsyncProxy", "InviteFriend");

	Params::FCTFriendManagementAsyncProxy_InviteFriend Parms{};

	Parms.FriendId = std::move(FriendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTFriendManagementAsyncProxy.RejectInviteFriend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FriendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTFriendManagementAsyncProxy*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTFriendManagementAsyncProxy* UFCTFriendManagementAsyncProxy::RejectInviteFriend(const class FString& FriendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTFriendManagementAsyncProxy", "RejectInviteFriend");

	Params::FCTFriendManagementAsyncProxy_RejectInviteFriend Parms{};

	Parms.FriendId = std::move(FriendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTFriendManagementAsyncProxy.RemoveFriend
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           FriendId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTFriendManagementAsyncProxy*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTFriendManagementAsyncProxy* UFCTFriendManagementAsyncProxy::RemoveFriend(const class FString& FriendId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTFriendManagementAsyncProxy", "RemoveFriend");

	Params::FCTFriendManagementAsyncProxy_RemoveFriend Parms{};

	Parms.FriendId = std::move(FriendId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTFriendImportByPlatformCallbackProxy.ImportFriendsByPlatform
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTFriendImportByPlatformCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTFriendImportByPlatformCallbackProxy* UFCTFriendImportByPlatformCallbackProxy::ImportFriendsByPlatform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTFriendImportByPlatformCallbackProxy", "ImportFriendsByPlatform");

	Params::FCTFriendImportByPlatformCallbackProxy_ImportFriendsByPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.UserCardBaseWidget.SetupAvatarImage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTextBlock*                       InitialsTextBlock                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetSwitcher*                  Switcher                                               (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserCardBaseWidget::SetupAvatarImage(const class FString& UserId, class UTextBlock* InitialsTextBlock, class UWidgetSwitcher* Switcher)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserCardBaseWidget", "SetupAvatarImage");

	Params::UserCardBaseWidget_SetupAvatarImage Parms{};

	Parms.UserId = std::move(UserId);
	Parms.InitialsTextBlock = InitialsTextBlock;
	Parms.Switcher = Switcher;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTSessionIDAsyncProxy.GetServerSessionID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTSessionIDAsyncProxy*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTSessionIDAsyncProxy* UFCTSessionIDAsyncProxy::GetServerSessionID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTSessionIDAsyncProxy", "GetServerSessionID");

	Params::FCTSessionIDAsyncProxy_GetServerSessionID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetLiveMessageCallbackProxy.GetLiveMessageFromCloudGameRecord
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UFCTGetLiveMessageCallbackProxy*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetLiveMessageCallbackProxy* UFCTGetLiveMessageCallbackProxy::GetLiveMessageFromCloudGameRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetLiveMessageCallbackProxy", "GetLiveMessageFromCloudGameRecord");

	Params::FCTGetLiveMessageCallbackProxy_GetLiveMessageFromCloudGameRecord Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetAllLeaderboardRankings.GetAllLeaderboardRankings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTGetAllLeaderboardRankings*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetAllLeaderboardRankings* UFCTGetAllLeaderboardRankings::GetAllLeaderboardRankings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetAllLeaderboardRankings", "GetAllLeaderboardRankings");

	Params::FCTGetAllLeaderboardRankings_GetAllLeaderboardRankings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetUserLeaderboardRanking.GetPublicUserLeaderboardRanking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Code                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAccelByteLeaderboardTimeFrame          TimeFrame                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTGetUserLeaderboardRanking*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetUserLeaderboardRanking* UFCTGetUserLeaderboardRanking::GetPublicUserLeaderboardRanking(const class FString& UserId, const class FString& Code, EAccelByteLeaderboardTimeFrame TimeFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetUserLeaderboardRanking", "GetPublicUserLeaderboardRanking");

	Params::FCTGetUserLeaderboardRanking_GetPublicUserLeaderboardRanking Parms{};

	Parms.UserId = std::move(UserId);
	Parms.Code = std::move(Code);
	Parms.TimeFrame = TimeFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetUserLeaderboardRanking.GetUserLeaderboardRanking
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Code                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAccelByteLeaderboardTimeFrame          TimeFrame                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTGetUserLeaderboardRanking*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetUserLeaderboardRanking* UFCTGetUserLeaderboardRanking::GetUserLeaderboardRanking(const class FString& Code, EAccelByteLeaderboardTimeFrame TimeFrame)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetUserLeaderboardRanking", "GetUserLeaderboardRanking");

	Params::FCTGetUserLeaderboardRanking_GetUserLeaderboardRanking Parms{};

	Parms.Code = std::move(Code);
	Parms.TimeFrame = TimeFrame;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPartyConnectionCallbackProxy.AcceptPartyInvitation
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           PartyId                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InvitationToken                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTPartyConnectionCallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTPartyConnectionCallbackProxy* UFCTPartyConnectionCallbackProxy::AcceptPartyInvitation(const class FString& PartyId, const class FString& InvitationToken)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPartyConnectionCallbackProxy", "AcceptPartyInvitation");

	Params::FCTPartyConnectionCallbackProxy_AcceptPartyInvitation Parms{};

	Parms.PartyId = std::move(PartyId);
	Parms.InvitationToken = std::move(InvitationToken);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPartyConnectionCallbackProxy.CreateParty
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UFCTPartyConnectionCallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTPartyConnectionCallbackProxy* UFCTPartyConnectionCallbackProxy::CreateParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPartyConnectionCallbackProxy", "CreateParty");

	Params::FCTPartyConnectionCallbackProxy_CreateParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPartyConnectionCallbackProxy.LeaveParty
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UFCTPartyConnectionCallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTPartyConnectionCallbackProxy* UFCTPartyConnectionCallbackProxy::LeaveParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPartyConnectionCallbackProxy", "LeaveParty");

	Params::FCTPartyConnectionCallbackProxy_LeaveParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPartyManagementCallbackProxy.InviteUserToParty
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           PlayerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTPartyManagementCallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTPartyManagementCallbackProxy* UFCTPartyManagementCallbackProxy::InviteUserToParty(const class FString& PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPartyManagementCallbackProxy", "InviteUserToParty");

	Params::FCTPartyManagementCallbackProxy_InviteUserToParty Parms{};

	Parms.PlayerId = std::move(PlayerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPartyManagementCallbackProxy.KickUserFromParty
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           PlayerId                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTPartyManagementCallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTPartyManagementCallbackProxy* UFCTPartyManagementCallbackProxy::KickUserFromParty(const class FString& PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPartyManagementCallbackProxy", "KickUserFromParty");

	Params::FCTPartyManagementCallbackProxy_KickUserFromParty Parms{};

	Parms.PlayerId = std::move(PlayerId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPartyInfoCallbackProxy.GetPartyInfo
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UFCTPartyInfoCallbackProxy*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTPartyInfoCallbackProxy* UFCTPartyInfoCallbackProxy::GetPartyInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPartyInfoCallbackProxy", "GetPartyInfo");

	Params::FCTPartyInfoCallbackProxy_GetPartyInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTJoinPartyCallbackProxy.JoinPendingConsoleLaunchMultiplayerSession
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTJoinPartyCallbackProxy*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTJoinPartyCallbackProxy* UFCTJoinPartyCallbackProxy::JoinPendingConsoleLaunchMultiplayerSession(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTJoinPartyCallbackProxy", "JoinPendingConsoleLaunchMultiplayerSession");

	Params::FCTJoinPartyCallbackProxy_JoinPendingConsoleLaunchMultiplayerSession Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTJoinPartyCallbackProxy.JoinPendingConsoleSession
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTJoinPartyCallbackProxy*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTJoinPartyCallbackProxy* UFCTJoinPartyCallbackProxy::JoinPendingConsoleSession(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTJoinPartyCallbackProxy", "JoinPendingConsoleSession");

	Params::FCTJoinPartyCallbackProxy_JoinPendingConsoleSession Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteBlockPlayerCallbackProxy.BlockPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteBlockPlayerCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteBlockPlayerCallbackProxy* UFCTAccelByteBlockPlayerCallbackProxy::BlockPlayer(class UObject* WorldContextObject, class APlayerController* PlayerController, const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteBlockPlayerCallbackProxy", "BlockPlayer");

	Params::FCTAccelByteBlockPlayerCallbackProxy_BlockPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerController = PlayerController;
	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteUnblockPlayerCallbackProxy.UnblockPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteUnblockPlayerCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteUnblockPlayerCallbackProxy* UFCTAccelByteUnblockPlayerCallbackProxy::UnblockPlayer(class UObject* WorldContextObject, class APlayerController* PlayerController, const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteUnblockPlayerCallbackProxy", "UnblockPlayer");

	Params::FCTAccelByteUnblockPlayerCallbackProxy_UnblockPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerController = PlayerController;
	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTMatchmakingManagementCallbackProxy.CancelMatchmaking
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UFCTMatchmakingManagementCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTMatchmakingManagementCallbackProxy* UFCTMatchmakingManagementCallbackProxy::CancelMatchmaking()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTMatchmakingManagementCallbackProxy", "CancelMatchmaking");

	Params::FCTMatchmakingManagementCallbackProxy_CancelMatchmaking Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTMatchmakingManagementCallbackProxy.SendReadyConsent
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UFCTMatchmakingManagementCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTMatchmakingManagementCallbackProxy* UFCTMatchmakingManagementCallbackProxy::SendReadyConsent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTMatchmakingManagementCallbackProxy", "SendReadyConsent");

	Params::FCTMatchmakingManagementCallbackProxy_SendReadyConsent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTMatchmakingManagementCallbackProxy.StartMatchmaking
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           InGameMode                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowCrossPlatformPlay                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchLanguage                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTMatchmakingManagementCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTMatchmakingManagementCallbackProxy* UFCTMatchmakingManagementCallbackProxy::StartMatchmaking(const class FString& InGameMode, bool AllowCrossPlatformPlay, const class FString& MatchLanguage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTMatchmakingManagementCallbackProxy", "StartMatchmaking");

	Params::FCTMatchmakingManagementCallbackProxy_StartMatchmaking Parms{};

	Parms.InGameMode = std::move(InGameMode);
	Parms.AllowCrossPlatformPlay = AllowCrossPlatformPlay;
	Parms.MatchLanguage = std::move(MatchLanguage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.MatchmakingLobbyWidget.BindEvents
// (Final, Native, Public, BlueprintCallable)

void UMatchmakingLobbyWidget::BindEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingLobbyWidget", "BindEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.MatchmakingLobbyWidget.OnDSNotif
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsDsNotice         Notification                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchmakingLobbyWidget::OnDSNotif(const struct FAccelByteModelsDsNotice& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingLobbyWidget", "OnDSNotif");

	Params::MatchmakingLobbyWidget_OnDSNotif Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.MatchmakingLobbyWidget.OnMatchmakingNotif
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsMatchmakingNoticeNotification                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchmakingLobbyWidget::OnMatchmakingNotif(const struct FAccelByteModelsMatchmakingNotice& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingLobbyWidget", "OnMatchmakingNotif");

	Params::MatchmakingLobbyWidget_OnMatchmakingNotif Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.MatchmakingLobbyWidget.OnReadyConsentNotif
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsReadyConsentNoticeNotification                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchmakingLobbyWidget::OnReadyConsentNotif(const struct FAccelByteModelsReadyConsentNotice& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingLobbyWidget", "OnReadyConsentNotif");

	Params::MatchmakingLobbyWidget_OnReadyConsentNotif Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.MatchmakingLobbyWidget.OnRematchmakingNotif
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsRematchmakingNoticeNotification                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMatchmakingLobbyWidget::OnRematchmakingNotif(const struct FAccelByteModelsRematchmakingNotice& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakingLobbyWidget", "OnRematchmakingNotif");

	Params::MatchmakingLobbyWidget_OnRematchmakingNotif Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FriendLobbyWidget.AddToPendingPlatformInfoStack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::AddToPendingPlatformInfoStack(const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "AddToPendingPlatformInfoStack");

	Params::FriendLobbyWidget_AddToPendingPlatformInfoStack Parms{};

	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FriendLobbyWidget.DequeuePendingPlatformInfoRequest
// (Final, Native, Public, BlueprintCallable)

void UFriendLobbyWidget::DequeuePendingPlatformInfoRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "DequeuePendingPlatformInfoRequest");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FriendLobbyWidget.OnGetUserPlatformInfoResponseComplete
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlatformName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           PlatformId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::OnGetUserPlatformInfoResponseComplete(const class FString& UserId, const class FString& PlatformName, const class FString& PlatformId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "OnGetUserPlatformInfoResponseComplete");

	Params::FriendLobbyWidget_OnGetUserPlatformInfoResponseComplete Parms{};

	Parms.UserId = std::move(UserId);
	Parms.PlatformName = std::move(PlatformName);
	Parms.PlatformId = std::move(PlatformId);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.FriendLobbyWidget.OnNotifyFriendRemoved
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsUnfriendNotif    Notification                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::OnNotifyFriendRemoved(const struct FAccelByteModelsUnfriendNotif& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "OnNotifyFriendRemoved");

	Params::FriendLobbyWidget_OnNotifyFriendRemoved Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FriendLobbyWidget.OnNotifyFriendRequestAccepted
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsAcceptFriendsNotifNotification                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::OnNotifyFriendRequestAccepted(const struct FAccelByteModelsAcceptFriendsNotif& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "OnNotifyFriendRequestAccepted");

	Params::FriendLobbyWidget_OnNotifyFriendRequestAccepted Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FriendLobbyWidget.OnNotifyFriendRequestCancelled
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsCancelFriendsNotifNotification                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::OnNotifyFriendRequestCancelled(const struct FAccelByteModelsCancelFriendsNotif& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "OnNotifyFriendRequestCancelled");

	Params::FriendLobbyWidget_OnNotifyFriendRequestCancelled Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FriendLobbyWidget.OnNotifyFriendRequestRejected
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsRejectFriendsNotifNotification                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::OnNotifyFriendRequestRejected(const struct FAccelByteModelsRejectFriendsNotif& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "OnNotifyFriendRequestRejected");

	Params::FriendLobbyWidget_OnNotifyFriendRequestRejected Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FriendLobbyWidget.OnNotifyFriendRequestSent
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsRequestFriendsNotifNotification                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::OnNotifyFriendRequestSent(const struct FAccelByteModelsRequestFriendsNotif& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "OnNotifyFriendRequestSent");

	Params::FriendLobbyWidget_OnNotifyFriendRequestSent Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FriendLobbyWidget.OnPrivateMessageRecieved
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsPersonalMessageNoticeNotification                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::OnPrivateMessageRecieved(const struct FAccelByteModelsPersonalMessageNotice& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "OnPrivateMessageRecieved");

	Params::FriendLobbyWidget_OnPrivateMessageRecieved Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FriendLobbyWidget.OnUserPresenceUpdated
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FAccelByteModelsUsersPresenceNoticeNotification                                           (Parm, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::OnUserPresenceUpdated(const struct FAccelByteModelsUsersPresenceNotice& Notification)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "OnUserPresenceUpdated");

	Params::FriendLobbyWidget_OnUserPresenceUpdated Parms{};

	Parms.Notification = std::move(Notification);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FriendLobbyWidget.RefreshFriendList
// (Event, Public, BlueprintEvent)
// Parameters:
// EFFCTFriendListType                     FriendListType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::RefreshFriendList(EFFCTFriendListType FriendListType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "RefreshFriendList");

	Params::FriendLobbyWidget_RefreshFriendList Parms{};

	Parms.FriendListType = FriendListType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.FriendLobbyWidget.SortByAvailability
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFCTFriendsList                  Online                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FFCTFriendsList                  Offline                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::SortByAvailability(struct FFCTFriendsList* Online, struct FFCTFriendsList* Offline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "SortByAvailability");

	Params::FriendLobbyWidget_SortByAvailability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Online != nullptr)
		*Online = std::move(Parms.Online);

	if (Offline != nullptr)
		*Offline = std::move(Parms.Offline);
}


// Function SCT.FriendLobbyWidget.SortByAvailabilityAscendingOrder
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFCTFriendsList                  Online                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FFCTFriendsList                  Offline                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::SortByAvailabilityAscendingOrder(struct FFCTFriendsList* Online, struct FFCTFriendsList* Offline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "SortByAvailabilityAscendingOrder");

	Params::FriendLobbyWidget_SortByAvailabilityAscendingOrder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Online != nullptr)
		*Online = std::move(Parms.Online);

	if (Offline != nullptr)
		*Offline = std::move(Parms.Offline);
}


// Function SCT.FriendLobbyWidget.SortByAvailabilityDescendingOrder
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFCTFriendsList                  Online                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FFCTFriendsList                  Offline                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::SortByAvailabilityDescendingOrder(struct FFCTFriendsList* Online, struct FFCTFriendsList* Offline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "SortByAvailabilityDescendingOrder");

	Params::FriendLobbyWidget_SortByAvailabilityDescendingOrder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Online != nullptr)
		*Online = std::move(Parms.Online);

	if (Offline != nullptr)
		*Offline = std::move(Parms.Offline);
}


// Function SCT.FriendLobbyWidget.SortByOnlineOnly
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFCTFriendsList                  Online                                                 (Parm, OutParm, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::SortByOnlineOnly(struct FFCTFriendsList* Online)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "SortByOnlineOnly");

	Params::FriendLobbyWidget_SortByOnlineOnly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Online != nullptr)
		*Online = std::move(Parms.Online);
}


// Function SCT.FriendLobbyWidget.SortByPlatform
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FFCTFriendsList                  Online                                                 (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FFCTFriendsList                  Offline                                                (Parm, OutParm, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::SortByPlatform(struct FFCTFriendsList* Online, struct FFCTFriendsList* Offline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "SortByPlatform");

	Params::FriendLobbyWidget_SortByPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Online != nullptr)
		*Online = std::move(Parms.Online);

	if (Offline != nullptr)
		*Offline = std::move(Parms.Offline);
}


// Function SCT.FriendLobbyWidget.SortCachedByAvailability
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UFriendCardWidget*>        Online                                                 (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UFriendCardWidget*>        Offline                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::SortCachedByAvailability(TArray<class UFriendCardWidget*>* Online, TArray<class UFriendCardWidget*>* Offline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "SortCachedByAvailability");

	Params::FriendLobbyWidget_SortCachedByAvailability Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Online != nullptr)
		*Online = std::move(Parms.Online);

	if (Offline != nullptr)
		*Offline = std::move(Parms.Offline);
}


// Function SCT.FriendLobbyWidget.SortCachedByAvailabilityAscendingOrder
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UFriendCardWidget*>        Online                                                 (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UFriendCardWidget*>        Offline                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::SortCachedByAvailabilityAscendingOrder(TArray<class UFriendCardWidget*>* Online, TArray<class UFriendCardWidget*>* Offline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "SortCachedByAvailabilityAscendingOrder");

	Params::FriendLobbyWidget_SortCachedByAvailabilityAscendingOrder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Online != nullptr)
		*Online = std::move(Parms.Online);

	if (Offline != nullptr)
		*Offline = std::move(Parms.Offline);
}


// Function SCT.FriendLobbyWidget.SortCachedByAvailabilityDescendingOrder
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UFriendCardWidget*>        Online                                                 (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UFriendCardWidget*>        Offline                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::SortCachedByAvailabilityDescendingOrder(TArray<class UFriendCardWidget*>* Online, TArray<class UFriendCardWidget*>* Offline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "SortCachedByAvailabilityDescendingOrder");

	Params::FriendLobbyWidget_SortCachedByAvailabilityDescendingOrder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Online != nullptr)
		*Online = std::move(Parms.Online);

	if (Offline != nullptr)
		*Offline = std::move(Parms.Offline);
}


// Function SCT.FriendLobbyWidget.SortCachedByOnlineOnly
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UFriendCardWidget*>        Online                                                 (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::SortCachedByOnlineOnly(TArray<class UFriendCardWidget*>* Online)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "SortCachedByOnlineOnly");

	Params::FriendLobbyWidget_SortCachedByOnlineOnly Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Online != nullptr)
		*Online = std::move(Parms.Online);
}


// Function SCT.FriendLobbyWidget.SortCachedByPlatform
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UFriendCardWidget*>        Online                                                 (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<class UFriendCardWidget*>        Offline                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UFriendLobbyWidget::SortCachedByPlatform(TArray<class UFriendCardWidget*>* Online, TArray<class UFriendCardWidget*>* Offline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FriendLobbyWidget", "SortCachedByPlatform");

	Params::FriendLobbyWidget_SortCachedByPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Online != nullptr)
		*Online = std::move(Parms.Online);

	if (Offline != nullptr)
		*Offline = std::move(Parms.Offline);
}


// Function SCT.WidgetOrganizer.Add
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetSCT*                       WidgetInstance                                         (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   behaviourOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetOrganizer::Add(class UWidgetSCT* WidgetInstance, int32 behaviourOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetOrganizer", "Add");

	Params::WidgetOrganizer_Add Parms{};

	Parms.WidgetInstance = WidgetInstance;
	Parms.behaviourOverride = behaviourOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.WidgetOrganizer.CreateWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UWidgetSCT>           WidgetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   behaviourOverride                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidgetSCT*                       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetSCT* UWidgetOrganizer::CreateWidget(TSubclassOf<class UWidgetSCT> WidgetType, int32 behaviourOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetOrganizer", "CreateWidget");

	Params::WidgetOrganizer_CreateWidget Parms{};

	Parms.WidgetType = WidgetType;
	Parms.behaviourOverride = behaviourOverride;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.WidgetOrganizer.OnWidgetRemovedExternally
// (Final, Native, Private)
// Parameters:
// class UWidgetSCT*                       Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetOrganizer::OnWidgetRemovedExternally(class UWidgetSCT* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetOrganizer", "OnWidgetRemovedExternally");

	Params::WidgetOrganizer_OnWidgetRemovedExternally Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.WidgetOrganizer.Remove
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UWidgetSCT*                       Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    RemoveFromParent                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWidgetOrganizer::Remove(class UWidgetSCT* Widget, bool RemoveFromParent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetOrganizer", "Remove");

	Params::WidgetOrganizer_Remove Parms{};

	Parms.Widget = Widget;
	Parms.RemoveFromParent = RemoveFromParent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.WidgetOrganizer.Contains
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidgetSCT*                       Widget                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWidgetOrganizer::Contains(class UWidgetSCT* Widget) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WidgetOrganizer", "Contains");

	Params::WidgetOrganizer_Contains Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ConsoleSessionManagement.ShowConsoleInviteUI
// (Final, Native, Static, Public)

void UConsoleSessionManagement::ShowConsoleInviteUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ConsoleSessionManagement", "ShowConsoleInviteUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ConsoleSessionManagement.OnCreateSessionComplete
// (Final, Native, Private)
// Parameters:
// class FName                             SessionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bWasSuccessful                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UConsoleSessionManagement::OnCreateSessionComplete(class FName SessionName, bool bWasSuccessful)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleSessionManagement", "OnCreateSessionComplete");

	Params::ConsoleSessionManagement_OnCreateSessionComplete Parms{};

	Parms.SessionName = SessionName;
	Parms.bWasSuccessful = bWasSuccessful;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ConsoleSessionManagement.OnReconnectedToLobby
// (Final, Native, Private)

void UConsoleSessionManagement::OnReconnectedToLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ConsoleSessionManagement", "OnReconnectedToLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccelByteLoginWidget.SetConnectionBinds
// (Final, Native, Private, BlueprintCallable)

void UFCTAccelByteLoginWidget::SetConnectionBinds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCTAccelByteLoginWidget", "SetConnectionBinds");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTGetUserPlatformInfoCallbackProxy.GetUserPlatformInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTGetUserPlatformInfoCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetUserPlatformInfoCallbackProxy* UFCTGetUserPlatformInfoCallbackProxy::GetUserPlatformInfo(const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetUserPlatformInfoCallbackProxy", "GetUserPlatformInfo");

	Params::FCTGetUserPlatformInfoCallbackProxy_GetUserPlatformInfo Parms{};

	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.GenerateRandomAccelByteProfileCode
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFCTPlatformBlueprintFunctionLibrary::GenerateRandomAccelByteProfileCode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "GenerateRandomAccelByteProfileCode");

	Params::FCTPlatformBlueprintFunctionLibrary_GenerateRandomAccelByteProfileCode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.GetAccelBytePlatformSync
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAccelBytePlatformSync                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAccelBytePlatformSync UFCTPlatformBlueprintFunctionLibrary::GetAccelBytePlatformSync()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "GetAccelBytePlatformSync");

	Params::FCTPlatformBlueprintFunctionLibrary_GetAccelBytePlatformSync Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.GetPlatformType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// EAccelBytePlatformType                  OutputExec                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTPlatformBlueprintFunctionLibrary::GetPlatformType(EAccelBytePlatformType* OutputExec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "GetPlatformType");

	Params::FCTPlatformBlueprintFunctionLibrary_GetPlatformType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutputExec != nullptr)
		*OutputExec = Parms.OutputExec;
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.GetPlatformUserDisplayName
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFCTPlatformBlueprintFunctionLibrary::GetPlatformUserDisplayName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "GetPlatformUserDisplayName");

	Params::FCTPlatformBlueprintFunctionLibrary_GetPlatformUserDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.GetPlatformUserID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFCTPlatformBlueprintFunctionLibrary::GetPlatformUserID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "GetPlatformUserID");

	Params::FCTPlatformBlueprintFunctionLibrary_GetPlatformUserID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.GetProfileAvatar
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* UFCTPlatformBlueprintFunctionLibrary::GetProfileAvatar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "GetProfileAvatar");

	Params::FCTPlatformBlueprintFunctionLibrary_GetProfileAvatar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.GetSplitDisplayNameAndFriendCode
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FString                           InFullDisplayName                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutDisplayName                                         (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutFriendCode                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTPlatformBlueprintFunctionLibrary::GetSplitDisplayNameAndFriendCode(const class FString& InFullDisplayName, class FString* OutDisplayName, class FString* OutFriendCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "GetSplitDisplayNameAndFriendCode");

	Params::FCTPlatformBlueprintFunctionLibrary_GetSplitDisplayNameAndFriendCode Parms{};

	Parms.InFullDisplayName = std::move(InFullDisplayName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDisplayName != nullptr)
		*OutDisplayName = std::move(Parms.OutDisplayName);

	if (OutFriendCode != nullptr)
		*OutFriendCode = std::move(Parms.OutFriendCode);
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.IsPlatformDLCInstalled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ID                                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFCTPlatformBlueprintFunctionLibrary::IsPlatformDLCInstalled(int32 ID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "IsPlatformDLCInstalled");

	Params::FCTPlatformBlueprintFunctionLibrary_IsPlatformDLCInstalled Parms{};

	Parms.ID = ID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.OpenStorePage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAccelByteGIS*                    AccelByteGIS                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Category                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ProductId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AddToCart                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTPlatformBlueprintFunctionLibrary::OpenStorePage(class UAccelByteGIS* AccelByteGIS, const class FString& Category, const class FString& ProductId, bool AddToCart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "OpenStorePage");

	Params::FCTPlatformBlueprintFunctionLibrary_OpenStorePage Parms{};

	Parms.AccelByteGIS = AccelByteGIS;
	Parms.Category = std::move(Category);
	Parms.ProductId = std::move(ProductId);
	Parms.AddToCart = AddToCart;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.OpenVersusEvilLogin
// (Final, Native, Static, Public, BlueprintCallable)

void UFCTPlatformBlueprintFunctionLibrary::OpenVersusEvilLogin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "OpenVersusEvilLogin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.RegistrationPasswordIsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Password                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ErrorCode                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFCTPlatformBlueprintFunctionLibrary::RegistrationPasswordIsValid(const class FString& Password, int32* ErrorCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "RegistrationPasswordIsValid");

	Params::FCTPlatformBlueprintFunctionLibrary_RegistrationPasswordIsValid Parms{};

	Parms.Password = std::move(Password);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ErrorCode != nullptr)
		*ErrorCode = Parms.ErrorCode;

	return Parms.ReturnValue;
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.RegistrationWasViewed
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFCTPlatformBlueprintFunctionLibrary::RegistrationWasViewed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "RegistrationWasViewed");

	Params::FCTPlatformBlueprintFunctionLibrary_RegistrationWasViewed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.SetDisplayNameWithoutFriendCodeToTextBlock
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTextBlock*                       InText                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutDisplayName                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTPlatformBlueprintFunctionLibrary::SetDisplayNameWithoutFriendCodeToTextBlock(class UTextBlock* InText, class FString& OutDisplayName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "SetDisplayNameWithoutFriendCodeToTextBlock");

	Params::FCTPlatformBlueprintFunctionLibrary_SetDisplayNameWithoutFriendCodeToTextBlock Parms{};

	Parms.InText = InText;
	Parms.OutDisplayName = std::move(OutDisplayName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutDisplayName = std::move(Parms.OutDisplayName);
}


// Function SCT.FCTPlatformBlueprintFunctionLibrary.SetUserDisplayNameWithFalloffToTextBlock
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UTextBlock*                       InText                                                 (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OutDisplayName                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TotalWidth                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTPlatformBlueprintFunctionLibrary::SetUserDisplayNameWithFalloffToTextBlock(class UTextBlock* InText, class FString& OutDisplayName, int32 TotalWidth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTPlatformBlueprintFunctionLibrary", "SetUserDisplayNameWithFalloffToTextBlock");

	Params::FCTPlatformBlueprintFunctionLibrary_SetUserDisplayNameWithFalloffToTextBlock Parms{};

	Parms.InText = InText;
	Parms.OutDisplayName = std::move(OutDisplayName);
	Parms.TotalWidth = TotalWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutDisplayName = std::move(Parms.OutDisplayName);
}


// Function SCT.FCTAchievementPopUp.Init
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UFCTAchievement*                  Achievement                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTAchievementPopUp::Init(class UFCTAchievement* Achievement)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCTAchievementPopUp", "Init");

	Params::FCTAchievementPopUp_Init Parms{};

	Parms.Achievement = Achievement;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTStatIncrementCallbackProxy.UpdateStatistic
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           StatCode                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   IncrementalValue                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTStatIncrementCallbackProxy*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTStatIncrementCallbackProxy* UFCTStatIncrementCallbackProxy::UpdateStatistic(const class FString& StatCode, float IncrementalValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTStatIncrementCallbackProxy", "UpdateStatistic");

	Params::FCTStatIncrementCallbackProxy_UpdateStatistic Parms{};

	Parms.StatCode = std::move(StatCode);
	Parms.IncrementalValue = IncrementalValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetStatsCallbackProxy.GetStatistic
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           StatCode                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTGetStatsCallbackProxy*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetStatsCallbackProxy* UFCTGetStatsCallbackProxy::GetStatistic(const class FString& StatCode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetStatsCallbackProxy", "GetStatistic");

	Params::FCTGetStatsCallbackProxy_GetStatistic Parms{};

	Parms.StatCode = std::move(StatCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTIncrementUnlinkedStatsCallbackProxy.IncrementUnlinkedStatistic
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           StatCode                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTIncrementUnlinkedStatsCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTIncrementUnlinkedStatsCallbackProxy* UFCTIncrementUnlinkedStatsCallbackProxy::IncrementUnlinkedStatistic(const class FString& StatCode, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTIncrementUnlinkedStatsCallbackProxy", "IncrementUnlinkedStatistic");

	Params::FCTIncrementUnlinkedStatsCallbackProxy_IncrementUnlinkedStatistic Parms{};

	Parms.StatCode = std::move(StatCode);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAchievementListCallbackProxy.GetRecentlyUnlockedUserAchievements
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Count                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAchievementListCallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAchievementListCallbackProxy* UFCTAchievementListCallbackProxy::GetRecentlyUnlockedUserAchievements(int32 Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAchievementListCallbackProxy", "GetRecentlyUnlockedUserAchievements");

	Params::FCTAchievementListCallbackProxy_GetRecentlyUnlockedUserAchievements Parms{};

	Parms.Count = Count;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAchievementListCallbackProxy.GetUserAchievements
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAccelByteGIS*                    AccelByteGIS                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAchievementListCallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAchievementListCallbackProxy* UFCTAchievementListCallbackProxy::GetUserAchievements(class UAccelByteGIS* AccelByteGIS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAchievementListCallbackProxy", "GetUserAchievements");

	Params::FCTAchievementListCallbackProxy_GetUserAchievements Parms{};

	Parms.AccelByteGIS = AccelByteGIS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.BulkUserDataCallbackProxy.GetBulkUsersData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   UserIds                                                (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UBulkUserDataCallbackProxy*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBulkUserDataCallbackProxy* UBulkUserDataCallbackProxy::GetBulkUsersData(const TArray<class FString>& UserIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BulkUserDataCallbackProxy", "GetBulkUsersData");

	Params::BulkUserDataCallbackProxy_GetBulkUsersData Parms{};

	Parms.UserIds = std::move(UserIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAchievementUnlockCallbackProxy.UnlockAchievement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Code                                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAchievementUnlockCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAchievementUnlockCallbackProxy* UFCTAchievementUnlockCallbackProxy::UnlockAchievement(const class FString& Code)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAchievementUnlockCallbackProxy", "UnlockAchievement");

	Params::FCTAchievementUnlockCallbackProxy_UnlockAchievement Parms{};

	Parms.Code = std::move(Code);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetTrophyRecordCallbackProxy.GetTrophyCustomizationRecord
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTGetTrophyRecordCallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTGetTrophyRecordCallbackProxy* UFCTGetTrophyRecordCallbackProxy::GetTrophyCustomizationRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGetTrophyRecordCallbackProxy", "GetTrophyCustomizationRecord");

	Params::FCTGetTrophyRecordCallbackProxy_GetTrophyCustomizationRecord Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGetTrophyRecordCallbackProxy.GetUserSelectedTrophies
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FCloudTrophyInfo                 TrophyRecord                                           (Parm, OutParm, NativeAccessSpecifierPublic)

void UFCTGetTrophyRecordCallbackProxy::GetUserSelectedTrophies(struct FCloudTrophyInfo* TrophyRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCTGetTrophyRecordCallbackProxy", "GetUserSelectedTrophies");

	Params::FCTGetTrophyRecordCallbackProxy_GetUserSelectedTrophies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TrophyRecord != nullptr)
		*TrophyRecord = std::move(Parms.TrophyRecord);
}


// Function SCT.FCTSetTrophyRecordCallbackProxy.SetTrophyCustomizationRecord
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<struct FCloudTrophy>             SelectedTrophies                                       (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UFCTSetTrophyRecordCallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTSetTrophyRecordCallbackProxy* UFCTSetTrophyRecordCallbackProxy::SetTrophyCustomizationRecord(const TArray<struct FCloudTrophy>& SelectedTrophies)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTSetTrophyRecordCallbackProxy", "SetTrophyCustomizationRecord");

	Params::FCTSetTrophyRecordCallbackProxy_SetTrophyCustomizationRecord Parms{};

	Parms.SelectedTrophies = std::move(SelectedTrophies);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTGameRecordStatisticsBlueprintLibrary.ClientIncrementGlobalStatistic
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGlobalClientStatistics                 Statistic                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTGameRecordStatisticsBlueprintLibrary::ClientIncrementGlobalStatistic(EGlobalClientStatistics Statistic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGameRecordStatisticsBlueprintLibrary", "ClientIncrementGlobalStatistic");

	Params::FCTGameRecordStatisticsBlueprintLibrary_ClientIncrementGlobalStatistic Parms{};

	Parms.Statistic = Statistic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTGameRecordStatisticsBlueprintLibrary.ServerIncrementGlobalStatistic
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EGlobalServerStatistics                 Statistic                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFCTGameRecordStatisticsBlueprintLibrary::ServerIncrementGlobalStatistic(EGlobalServerStatistics Statistic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTGameRecordStatisticsBlueprintLibrary", "ServerIncrementGlobalStatistic");

	Params::FCTGameRecordStatisticsBlueprintLibrary_ServerIncrementGlobalStatistic Parms{};

	Parms.Statistic = Statistic;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy.CheckAnonymousCommunicationPrivilege
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInIsFriend                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInForceUpdate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy* UBlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy::CheckAnonymousCommunicationPrivilege(class UObject* WorldContextObject, class APlayerController* InPlayerController, bool bInIsFriend, bool bInForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy", "CheckAnonymousCommunicationPrivilege");

	Params::BlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy_CheckAnonymousCommunicationPrivilege Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPlayerController = InPlayerController;
	Parms.bInIsFriend = bInIsFriend;
	Parms.bInForceUpdate = bInForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteGetUserUtils.GetUserInfo
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteGetUserUtils*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteGetUserUtils* UFCTAccelByteGetUserUtils::GetUserInfo(const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteGetUserUtils", "GetUserInfo");

	Params::FCTAccelByteGetUserUtils_GetUserInfo Parms{};

	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteKarmaStat.AddToCurrentKarma
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteKarmaStat*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteKarmaStat* UFCTAccelByteKarmaStat::AddToCurrentKarma(int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteKarmaStat", "AddToCurrentKarma");

	Params::FCTAccelByteKarmaStat_AddToCurrentKarma Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteKarmaStat.GetCurrentKarma
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTAccelByteKarmaStat*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteKarmaStat* UFCTAccelByteKarmaStat::GetCurrentKarma()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteKarmaStat", "GetCurrentKarma");

	Params::FCTAccelByteKarmaStat_GetCurrentKarma Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccountMigrationCallbackProxy.GetCurrentAccountInformation
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTAccountMigrationCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccountMigrationCallbackProxy* UFCTAccountMigrationCallbackProxy::GetCurrentAccountInformation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccountMigrationCallbackProxy", "GetCurrentAccountInformation");

	Params::FCTAccountMigrationCallbackProxy_GetCurrentAccountInformation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccountMigrationCallbackProxy.MigrateToNewAccount
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FFCTUserAccountMergerPayload     MergePayload_0                                         (Parm, NativeAccessSpecifierPublic)
// class UFCTAccountMigrationCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccountMigrationCallbackProxy* UFCTAccountMigrationCallbackProxy::MigrateToNewAccount(const struct FFCTUserAccountMergerPayload& MergePayload_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccountMigrationCallbackProxy", "MigrateToNewAccount");

	Params::FCTAccountMigrationCallbackProxy_MigrateToNewAccount Parms{};

	Parms.MergePayload_0 = std::move(MergePayload_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccountMigrationCallbackProxy.MergeAchievementsToNewAccount
// (Final, Native, Private)

void UFCTAccountMigrationCallbackProxy::MergeAchievementsToNewAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCTAccountMigrationCallbackProxy", "MergeAchievementsToNewAccount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccountMigrationCallbackProxy.MergeBulkFriendsToNewAccount
// (Final, Native, Private)

void UFCTAccountMigrationCallbackProxy::MergeBulkFriendsToNewAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCTAccountMigrationCallbackProxy", "MergeBulkFriendsToNewAccount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccountMigrationCallbackProxy.MergeEntitlementsToNewAccount
// (Final, Native, Private)

void UFCTAccountMigrationCallbackProxy::MergeEntitlementsToNewAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCTAccountMigrationCallbackProxy", "MergeEntitlementsToNewAccount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccountMigrationCallbackProxy.MergeStatsToNewAccount
// (Final, Native, Private)

void UFCTAccountMigrationCallbackProxy::MergeStatsToNewAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCTAccountMigrationCallbackProxy", "MergeStatsToNewAccount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccountMigrationCallbackProxy.QueryAchievementsFromCurrentAccount
// (Final, Native, Private)

void UFCTAccountMigrationCallbackProxy::QueryAchievementsFromCurrentAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCTAccountMigrationCallbackProxy", "QueryAchievementsFromCurrentAccount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccountMigrationCallbackProxy.QueryBulkFriendsFromCurrentAccount
// (Final, Native, Private)

void UFCTAccountMigrationCallbackProxy::QueryBulkFriendsFromCurrentAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCTAccountMigrationCallbackProxy", "QueryBulkFriendsFromCurrentAccount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccountMigrationCallbackProxy.QueryEntitlementsFromCurrentAccount
// (Final, Native, Private)

void UFCTAccountMigrationCallbackProxy::QueryEntitlementsFromCurrentAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCTAccountMigrationCallbackProxy", "QueryEntitlementsFromCurrentAccount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FCTAccountMigrationCallbackProxy.QueryStatsFromCurrentAccount
// (Final, Native, Private)

void UFCTAccountMigrationCallbackProxy::QueryStatsFromCurrentAccount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FCTAccountMigrationCallbackProxy", "QueryStatsFromCurrentAccount");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SetCloudIntDataCallbackProxy.SetCloudRecordValue
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// EUserRecordType                         UserRecord                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AddValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USetCloudIntDataCallbackProxy*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USetCloudIntDataCallbackProxy* USetCloudIntDataCallbackProxy::SetCloudRecordValue(EUserRecordType UserRecord, const class FString& FieldName, const int32 AddValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SetCloudIntDataCallbackProxy", "SetCloudRecordValue");

	Params::SetCloudIntDataCallbackProxy_SetCloudRecordValue Parms{};

	Parms.UserRecord = UserRecord;
	Parms.FieldName = std::move(FieldName);
	Parms.AddValue = AddValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteSearchUserUtils.SearchUsers
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class FString                           Query                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteSearchUserUtils*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteSearchUserUtils* UFCTAccelByteSearchUserUtils::SearchUsers(const class FString& Query)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteSearchUserUtils", "SearchUsers");

	Params::FCTAccelByteSearchUserUtils_SearchUsers Parms{};

	Parms.Query = std::move(Query);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteCloudPublicProfileCallbackProxy.GetCloudPublicProfile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTAccelByteCloudPublicProfileCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteCloudPublicProfileCallbackProxy* UFCTAccelByteCloudPublicProfileCallbackProxy::GetCloudPublicProfile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteCloudPublicProfileCallbackProxy", "GetCloudPublicProfile");

	Params::FCTAccelByteCloudPublicProfileCallbackProxy_GetCloudPublicProfile Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteCloudPublicProfileCallbackProxy.GetUserCloudPublicProfile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteCloudPublicProfileCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteCloudPublicProfileCallbackProxy* UFCTAccelByteCloudPublicProfileCallbackProxy::GetUserCloudPublicProfile(const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteCloudPublicProfileCallbackProxy", "GetUserCloudPublicProfile");

	Params::FCTAccelByteCloudPublicProfileCallbackProxy_GetUserCloudPublicProfile Parms{};

	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteCloudPublicProfileCallbackProxy.SetCloudPublicProfile
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AddedExperience                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteCloudPublicProfileCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteCloudPublicProfileCallbackProxy* UFCTAccelByteCloudPublicProfileCallbackProxy::SetCloudPublicProfile(int32 AddedExperience)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteCloudPublicProfileCallbackProxy", "SetCloudPublicProfile");

	Params::FCTAccelByteCloudPublicProfileCallbackProxy_SetCloudPublicProfile Parms{};

	Parms.AddedExperience = AddedExperience;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ServiceMessageHandler.GetServiceMessagesFromGameRecord
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UServiceMessageHandler*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UServiceMessageHandler* UServiceMessageHandler::GetServiceMessagesFromGameRecord()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ServiceMessageHandler", "GetServiceMessagesFromGameRecord");

	Params::ServiceMessageHandler_GetServiceMessagesFromGameRecord Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteCustomizationPayloadCallbackProxy.GetUserCustomizationPayload
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTAccelByteCustomizationPayloadCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteCustomizationPayloadCallbackProxy* UFCTAccelByteCustomizationPayloadCallbackProxy::GetUserCustomizationPayload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteCustomizationPayloadCallbackProxy", "GetUserCustomizationPayload");

	Params::FCTAccelByteCustomizationPayloadCallbackProxy_GetUserCustomizationPayload Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteCustomizationPayloadCallbackProxy.SetUserCustomizationPayload
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FFCTCloudCustomizationGender     Male                                                   (Parm, NativeAccessSpecifierPublic)
// struct FFCTCloudCustomizationGender     Female                                                 (Parm, NativeAccessSpecifierPublic)
// struct FFCTCloudCustomizationVruumba    Vruumba                                                (Parm, NativeAccessSpecifierPublic)
// bool                                    MaleSelected                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteCustomizationPayloadCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteCustomizationPayloadCallbackProxy* UFCTAccelByteCustomizationPayloadCallbackProxy::SetUserCustomizationPayload(const struct FFCTCloudCustomizationGender& Male, const struct FFCTCloudCustomizationGender& Female, const struct FFCTCloudCustomizationVruumba& Vruumba, bool MaleSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteCustomizationPayloadCallbackProxy", "SetUserCustomizationPayload");

	Params::FCTAccelByteCustomizationPayloadCallbackProxy_SetUserCustomizationPayload Parms{};

	Parms.Male = std::move(Male);
	Parms.Female = std::move(Female);
	Parms.Vruumba = std::move(Vruumba);
	Parms.MaleSelected = MaleSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteCustomizationSettingsCallbackProxy.GetCustomizationSettingsByUserId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteCustomizationSettingsCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteCustomizationSettingsCallbackProxy* UFCTAccelByteCustomizationSettingsCallbackProxy::GetCustomizationSettingsByUserId(const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteCustomizationSettingsCallbackProxy", "GetCustomizationSettingsByUserId");

	Params::FCTAccelByteCustomizationSettingsCallbackProxy_GetCustomizationSettingsByUserId Parms{};

	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteVruumbaCustomizationSettingsCallbackProxy.GetVruumbaCustomizationSettingsByUserId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy* UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy::GetVruumbaCustomizationSettingsByUserId(const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteVruumbaCustomizationSettingsCallbackProxy", "GetVruumbaCustomizationSettingsByUserId");

	Params::FCTAccelByteVruumbaCustomizationSettingsCallbackProxy_GetVruumbaCustomizationSettingsByUserId Parms{};

	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteVirtualPurchasesCallbackProxy.GetInGamePurchasingPayload
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTAccelByteVirtualPurchasesCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteVirtualPurchasesCallbackProxy* UFCTAccelByteVirtualPurchasesCallbackProxy::GetInGamePurchasingPayload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteVirtualPurchasesCallbackProxy", "GetInGamePurchasingPayload");

	Params::FCTAccelByteVirtualPurchasesCallbackProxy_GetInGamePurchasingPayload Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteVirtualPurchasesCallbackProxy.PurchaseItemWithFirstClassTokens
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Cost                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteVirtualPurchasesCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteVirtualPurchasesCallbackProxy* UFCTAccelByteVirtualPurchasesCallbackProxy::PurchaseItemWithFirstClassTokens(const class FString& Name_0, int32 Cost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteVirtualPurchasesCallbackProxy", "PurchaseItemWithFirstClassTokens");

	Params::FCTAccelByteVirtualPurchasesCallbackProxy_PurchaseItemWithFirstClassTokens Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.Cost = Cost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteVirtualPurchasesCallbackProxy.UpdateFirstClassTokenWallet
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AddedCurrency                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAccelByteVirtualPurchasesCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAccelByteVirtualPurchasesCallbackProxy* UFCTAccelByteVirtualPurchasesCallbackProxy::UpdateFirstClassTokenWallet(int32 AddedCurrency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteVirtualPurchasesCallbackProxy", "UpdateFirstClassTokenWallet");

	Params::FCTAccelByteVirtualPurchasesCallbackProxy_UpdateFirstClassTokenWallet Parms{};

	Parms.AddedCurrency = AddedCurrency;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTCloudEmotesCallbackProxy.GetEmotesFromCloud
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UFCTCloudEmotesCallbackProxy*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTCloudEmotesCallbackProxy* UFCTCloudEmotesCallbackProxy::GetEmotesFromCloud()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTCloudEmotesCallbackProxy", "GetEmotesFromCloud");

	Params::FCTCloudEmotesCallbackProxy_GetEmotesFromCloud Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTCloudEmotesCallbackProxy.SetEmotesToCloud
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   Names                                                  (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UFCTCloudEmotesCallbackProxy*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTCloudEmotesCallbackProxy* UFCTCloudEmotesCallbackProxy::SetEmotesToCloud(const TArray<class FString>& Names)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTCloudEmotesCallbackProxy", "SetEmotesToCloud");

	Params::FCTCloudEmotesCallbackProxy_SetEmotesToCloud Parms{};

	Parms.Names = std::move(Names);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteUtilities.ConvertToAlphaNumeric
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Input                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UFCTAccelByteUtilities::ConvertToAlphaNumeric(const class FString& Input)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteUtilities", "ConvertToAlphaNumeric");

	Params::FCTAccelByteUtilities_ConvertToAlphaNumeric Parms{};

	Parms.Input = std::move(Input);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteUtilities.DoesItemHaveUniqueSku
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAccelByteModelsEntitlementInfo  ABEntitlementInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           FCTSku                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFCTAccelByteUtilities::DoesItemHaveUniqueSku(const struct FAccelByteModelsEntitlementInfo& ABEntitlementInfo, const class FString& FCTSku)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteUtilities", "DoesItemHaveUniqueSku");

	Params::FCTAccelByteUtilities_DoesItemHaveUniqueSku Parms{};

	Parms.ABEntitlementInfo = std::move(ABEntitlementInfo);
	Parms.FCTSku = std::move(FCTSku);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteUtilities.IsEntitlementFoundInLocalData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAccelByteModelsEntitlementInfo  ABEntitlementInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           FCTSku                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFCTAccelByteUtilities::IsEntitlementFoundInLocalData(const struct FAccelByteModelsEntitlementInfo& ABEntitlementInfo, const class FString& FCTSku)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteUtilities", "IsEntitlementFoundInLocalData");

	Params::FCTAccelByteUtilities_IsEntitlementFoundInLocalData Parms{};

	Parms.ABEntitlementInfo = std::move(ABEntitlementInfo);
	Parms.FCTSku = std::move(FCTSku);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAccelByteUtilities.IsItemEqual
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAccelByteModelsEntitlementInfo  ABEntitlementInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           FCTSku                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFCTAccelByteUtilities::IsItemEqual(const struct FAccelByteModelsEntitlementInfo& ABEntitlementInfo, const class FString& FCTSku)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAccelByteUtilities", "IsItemEqual");

	Params::FCTAccelByteUtilities_IsItemEqual Parms{};

	Parms.ABEntitlementInfo = std::move(ABEntitlementInfo);
	Parms.FCTSku = std::move(FCTSku);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTSettings.GetCustomGameMinimumPlayerCount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UFCTSettings::GetCustomGameMinimumPlayerCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTSettings", "GetCustomGameMinimumPlayerCount");

	Params::FCTSettings_GetCustomGameMinimumPlayerCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTSettings.GetDefaultCustomGameSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FCustomGameSettings              ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FCustomGameSettings UFCTSettings::GetDefaultCustomGameSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTSettings", "GetDefaultCustomGameSettings");

	Params::FCTSettings_GetDefaultCustomGameSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTSettings.GetIsGamepadRebindingEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFCTSettings::GetIsGamepadRebindingEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTSettings", "GetIsGamepadRebindingEnabled");

	Params::FCTSettings_GetIsGamepadRebindingEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTSettings.GetUserSettingsObjects
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<TSubclassOf<class USettingsObject>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class USettingsObject>> UFCTSettings::GetUserSettingsObjects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTSettings", "GetUserSettingsObjects");

	Params::FCTSettings_GetUserSettingsObjects Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTUserReportUtilitiesLibrary.GetMostRelevantUserBanData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    OutHasActiveBan                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FFCTUserBan>              Bans                                                   (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TMap<class FString, class FString>      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<class FString, class FString> UFCTUserReportUtilitiesLibrary::GetMostRelevantUserBanData(bool* OutHasActiveBan, const TArray<struct FFCTUserBan>& Bans)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTUserReportUtilitiesLibrary", "GetMostRelevantUserBanData");

	Params::FCTUserReportUtilitiesLibrary_GetMostRelevantUserBanData Parms{};

	Parms.Bans = std::move(Bans);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHasActiveBan != nullptr)
		*OutHasActiveBan = Parms.OutHasActiveBan;

	return Parms.ReturnValue;
}


// Function SCT.SubMenuSelectionButtonUserWidget.OnPressed
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void USubMenuSelectionButtonUserWidget::OnPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubMenuSelectionButtonUserWidget", "OnPressed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SendUserReportCallbackProxy.ReportUser
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DisplayName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Reportedby_userid                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Reason                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Description                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           SessionID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USendUserReportCallbackProxy*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USendUserReportCallbackProxy* USendUserReportCallbackProxy::ReportUser(const class FString& UserId, const class FString& DisplayName, const class FString& Reportedby_userid, const class FString& Reason, const class FString& Description, const class FString& SessionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SendUserReportCallbackProxy", "ReportUser");

	Params::SendUserReportCallbackProxy_ReportUser Parms{};

	Parms.UserId = std::move(UserId);
	Parms.DisplayName = std::move(DisplayName);
	Parms.Reportedby_userid = std::move(Reportedby_userid);
	Parms.Reason = std::move(Reason);
	Parms.Description = std::move(Description);
	Parms.SessionID = std::move(SessionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.GetUserBansCallbackProxy.GetUserBans
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGetUserBansCallbackProxy*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGetUserBansCallbackProxy* UGetUserBansCallbackProxy::GetUserBans()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GetUserBansCallbackProxy", "GetUserBans");

	Params::GetUserBansCallbackProxy_GetUserBans Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.GetUserBanByIdCallbackProxy.GetUserBanByBanId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           BanId                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGetUserBanByIdCallbackProxy*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGetUserBanByIdCallbackProxy* UGetUserBanByIdCallbackProxy::GetUserBanByBanId(const class FString& BanId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GetUserBanByIdCallbackProxy", "GetUserBanByBanId");

	Params::GetUserBanByIdCallbackProxy_GetUserBanByBanId Parms{};

	Parms.BanId = std::move(BanId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FireExtinguisher.SetCurrentAmmo
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewAmmo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFireExtinguisher::SetCurrentAmmo(float NewAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireExtinguisher", "SetCurrentAmmo");

	Params::FireExtinguisher_SetCurrentAmmo Parms{};

	Parms.NewAmmo = NewAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.FireExtinguisher.GetCurrentAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFireExtinguisher::GetCurrentAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireExtinguisher", "GetCurrentAmmo");

	Params::FireExtinguisher_GetCurrentAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FireExtinguisher.GetMaximumAmmo
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UFireExtinguisher::GetMaximumAmmo() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FireExtinguisher", "GetMaximumAmmo");

	Params::FireExtinguisher_GetMaximumAmmo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.NextLevelExpCallbackProxy.RequestNextLevelExpRequired
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UNextLevelExpCallbackProxy*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNextLevelExpCallbackProxy* UNextLevelExpCallbackProxy::RequestNextLevelExpRequired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NextLevelExpCallbackProxy", "RequestNextLevelExpRequired");

	Params::NextLevelExpCallbackProxy_RequestNextLevelExpRequired Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.GamesightGIS.GameLaunch
// (Final, Native, Private)

void UGamesightGIS::GameLaunch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GamesightGIS", "GameLaunch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.GlobalEventBool.Broadcast
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlobalEventBool::Broadcast(bool Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEventBool", "Broadcast");

	Params::GlobalEventBool_Broadcast Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.GlobalEventFloat.Broadcast
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlobalEventFloat::Broadcast(float Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEventFloat", "Broadcast");

	Params::GlobalEventFloat_Broadcast Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.GlobalEventLinearColor.Broadcast
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FLinearColor                     Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGlobalEventLinearColor::Broadcast(const struct FLinearColor& Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GlobalEventLinearColor", "Broadcast");

	Params::GlobalEventLinearColor_Broadcast Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.HealthAttributeSet.OnRep_Health
// (Native, Protected)

void UHealthAttributeSet::OnRep_Health()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthAttributeSet", "OnRep_Health");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.HealthAttributeSet.OnRep_MaxHealth
// (Native, Protected)

void UHealthAttributeSet::OnRep_MaxHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthAttributeSet", "OnRep_MaxHealth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.HumanoidCharacter.ClosePuzzleMenu
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void AHumanoidCharacter::ClosePuzzleMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidCharacter", "ClosePuzzleMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.HumanoidCharacter.K2_InitializePersonoid
// (Native, Event, Public, BlueprintEvent)

void AHumanoidCharacter::K2_InitializePersonoid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidCharacter", "K2_InitializePersonoid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.HumanoidCharacter.K2_InitializeResident
// (Native, Event, Public, BlueprintEvent)

void AHumanoidCharacter::K2_InitializeResident()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidCharacter", "K2_InitializeResident");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.HumanoidCharacter.K2_OnDestiny
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FDestiny                         Destiny                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AHumanoidCharacter::K2_OnDestiny(const struct FDestiny& Destiny)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidCharacter", "K2_OnDestiny");

	Params::HumanoidCharacter_K2_OnDestiny Parms{};

	Parms.Destiny = std::move(Destiny);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.HumanoidCharacter.K2_OnWetnessChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   Wetness                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanoidCharacter::K2_OnWetnessChanged(float Wetness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidCharacter", "K2_OnWetnessChanged");

	Params::HumanoidCharacter_K2_OnWetnessChanged Parms{};

	Parms.Wetness = Wetness;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.HumanoidCharacter.Kill
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FDestiny                         Destiny                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void AHumanoidCharacter::Kill(const struct FDestiny& Destiny)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidCharacter", "Kill");

	Params::HumanoidCharacter_Kill Parms{};

	Parms.Destiny = std::move(Destiny);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.HumanoidCharacter.OnWetnessChanged
// (Final, Native, Protected)
// Parameters:
// float                                   Wetness                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AHumanoidCharacter::OnWetnessChanged(float Wetness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidCharacter", "OnWetnessChanged");

	Params::HumanoidCharacter_OnWetnessChanged Parms{};

	Parms.Wetness = Wetness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.HumanoidCharacter.OpenPuzzleMenu
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)

void AHumanoidCharacter::OpenPuzzleMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidCharacter", "OpenPuzzleMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.HumanoidCharacter.ToggleCrouch
// (Final, Native, Private)

void AHumanoidCharacter::ToggleCrouch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidCharacter", "ToggleCrouch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.HumanoidCharacter.ToggleThumbVoteMenu
// (Final, Native, Private)

void AHumanoidCharacter::ToggleThumbVoteMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HumanoidCharacter", "ToggleThumbVoteMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.IdentificationColorGlobalEvent.Broadcast
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIdentificationColorGlobalEvent::Broadcast(class APlayerState* PlayerState, const struct FLinearColor& Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IdentificationColorGlobalEvent", "Broadcast");

	Params::IdentificationColorGlobalEvent_Broadcast Parms{};

	Parms.PlayerState = PlayerState;
	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.IdentificationColorGlobalVariable.SetColor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIdentificationColorGlobalVariable::SetColor(class APlayerState* PlayerState, const struct FLinearColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IdentificationColorGlobalVariable", "SetColor");

	Params::IdentificationColorGlobalVariable_SetColor Parms{};

	Parms.PlayerState = PlayerState;
	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.IdentificationColorGlobalVariable.GetColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UIdentificationColorGlobalVariable::GetColor(class APlayerState* PlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IdentificationColorGlobalVariable", "GetColor");

	Params::IdentificationColorGlobalVariable_GetColor Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.IdentificationColorGlobalVariable.GetColorFromID
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UIdentificationColorGlobalVariable::GetColorFromID(int32 PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IdentificationColorGlobalVariable", "GetColorFromID");

	Params::IdentificationColorGlobalVariable_GetColorFromID Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTCheckConsoleBansCallbackProxy.CheckConsoleBans
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTCheckConsoleBansCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTCheckConsoleBansCallbackProxy* UFCTCheckConsoleBansCallbackProxy::CheckConsoleBans(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTCheckConsoleBansCallbackProxy", "CheckConsoleBans");

	Params::FCTCheckConsoleBansCallbackProxy_CheckConsoleBans Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InputSettingsActionSubComponent.SetGamepadAction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SettingsName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputChord                      Chord                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettingsActionSubComponent::SetGamepadAction(const class FName& SettingsName, const struct FInputChord& Chord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsActionSubComponent", "SetGamepadAction");

	Params::InputSettingsActionSubComponent_SetGamepadAction Parms{};

	Parms.SettingsName = SettingsName;
	Parms.Chord = std::move(Chord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InputSettingsActionSubComponent.SetKeyboardAction
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SettingsName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputChord                      Chord                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettingsActionSubComponent::SetKeyboardAction(const class FName& SettingsName, const struct FInputChord& Chord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsActionSubComponent", "SetKeyboardAction");

	Params::InputSettingsActionSubComponent_SetKeyboardAction Parms{};

	Parms.SettingsName = SettingsName;
	Parms.Chord = std::move(Chord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InputSettingsActionSubComponent.GetGamepadAction
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SettingsName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputActionKeyMapping           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInputActionKeyMapping UInputSettingsActionSubComponent::GetGamepadAction(const class FName& SettingsName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsActionSubComponent", "GetGamepadAction");

	Params::InputSettingsActionSubComponent_GetGamepadAction Parms{};

	Parms.SettingsName = SettingsName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InputSettingsActionSubComponent.GetKeyboardAction
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SettingsName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputActionKeyMapping           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInputActionKeyMapping UInputSettingsActionSubComponent::GetKeyboardAction(const class FName& SettingsName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsActionSubComponent", "GetKeyboardAction");

	Params::InputSettingsActionSubComponent_GetKeyboardAction Parms{};

	Parms.SettingsName = SettingsName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InputSettingsActionSubComponent.GetRebindableActions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FInputInformation>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FInputInformation> UInputSettingsActionSubComponent::GetRebindableActions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsActionSubComponent", "GetRebindableActions");

	Params::InputSettingsActionSubComponent_GetRebindableActions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InputSettingsActionSubComponent.IsKeyBound
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputChord                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputSettingsActionSubComponent::IsKeyBound(const class FName& Name_0, const struct FInputChord& Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsActionSubComponent", "IsKeyBound");

	Params::InputSettingsActionSubComponent_IsKeyBound Parms{};

	Parms.Name_0 = Name_0;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SetCloudStringDataCallbackProxy.SetCloudRecordValue
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// EUserRecordType                         UserRecord                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewValue                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USetCloudStringDataCallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USetCloudStringDataCallbackProxy* USetCloudStringDataCallbackProxy::SetCloudRecordValue(EUserRecordType UserRecord, const class FString& FieldName, const class FString& NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SetCloudStringDataCallbackProxy", "SetCloudRecordValue");

	Params::SetCloudStringDataCallbackProxy_SetCloudRecordValue Parms{};

	Parms.UserRecord = UserRecord;
	Parms.FieldName = std::move(FieldName);
	Parms.NewValue = std::move(NewValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InputSettingsAxesSubComponent.GetInformation
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SettingsName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputInformationAxis            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInputInformationAxis UInputSettingsAxesSubComponent::GetInformation(const class FName& SettingsName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsAxesSubComponent", "GetInformation");

	Params::InputSettingsAxesSubComponent_GetInformation Parms{};

	Parms.SettingsName = SettingsName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InputSettingsAxesSubComponent.GetRebindableAxesKeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UInputSettingsAxesSubComponent::GetRebindableAxesKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsAxesSubComponent", "GetRebindableAxesKeys");

	Params::InputSettingsAxesSubComponent_GetRebindableAxesKeys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InputSettingsAxesSubComponent.SetKeyboardAxis
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SettingsName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputChord                      Chord                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettingsAxesSubComponent::SetKeyboardAxis(const class FName& SettingsName, const struct FInputChord& Chord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsAxesSubComponent", "SetKeyboardAxis");

	Params::InputSettingsAxesSubComponent_SetKeyboardAxis Parms{};

	Parms.SettingsName = SettingsName;
	Parms.Chord = std::move(Chord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InputSettingsAxesSubComponent.GetKeyboardAxis
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SettingsName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputAxisKeyMapping             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInputAxisKeyMapping UInputSettingsAxesSubComponent::GetKeyboardAxis(const class FName& SettingsName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsAxesSubComponent", "GetKeyboardAxis");

	Params::InputSettingsAxesSubComponent_GetKeyboardAxis Parms{};

	Parms.SettingsName = SettingsName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InputSettingsAxesSubComponent.IsKeyBound
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputChord                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputSettingsAxesSubComponent::IsKeyBound(const class FName& Name_0, const struct FInputChord& Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsAxesSubComponent", "IsKeyBound");

	Params::InputSettingsAxesSubComponent_IsKeyBound Parms{};

	Parms.Name_0 = Name_0;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InputSettingsToggleSubComponent.GetRebindableToggleKeys
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> UInputSettingsToggleSubComponent::GetRebindableToggleKeys()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsToggleSubComponent", "GetRebindableToggleKeys");

	Params::InputSettingsToggleSubComponent_GetRebindableToggleKeys Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InputSettingsToggleSubComponent.SetToggle
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             SettingsName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInputSettingsToggleSubComponent::SetToggle(const class FName& SettingsName, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsToggleSubComponent", "SetToggle");

	Params::InputSettingsToggleSubComponent_SetToggle Parms{};

	Parms.SettingsName = SettingsName;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InputSettingsToggleSubComponent.GetInformation
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SettingsName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputInformationToggle          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FInputInformationToggle UInputSettingsToggleSubComponent::GetInformation(const class FName& SettingsName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsToggleSubComponent", "GetInformation");

	Params::InputSettingsToggleSubComponent_GetInformation Parms{};

	Parms.SettingsName = SettingsName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InputSettingsToggleSubComponent.GetToggle
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             SettingsName                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInputSettingsToggleSubComponent::GetToggle(const class FName& SettingsName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InputSettingsToggleSubComponent", "GetToggle");

	Params::InputSettingsToggleSubComponent_GetToggle Parms{};

	Parms.SettingsName = SettingsName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SkillcheckController.ClientCancelSkillcheck
// (Net, NetReliable, Native, Event, Public, NetClient)

void USkillcheckController::ClientCancelSkillcheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillcheckController", "ClientCancelSkillcheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SkillcheckController.ClientCreateSkillcheck
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// TSubclassOf<class USkillcheckWidget>    WidgetType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillcheckController::ClientCreateSkillcheck(TSubclassOf<class USkillcheckWidget> WidgetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillcheckController", "ClientCreateSkillcheck");

	Params::SkillcheckController_ClientCreateSkillcheck Parms{};

	Parms.WidgetType = WidgetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SkillcheckController.ClientCreateWaitForOthersWidget
// (Net, NetReliable, Native, Event, Public, NetClient)

void USkillcheckController::ClientCreateWaitForOthersWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillcheckController", "ClientCreateWaitForOthersWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SkillcheckController.OnSkillcheckEnded
// (Final, Native, Private)

void USkillcheckController::OnSkillcheckEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillcheckController", "OnSkillcheckEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SkillcheckController.ServerRegister
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ASkillcheckManager*               Manager                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillcheckController::ServerRegister(class ASkillcheckManager* Manager)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillcheckController", "ServerRegister");

	Params::SkillcheckController_ServerRegister Parms{};

	Parms.Manager = Manager;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SkillcheckController.ServerUnregister
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class ASkillcheckManager*               Manager                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USkillcheckController::ServerUnregister(class ASkillcheckManager* Manager)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SkillcheckController", "ServerUnregister");

	Params::SkillcheckController_ServerUnregister Parms{};

	Parms.Manager = Manager;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionComponentCosmeticBase.GetInteractionComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInteractionComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInteractionComponent* UInteractionComponentCosmeticBase::GetInteractionComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionComponentCosmeticBase", "GetInteractionComponent");

	Params::InteractionComponentCosmeticBase_GetInteractionComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionCoopDispatcher.AddReceiver
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UInteractionCoopReceiver*         Receiver_0                                             (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionCoopDispatcher::AddReceiver(class UInteractionCoopReceiver* Receiver_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCoopDispatcher", "AddReceiver");

	Params::InteractionCoopDispatcher_AddReceiver Parms{};

	Parms.Receiver_0 = Receiver_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionCoopReceiver.K2_DispatcherRegistered
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UInteractionCoopDispatcher*       Dispatcher                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionCoopReceiver::K2_DispatcherRegistered(const class UInteractionCoopDispatcher* Dispatcher)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCoopReceiver", "K2_DispatcherRegistered");

	Params::InteractionCoopReceiver_K2_DispatcherRegistered Parms{};

	Parms.Dispatcher = Dispatcher;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.InteractionCoopReceiver.K2_DispatcherUnregistered
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UInteractionCoopDispatcher*       Dispatcher                                             (ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionCoopReceiver::K2_DispatcherUnregistered(const class UInteractionCoopDispatcher* Dispatcher)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCoopReceiver", "K2_DispatcherUnregistered");

	Params::InteractionCoopReceiver_K2_DispatcherUnregistered Parms{};

	Parms.Dispatcher = Dispatcher;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.InteractionCoopReceiver.K2_OnRep_State
// (Event, Protected, BlueprintEvent)

void UInteractionCoopReceiver::K2_OnRep_State()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCoopReceiver", "K2_OnRep_State");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.InteractionCoopReceiver.OnRep_State
// (Final, Native, Protected)

void UInteractionCoopReceiver::OnRep_State()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCoopReceiver", "OnRep_State");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionCoopReceiver.TrySetState
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// EInteractionCoopReceiverState           NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionCoopReceiver::TrySetState(EInteractionCoopReceiverState NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCoopReceiver", "TrySetState");

	Params::InteractionCoopReceiver_TrySetState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.InteractionCoopReceiver.K2_CanChangeState
// (Event, Protected, BlueprintEvent, Const)
// Parameters:
// EInteractionCoopReceiverState           RequestedNewState                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInteractionCoopReceiver::K2_CanChangeState(EInteractionCoopReceiverState RequestedNewState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionCoopReceiver", "K2_CanChangeState");

	Params::InteractionCoopReceiver_K2_CanChangeState Parms{};

	Parms.RequestedNewState = RequestedNewState;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SCT.InteractionSkillcheckExtension.SetManager
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ASkillcheckManager*               Manager_0                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInteractionSkillcheckExtension::SetManager(class ASkillcheckManager* Manager_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionSkillcheckExtension", "SetManager");

	Params::InteractionSkillcheckExtension_SetManager Parms{};

	Parms.Manager_0 = Manager_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionSubComponentInterface.Ended
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    WasCancelled                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractionSubComponentInterface::Ended(const struct FInteractionPayload& Payload, bool WasCancelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionSubComponentInterface", "Ended");

	Params::InteractionSubComponentInterface_Ended Parms{};

	Parms.Payload = std::move(Payload);
	Parms.WasCancelled = WasCancelled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionSubComponentInterface.SetInteractionOwner
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UInteractionComponent*            Component                                              (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IInteractionSubComponentInterface::SetInteractionOwner(class UInteractionComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionSubComponentInterface", "SetInteractionOwner");

	Params::InteractionSubComponentInterface_SetInteractionOwner Parms{};

	Parms.Component = Component;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionSubComponentInterface.Started
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void IInteractionSubComponentInterface::Started(const struct FInteractionPayload& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionSubComponentInterface", "Started");

	Params::InteractionSubComponentInterface_Started Parms{};

	Parms.Payload = std::move(Payload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.InteractionSubComponentInterface.Succeeded
// (Native, Event, Public, BlueprintEvent)

void IInteractionSubComponentInterface::Succeeded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractionSubComponentInterface", "Succeeded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Inventory.AssignToSlot
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UPower*                           Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventorySlotID                        SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::AssignToSlot(class UPower* Power, EInventorySlotID SlotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "AssignToSlot");

	Params::Inventory_AssignToSlot Parms{};

	Parms.Power = Power;
	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Inventory.CallOnInventoryChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayAbilitySpec             Spec                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UInventory::CallOnInventoryChanged(const struct FGameplayAbilitySpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "CallOnInventoryChanged");

	Params::Inventory_CallOnInventoryChanged Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Inventory.CallOnSlotAssigned
// (Final, Native, Private)
// Parameters:
// class UPower*                           PowerChanged                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventorySlotID                        SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::CallOnSlotAssigned(class UPower* PowerChanged, EInventorySlotID SlotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "CallOnSlotAssigned");

	Params::Inventory_CallOnSlotAssigned Parms{};

	Parms.PowerChanged = PowerChanged;
	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Inventory.CallOnSlotCleared
// (Final, Native, Private)
// Parameters:
// class UPower*                           PowerChanged                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventorySlotID                        SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::CallOnSlotCleared(class UPower* PowerChanged, EInventorySlotID SlotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "CallOnSlotCleared");

	Params::Inventory_CallOnSlotCleared Parms{};

	Parms.PowerChanged = PowerChanged;
	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Inventory.ClearSlot
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// EInventorySlotID                        SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::ClearSlot(EInventorySlotID SlotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "ClearSlot");

	Params::Inventory_ClearSlot Parms{};

	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Inventory.ClientOnInventoryChanged
// (Final, Net, Native, Event, Private, NetClient)

void UInventory::ClientOnInventoryChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "ClientOnInventoryChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Inventory.ClientOnSlotAssigned
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class UPower*                           PowerChanged                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventorySlotID                        SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::ClientOnSlotAssigned(class UPower* PowerChanged, EInventorySlotID SlotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "ClientOnSlotAssigned");

	Params::Inventory_ClientOnSlotAssigned Parms{};

	Parms.PowerChanged = PowerChanged;
	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Inventory.ClientOnSlotCleared
// (Final, Net, NetReliable, Native, Event, Private, NetClient)
// Parameters:
// class UPower*                           PowerChanged                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EInventorySlotID                        SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::ClientOnSlotCleared(class UPower* PowerChanged, EInventorySlotID SlotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "ClientOnSlotCleared");

	Params::Inventory_ClientOnSlotCleared Parms{};

	Parms.PowerChanged = PowerChanged;
	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Inventory.DropAllPowers
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UInventory::DropAllPowers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "DropAllPowers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Inventory.DropPowerType
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UPower>               PowerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::DropPowerType(TSubclassOf<class UPower> PowerType, const struct FVector& WorldPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "DropPowerType");

	Params::Inventory_DropPowerType Parms{};

	Parms.PowerType = PowerType;
	Parms.WorldPosition = std::move(WorldPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.DropSwapableIfPossible
// (Final, Native, Private, HasDefaults)
// Parameters:
// TSubclassOf<class UPower>               PowerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PickupPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    TrueIfNone                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::DropSwapableIfPossible(TSubclassOf<class UPower> PowerType, const struct FVector& PickupPosition, bool TrueIfNone)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "DropSwapableIfPossible");

	Params::Inventory_DropSwapableIfPossible Parms{};

	Parms.PowerType = PowerType;
	Parms.PickupPosition = std::move(PickupPosition);
	Parms.TrueIfNone = TrueIfNone;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.GetCachedItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EInventorySlotID                        SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UPower>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UPower> UInventory::GetCachedItem(EInventorySlotID SlotId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetCachedItem");

	Params::Inventory_GetCachedItem Parms{};

	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.OnAbilityGranted
// (Final, Native, Private)
// Parameters:
// class UPower*                           Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UInventory::OnAbilityGranted(class UPower* Power)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "OnAbilityGranted");

	Params::Inventory_OnAbilityGranted Parms{};

	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Inventory.OnAbilityRemoved
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGameplayAbilitySpec             AbilitySpec                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UInventory::OnAbilityRemoved(struct FGameplayAbilitySpec* AbilitySpec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "OnAbilityRemoved");

	Params::Inventory_OnAbilityRemoved Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AbilitySpec != nullptr)
		*AbilitySpec = std::move(Parms.AbilitySpec);
}


// Function SCT.Inventory.OnRep_CachedItemSlots
// (Final, Native, Private)

void UInventory::OnRep_CachedItemSlots()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "OnRep_CachedItemSlots");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Inventory.RemovePower
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UPower*                           Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::RemovePower(class UPower* Power)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "RemovePower");

	Params::Inventory_RemovePower Parms{};

	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.RemovePowerAll
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UPower*                           Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::RemovePowerAll(class UPower* Power)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "RemovePowerAll");

	Params::Inventory_RemovePowerAll Parms{};

	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.RemovePowerStacks
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UPower*                           Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StacksToRemove                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::RemovePowerStacks(class UPower* Power, int32 StacksToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "RemovePowerStacks");

	Params::Inventory_RemovePowerStacks Parms{};

	Parms.Power = Power;
	Parms.StacksToRemove = StacksToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.RemovePowerType
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UPower>               PowerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::RemovePowerType(TSubclassOf<class UPower> PowerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "RemovePowerType");

	Params::Inventory_RemovePowerType Parms{};

	Parms.PowerType = PowerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.RemovePowerTypeAll
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UPower>               PowerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::RemovePowerTypeAll(TSubclassOf<class UPower> PowerType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "RemovePowerTypeAll");

	Params::Inventory_RemovePowerTypeAll Parms{};

	Parms.PowerType = PowerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.RemovePowerTypeStacks
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UPower>               PowerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StacksToRemove                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::RemovePowerTypeStacks(TSubclassOf<class UPower> PowerType, int32 StacksToRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "RemovePowerTypeStacks");

	Params::Inventory_RemovePowerTypeStacks Parms{};

	Parms.PowerType = PowerType;
	Parms.StacksToRemove = StacksToRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.TryAddPower
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UPower>               PowerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StacksToAdd                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPowerRuntimeData                RuntimeData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   InputID                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::TryAddPower(TSubclassOf<class UPower> PowerType, int32 StacksToAdd, const struct FPowerRuntimeData& RuntimeData, int32 InputID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "TryAddPower");

	Params::Inventory_TryAddPower Parms{};

	Parms.PowerType = PowerType;
	Parms.StacksToAdd = StacksToAdd;
	Parms.RuntimeData = std::move(RuntimeData);
	Parms.InputID = InputID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.TrySwapPower
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// TSubclassOf<class UPower>               PowerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StacksToAdd                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          PickupPosition                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPowerRuntimeData                RuntimeData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::TrySwapPower(TSubclassOf<class UPower> PowerType, int32 StacksToAdd, const struct FVector& PickupPosition, const struct FPowerRuntimeData& RuntimeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "TrySwapPower");

	Params::Inventory_TrySwapPower Parms{};

	Parms.PowerType = PowerType;
	Parms.StacksToAdd = StacksToAdd;
	Parms.PickupPosition = std::move(PickupPosition);
	Parms.RuntimeData = std::move(RuntimeData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.CanAddPower
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UPower>               PowerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Stacks                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::CanAddPower(TSubclassOf<class UPower> PowerType, int32 Stacks) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "CanAddPower");

	Params::Inventory_CanAddPower Parms{};

	Parms.PowerType = PowerType;
	Parms.Stacks = Stacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.CanPickupUniqueItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UPower>               Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::CanPickupUniqueItem(TSubclassOf<class UPower> Power) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "CanPickupUniqueItem");

	Params::Inventory_CanPickupUniqueItem Parms{};

	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.ContainsPower
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPower*                           Power                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::ContainsPower(const class UPower* Power) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "ContainsPower");

	Params::Inventory_ContainsPower Parms{};

	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.ContainsPowerType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UPower>               PowerType                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::ContainsPowerType(TSubclassOf<class UPower> PowerType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "ContainsPowerType");

	Params::Inventory_ContainsPowerType Parms{};

	Parms.PowerType = PowerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.GetAllItems
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FItemDetails>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FItemDetails> UInventory::GetAllItems() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetAllItems");

	Params::Inventory_GetAllItems Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.GetAllPowers
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FPowerDetails>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FPowerDetails> UInventory::GetAllPowers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetAllPowers");

	Params::Inventory_GetAllPowers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.GetAllSkills
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FSkillDetails>            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSkillDetails> UInventory::GetAllSkills() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetAllSkills");

	Params::Inventory_GetAllSkills Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.GetCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UInventory::GetCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "GetCount");

	Params::Inventory_GetCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.HasCachedItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInventorySlotID                        SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::HasCachedItem(EInventorySlotID SlotId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "HasCachedItem");

	Params::Inventory_HasCachedItem Parms{};

	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.HasUniqueItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::HasUniqueItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "HasUniqueItem");

	Params::Inventory_HasUniqueItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.IsUniqueItem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UPower>               Power                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UInventory::IsUniqueItem(TSubclassOf<class UPower> Power) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "IsUniqueItem");

	Params::Inventory_IsUniqueItem Parms{};

	Parms.Power = Power;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.TryGetPowerFromType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UPower>               PowerType                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPower*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPower* UInventory::TryGetPowerFromType(const TSubclassOf<class UPower> PowerType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "TryGetPowerFromType");

	Params::Inventory_TryGetPowerFromType Parms{};

	Parms.PowerType = PowerType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Inventory.TryGetPowerInSlot
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EInventorySlotID                        SlotId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPower*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPower* UInventory::TryGetPowerInSlot(EInventorySlotID SlotId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Inventory", "TryGetPowerInSlot");

	Params::Inventory_TryGetPowerInSlot Parms{};

	Parms.SlotId = SlotId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SymbolPuzzleComponent.AssignSeed
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USymbolPuzzleComponent::AssignSeed(int32 Seed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SymbolPuzzleComponent", "AssignSeed");

	Params::SymbolPuzzleComponent_AssignSeed Parms{};

	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SymbolPuzzleComponent.OnWidgetSymbolSelected
// (Final, Native, Private)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USymbolPuzzleComponent::OnWidgetSymbolSelected(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SymbolPuzzleComponent", "OnWidgetSymbolSelected");

	Params::SymbolPuzzleComponent_OnWidgetSymbolSelected Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SymbolPuzzleComponent.ServerSelectedSymbol
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USymbolPuzzleComponent::ServerSelectedSymbol(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SymbolPuzzleComponent", "ServerSelectedSymbol");

	Params::SymbolPuzzleComponent_ServerSelectedSymbol Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SymbolPuzzleComponent.ServerUserQuit
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void USymbolPuzzleComponent::ServerUserQuit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SymbolPuzzleComponent", "ServerUserQuit");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SymbolPuzzleComponent.ToggleUI
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Toggle                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USymbolPuzzleComponent::ToggleUI(bool Toggle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SymbolPuzzleComponent", "ToggleUI");

	Params::SymbolPuzzleComponent_ToggleUI Parms{};

	Parms.Toggle = Toggle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SymbolPuzzleComponent.GetPuzzleWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USymbolPuzzleWidget*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USymbolPuzzleWidget* USymbolPuzzleComponent::GetPuzzleWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SymbolPuzzleComponent", "GetPuzzleWidget");

	Params::SymbolPuzzleComponent_GetPuzzleWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.LevelChangeHandlerInterface.K2_PostLevelChange
// (Event, Public, BlueprintEvent)

void ILevelChangeHandlerInterface::K2_PostLevelChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelChangeHandlerInterface", "K2_PostLevelChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.LevelChangeHandlerInterface.K2_PreLevelChange
// (Event, Public, BlueprintEvent)

void ILevelChangeHandlerInterface::K2_PreLevelChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelChangeHandlerInterface", "K2_PreLevelChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.LevelChangeHandlerInterface.PostLevelChange
// (Native, Public)

void ILevelChangeHandlerInterface::PostLevelChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelChangeHandlerInterface", "PostLevelChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.LevelChangeHandlerInterface.PreLevelChange
// (Native, Public)

void ILevelChangeHandlerInterface::PreLevelChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelChangeHandlerInterface", "PreLevelChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.LevelVoteComponent.OnRep_SelectedLevel
// (Final, Native, Private)

void ULevelVoteComponent::OnRep_SelectedLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "OnRep_SelectedLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.LevelVoteComponent.OnRep_TotalVoted
// (Final, Native, Private)

void ULevelVoteComponent::OnRep_TotalVoted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "OnRep_TotalVoted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.LevelVoteComponent.OnRep_VoteOptions
// (Final, Native, Private)

void ULevelVoteComponent::OnRep_VoteOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "OnRep_VoteOptions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.LevelVoteComponent.OnRep_VoteTimeoutTime
// (Final, Native, Private)

void ULevelVoteComponent::OnRep_VoteTimeoutTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "OnRep_VoteTimeoutTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.LevelVoteComponent.OnVoteTimeout
// (Final, Native, Private)

void ULevelVoteComponent::OnVoteTimeout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "OnVoteTimeout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.LevelVoteComponent.StartVotingProcess
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ULevelVoteComponent::StartVotingProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "StartVotingProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.LevelVoteComponent.VoteOnLevel
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   LevelIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelVoteComponent::VoteOnLevel(int32 LevelIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "VoteOnLevel");

	Params::LevelVoteComponent_VoteOnLevel Parms{};

	Parms.LevelIndex = LevelIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.ClientCreateGameSessionReservation
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GameSessionID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchEndData                    MatchEndData                                           (Parm, NativeAccessSpecifierPublic)

void UXboxGameSessionControllerGIS::ClientCreateGameSessionReservation(class APlayerController* PlayerController, const class FString& GameSessionID, const struct FMatchEndData& MatchEndData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ClientCreateGameSessionReservation");

	Params::XboxGameSessionControllerGIS_ClientCreateGameSessionReservation Parms{};

	Parms.PlayerController = PlayerController;
	Parms.GameSessionID = std::move(GameSessionID);
	Parms.MatchEndData = std::move(MatchEndData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.ClientCreateNewGameSession
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UXboxGameSessionControllerGIS::ClientCreateNewGameSession(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ClientCreateNewGameSession");

	Params::XboxGameSessionControllerGIS_ClientCreateNewGameSession Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.ClientFinishGameSession
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GameSessionID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UXboxGameSessionControllerGIS::ClientFinishGameSession(class APlayerController* PlayerController, const class FString& GameSessionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ClientFinishGameSession");

	Params::XboxGameSessionControllerGIS_ClientFinishGameSession Parms{};

	Parms.PlayerController = PlayerController;
	Parms.GameSessionID = std::move(GameSessionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.ClientHasGameSession
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UXboxGameSessionControllerGIS::ClientHasGameSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ClientHasGameSession");

	Params::XboxGameSessionControllerGIS_ClientHasGameSession Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.XboxGameSessionControllerGIS.ClientJoinGameSession
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           GameSessionID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UXboxGameSessionControllerGIS::ClientJoinGameSession(class APlayerController* PlayerController, const class FString& GameSessionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ClientJoinGameSession");

	Params::XboxGameSessionControllerGIS_ClientJoinGameSession Parms{};

	Parms.PlayerController = PlayerController;
	Parms.GameSessionID = std::move(GameSessionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.ClientLeaveGameSession
// (Final, Native, Public)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UXboxGameSessionControllerGIS::ClientLeaveGameSession(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ClientLeaveGameSession");

	Params::XboxGameSessionControllerGIS_ClientLeaveGameSession Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.ClientReceiveServerClientStateData
// (Final, Native, Public)
// Parameters:
// struct FXboxGameSessionControllerClientStateDataXboxGameSessionControllerClientStateData               (Parm, NativeAccessSpecifierPublic)

void UXboxGameSessionControllerGIS::ClientReceiveServerClientStateData(const struct FXboxGameSessionControllerClientStateData& XboxGameSessionControllerClientStateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ClientReceiveServerClientStateData");

	Params::XboxGameSessionControllerGIS_ClientReceiveServerClientStateData Parms{};

	Parms.XboxGameSessionControllerClientStateData = std::move(XboxGameSessionControllerClientStateData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.ClientResetGameSession
// (Final, Native, Public, BlueprintCallable)

void UXboxGameSessionControllerGIS::ClientResetGameSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ClientResetGameSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.DoGameSessionFinishes
// (Final, Native, Private)

void UXboxGameSessionControllerGIS::DoGameSessionFinishes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "DoGameSessionFinishes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.DoJoinClients
// (Final, Native, Private)

void UXboxGameSessionControllerGIS::DoJoinClients()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "DoJoinClients");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.DoJoins
// (Final, Native, Private)

void UXboxGameSessionControllerGIS::DoJoins()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "DoJoins");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.DoRequestNewGameSession
// (Final, Native, Private)

void UXboxGameSessionControllerGIS::DoRequestNewGameSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "DoRequestNewGameSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.DoReservations
// (Final, Native, Private)

void UXboxGameSessionControllerGIS::DoReservations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "DoReservations");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.DoReserveClients
// (Final, Native, Private)

void UXboxGameSessionControllerGIS::DoReserveClients()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "DoReserveClients");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.DoUpdateGameStateClientStates
// (Final, Native, Private)

void UXboxGameSessionControllerGIS::DoUpdateGameStateClientStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "DoUpdateGameStateClientStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.RunClientCommand
// (Final, Native, Public)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EXboxGameSessionClientCommand           ClientCommand                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FXboxGameSessionCommandData      CommandData                                            (Parm, NativeAccessSpecifierPublic)

void UXboxGameSessionControllerGIS::RunClientCommand(class APlayerController* PlayerController, EXboxGameSessionClientCommand ClientCommand, const struct FXboxGameSessionCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "RunClientCommand");

	Params::XboxGameSessionControllerGIS_RunClientCommand Parms{};

	Parms.PlayerController = PlayerController;
	Parms.ClientCommand = ClientCommand;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.ServerBeginGameSession
// (Final, Native, Public)

void UXboxGameSessionControllerGIS::ServerBeginGameSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ServerBeginGameSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.ServerClientJoinGameSession
// (Final, Native, Public)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UXboxGameSessionControllerGIS::ServerClientJoinGameSession(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ServerClientJoinGameSession");

	Params::XboxGameSessionControllerGIS_ServerClientJoinGameSession Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.ServerEndGameSession
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FMatchEndData                    MatchEndData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UXboxGameSessionControllerGIS::ServerEndGameSession(const struct FMatchEndData& MatchEndData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ServerEndGameSession");

	Params::XboxGameSessionControllerGIS_ServerEndGameSession Parms{};

	Parms.MatchEndData = std::move(MatchEndData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.ServerProcessCommandResult
// (Final, Native, Public)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EXboxGameSessionServerCommandResult     CommandResult                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FXboxGameSessionCommandData      CommandData                                            (Parm, NativeAccessSpecifierPublic)

void UXboxGameSessionControllerGIS::ServerProcessCommandResult(class APlayerController* PlayerController, EXboxGameSessionServerCommandResult CommandResult, const struct FXboxGameSessionCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ServerProcessCommandResult");

	Params::XboxGameSessionControllerGIS_ServerProcessCommandResult Parms{};

	Parms.PlayerController = PlayerController;
	Parms.CommandResult = CommandResult;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.ServerRemoveClient
// (Final, Native, Public)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UXboxGameSessionControllerGIS::ServerRemoveClient(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ServerRemoveClient");

	Params::XboxGameSessionControllerGIS_ServerRemoveClient Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxGameSessionControllerGIS.ServerStartNewGameSession
// (Final, Native, Public)

void UXboxGameSessionControllerGIS::ServerStartNewGameSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxGameSessionControllerGIS", "ServerStartNewGameSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.MatchmakerLanguageData.GetKeyAt
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UMatchmakerLanguageData::GetKeyAt(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakerLanguageData", "GetKeyAt");

	Params::MatchmakerLanguageData_GetKeyAt Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.MatchmakerLanguageData.GetKeyIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           Key                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UMatchmakerLanguageData::GetKeyIndex(const class FString& Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakerLanguageData", "GetKeyIndex");

	Params::MatchmakerLanguageData_GetKeyIndex Parms{};

	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.MatchmakerLanguageData.PopuplateComboBoxString
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UComboBoxString*                  InComboBoxString                                       (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchmakerLanguageData::PopuplateComboBoxString(class UComboBoxString* InComboBoxString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchmakerLanguageData", "PopuplateComboBoxString");

	Params::MatchmakerLanguageData_PopuplateComboBoxString Parms{};

	Parms.InComboBoxString = InComboBoxString;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.MatchStartedInterface.OnMatchHasStarted
// (Native, Event, Public, BlueprintEvent)

void IMatchStartedInterface::OnMatchHasStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchStartedInterface", "OnMatchHasStarted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.MaterialCustomizationRowWidget.GenerateOptions
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UMaterialInstance*>        InOptions                                              (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InClothingPrimitive                                    (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InMeshMaterialIndex                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMaterialCustomizationRowWidget::GenerateOptions(const TArray<class UMaterialInstance*>& InOptions, class UPrimitiveComponent* InClothingPrimitive, int32 InMeshMaterialIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialCustomizationRowWidget", "GenerateOptions");

	Params::MaterialCustomizationRowWidget_GenerateOptions Parms{};

	Parms.InOptions = std::move(InOptions);
	Parms.InClothingPrimitive = InClothingPrimitive;
	Parms.InMeshMaterialIndex = InMeshMaterialIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Modal.EscapeAMenu
// (Final, Native, Public, BlueprintCallable)

void UModal::EscapeAMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Modal", "EscapeAMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.Modal.IsAirlockMenuVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UModal::IsAirlockMenuVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Modal", "IsAirlockMenuVisible");

	Params::Modal_IsAirlockMenuVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Modal.IsCharacterMenuVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UModal::IsCharacterMenuVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Modal", "IsCharacterMenuVisible");

	Params::Modal_IsCharacterMenuVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Modal.IsEmergencyMeetingVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UModal::IsEmergencyMeetingVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Modal", "IsEmergencyMeetingVisible");

	Params::Modal_IsEmergencyMeetingVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Modal.IsEmoteWheelVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UModal::IsEmoteWheelVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Modal", "IsEmoteWheelVisible");

	Params::Modal_IsEmoteWheelVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Modal.IsInGameMenuVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UModal::IsInGameMenuVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Modal", "IsInGameMenuVisible");

	Params::Modal_IsInGameMenuVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Modal.IsItemWheelVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UModal::IsItemWheelVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Modal", "IsItemWheelVisible");

	Params::Modal_IsItemWheelVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Modal.IsMapVotingVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UModal::IsMapVotingVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Modal", "IsMapVotingVisible");

	Params::Modal_IsMapVotingVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Modal.IsPlayerListVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UModal::IsPlayerListVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Modal", "IsPlayerListVisible");

	Params::Modal_IsPlayerListVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Modal.IsPuzzleMenuVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UModal::IsPuzzleMenuVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Modal", "IsPuzzleMenuVisible");

	Params::Modal_IsPuzzleMenuVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Modal.IsSkillCheckMenuVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UModal::IsSkillCheckMenuVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Modal", "IsSkillCheckMenuVisible");

	Params::Modal_IsSkillCheckMenuVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Modal.IsSpectatorHUDMenuVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UModal::IsSpectatorHUDMenuVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Modal", "IsSpectatorHUDMenuVisible");

	Params::Modal_IsSpectatorHUDMenuVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.Modal.IsThumbVoteMenuVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UModal::IsThumbVoteMenuVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("Modal", "IsThumbVoteMenuVisible");

	Params::Modal_IsThumbVoteMenuVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.MoveAttributeSet.OnRep_MoveSpeed
// (Native, Protected)

void UMoveAttributeSet::OnRep_MoveSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoveAttributeSet", "OnRep_MoveSpeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.OxygenAttributeSet.OnRep_MaxOxygen
// (Native, Protected)

void UOxygenAttributeSet::OnRep_MaxOxygen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OxygenAttributeSet", "OnRep_MaxOxygen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.OxygenAttributeSet.OnRep_Oxygen
// (Native, Protected)

void UOxygenAttributeSet::OnRep_Oxygen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OxygenAttributeSet", "OnRep_Oxygen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PartyListInterface.GetDebugPartyMembers
// (Native, Public, BlueprintCallable)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> IPartyListInterface::GetDebugPartyMembers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartyListInterface", "GetDebugPartyMembers");

	Params::PartyListInterface_GetDebugPartyMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PartyListInterface.IsDebugMode
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IPartyListInterface::IsDebugMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PartyListInterface", "IsDebugMode");

	Params::PartyListInterface_IsDebugMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PassengerLogGenerator.CanSpawn
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPassengerLogGenerator::CanSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGenerator", "CanSpawn");

	Params::PassengerLogGenerator_CanSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PassengerLogGenerator.GetDescriptionText
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPassengerLogGenerator::GetDescriptionText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGenerator", "GetDescriptionText");

	Params::PassengerLogGenerator_GetDescriptionText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function SCT.PassengerLogGenerator.GetInformation
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FPassengerLogInformation         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPassengerLogInformation UPassengerLogGenerator::GetInformation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGenerator", "GetInformation");

	Params::PassengerLogGenerator_GetInformation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PassengerLogGenerator.Initialize
// (Event, Public, BlueprintCallable, BlueprintEvent)

void UPassengerLogGenerator::Initialize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGenerator", "Initialize");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.PassengerLogGenerator.LogShit
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           Msg                                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPassengerLogGenerator::LogShit(const class FString& Msg)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGenerator", "LogShit");

	Params::PassengerLogGenerator_LogShit Parms{};

	Parms.Msg = std::move(Msg);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PassengerLogGenerator.Sabotage
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FInteractionPayload              Payload                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UPassengerLogGenerator::Sabotage(const struct FInteractionPayload& Payload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGenerator", "Sabotage");

	Params::PassengerLogGenerator_Sabotage Parms{};

	Parms.Payload = std::move(Payload);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.PassengerLogGenerator.SetTargets
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           Targets                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UPassengerLogGenerator::SetTargets(const TArray<int32>& Targets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGenerator", "SetTargets");

	Params::PassengerLogGenerator_SetTargets Parms{};

	Parms.Targets = std::move(Targets);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PassengerLogGenerator.GetContextObject
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UPassengerLogGenerator::GetContextObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGenerator", "GetContextObject");

	Params::PassengerLogGenerator_GetContextObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PassengerLogGenerator.GetPassengerLogGIS
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPassengerLogGIS*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPassengerLogGIS* UPassengerLogGenerator::GetPassengerLogGIS() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGenerator", "GetPassengerLogGIS");

	Params::PassengerLogGenerator_GetPassengerLogGIS Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PassengerLogGIS.GetRandom
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           bannedPlayers                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPassengerLogGIS::GetRandom(const TArray<int32>& bannedPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGIS", "GetRandom");

	Params::PassengerLogGIS_GetRandom Parms{};

	Parms.bannedPlayers = std::move(bannedPlayers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PassengerLogGIS.GetRandomPersonoid
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           bannedPlayers                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPassengerLogGIS::GetRandomPersonoid(const TArray<int32>& bannedPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGIS", "GetRandomPersonoid");

	Params::PassengerLogGIS_GetRandomPersonoid Parms{};

	Parms.bannedPlayers = std::move(bannedPlayers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PassengerLogGIS.GetRandomPlayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Personoids                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Residents                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UPassengerLogGIS::GetRandomPlayers(int32 Personoids, int32 Residents)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGIS", "GetRandomPlayers");

	Params::PassengerLogGIS_GetRandomPlayers Parms{};

	Parms.Personoids = Personoids;
	Parms.Residents = Residents;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PassengerLogGIS.GetRandomResident
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           bannedPlayers                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPassengerLogGIS::GetRandomResident(const TArray<int32>& bannedPlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGIS", "GetRandomResident");

	Params::PassengerLogGIS_GetRandomResident Parms{};

	Parms.bannedPlayers = std::move(bannedPlayers);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PassengerLogGIS.GetAll
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UPassengerLogGIS::GetAll() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGIS", "GetAll");

	Params::PassengerLogGIS_GetAll Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PassengerLogGIS.GetAllFromFaction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerFaction                          Faction                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UPassengerLogGIS::GetAllFromFaction(EPlayerFaction Faction) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PassengerLogGIS", "GetAllFromFaction");

	Params::PassengerLogGIS_GetAllFromFaction Parms{};

	Parms.Faction = Faction;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PersonoidChatAbility.DisablePersonoidChannel
// (Final, Native, Protected, BlueprintCallable)

void UPersonoidChatAbility::DisablePersonoidChannel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersonoidChatAbility", "DisablePersonoidChannel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PersonoidChatAbility.EnablePersonoidChannel
// (Final, Native, Protected, BlueprintCallable)

void UPersonoidChatAbility::EnablePersonoidChannel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersonoidChatAbility", "EnablePersonoidChannel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PersonoidInformationComponent.HaveAllPersonoidsReplicated
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPersonoidInformationComponent::HaveAllPersonoidsReplicated(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PersonoidInformationComponent", "HaveAllPersonoidsReplicated");

	Params::PersonoidInformationComponent_HaveAllPersonoidsReplicated Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PersonoidInformationComponent.ReplicatedPersonoidsInformationNum
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPersonoidInformationComponent::ReplicatedPersonoidsInformationNum(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PersonoidInformationComponent", "ReplicatedPersonoidsInformationNum");

	Params::PersonoidInformationComponent_ReplicatedPersonoidsInformationNum Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PersonoidInformationComponent.GetFaction
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerFaction                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerFaction UPersonoidInformationComponent::GetFaction(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersonoidInformationComponent", "GetFaction");

	Params::PersonoidInformationComponent_GetFaction Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PersonoidInformationComponent.OnRep_PlayerInformation
// (Final, Native, Public)

void UPersonoidInformationComponent::OnRep_PlayerInformation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PersonoidInformationComponent", "OnRep_PlayerInformation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerHapticsComponent.Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InPlayerController                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundSubmix*                     InPadTactileMix                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USoundSubmix*                     InPadAudioMix                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHapticsComponent::Initialize(const class APlayerController* InPlayerController, const class USoundSubmix* InPadTactileMix, const class USoundSubmix* InPadAudioMix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHapticsComponent", "Initialize");

	Params::PlayerHapticsComponent_Initialize Parms{};

	Parms.InPlayerController = InPlayerController;
	Parms.InPadTactileMix = InPadTactileMix;
	Parms.InPadAudioMix = InPadAudioMix;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerHapticsComponent.PauseHapticsEffects
// (Final, Native, Public, BlueprintCallable)

void UPlayerHapticsComponent::PauseHapticsEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHapticsComponent", "PauseHapticsEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerHapticsComponent.ResetKeyHaptics
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHapticsComponent::ResetKeyHaptics(class FName ActionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHapticsComponent", "ResetKeyHaptics");

	Params::PlayerHapticsComponent_ResetKeyHaptics Parms{};

	Parms.ActionName = ActionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerHapticsComponent.ResistKeyPress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PressRangeStart                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PressRangeEnd                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHapticsComponent::ResistKeyPress(class FName ActionName, float PressRangeStart, float PressRangeEnd, float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHapticsComponent", "ResistKeyPress");

	Params::PlayerHapticsComponent_ResistKeyPress Parms{};

	Parms.ActionName = ActionName;
	Parms.PressRangeStart = PressRangeStart;
	Parms.PressRangeEnd = PressRangeEnd;
	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerHapticsComponent.ResumeHapticsEffects
// (Final, Native, Public, BlueprintCallable)

void UPlayerHapticsComponent::ResumeHapticsEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHapticsComponent", "ResumeHapticsEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerHapticsComponent.RumbleKey
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             ActionName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PressRangeStart                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Frequency                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Amplitude                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerHapticsComponent::RumbleKey(class FName ActionName, float PressRangeStart, float Frequency, float Amplitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerHapticsComponent", "RumbleKey");

	Params::PlayerHapticsComponent_RumbleKey Parms{};

	Parms.ActionName = ActionName;
	Parms.PressRangeStart = PressRangeStart;
	Parms.Frequency = Frequency;
	Parms.Amplitude = Amplitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.AddCollaborationScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::AddCollaborationScore(int32 PlayerId, int32 Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "AddCollaborationScore");

	Params::PlayerInfoGIS_AddCollaborationScore Parms{};

	Parms.PlayerId = PlayerId;
	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.AddDeceptionScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::AddDeceptionScore(int32 PlayerId, int32 Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "AddDeceptionScore");

	Params::PlayerInfoGIS_AddDeceptionScore Parms{};

	Parms.PlayerId = PlayerId;
	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.AddDeductionScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::AddDeductionScore(int32 PlayerId, int32 Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "AddDeductionScore");

	Params::PlayerInfoGIS_AddDeductionScore Parms{};

	Parms.PlayerId = PlayerId;
	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.AddEndScenarioScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::AddEndScenarioScore(int32 PlayerId, int32 Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "AddEndScenarioScore");

	Params::PlayerInfoGIS_AddEndScenarioScore Parms{};

	Parms.PlayerId = PlayerId;
	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.AddProgressionScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::AddProgressionScore(int32 PlayerId, int32 Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "AddProgressionScore");

	Params::PlayerInfoGIS_AddProgressionScore Parms{};

	Parms.PlayerId = PlayerId;
	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.AddSabotageScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::AddSabotageScore(int32 PlayerId, int32 Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "AddSabotageScore");

	Params::PlayerInfoGIS_AddSabotageScore Parms{};

	Parms.PlayerId = PlayerId;
	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.AddScoreEntry
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             RowName                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::AddScoreEntry(int32 PlayerId, class FName RowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "AddScoreEntry");

	Params::PlayerInfoGIS_AddScoreEntry Parms{};

	Parms.PlayerId = PlayerId;
	Parms.RowName = RowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.AddTotalPersonoidScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::AddTotalPersonoidScore(int32 PlayerId, int32 Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "AddTotalPersonoidScore");

	Params::PlayerInfoGIS_AddTotalPersonoidScore Parms{};

	Parms.PlayerId = PlayerId;
	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.AddTotalResidentScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::AddTotalResidentScore(int32 PlayerId, int32 Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "AddTotalResidentScore");

	Params::PlayerInfoGIS_AddTotalResidentScore Parms{};

	Parms.PlayerId = PlayerId;
	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.GetAgenda
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAgendaObject*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAgendaObject* UPlayerInfoGIS::GetAgenda(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "GetAgenda");

	Params::PlayerInfoGIS_GetAgenda Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.GetAllPlayerData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<struct FPlayerData>              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FPlayerData> UPlayerInfoGIS::GetAllPlayerData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "GetAllPlayerData");

	Params::PlayerInfoGIS_GetAllPlayerData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.GetCharacterVariant
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UPlayerInfoGIS::GetCharacterVariant(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "GetCharacterVariant");

	Params::PlayerInfoGIS_GetCharacterVariant Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.GetDownvotedPlayers
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TargetPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UPlayerInfoGIS::GetDownvotedPlayers(int32 TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "GetDownvotedPlayers");

	Params::PlayerInfoGIS_GetDownvotedPlayers Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.GetFate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APawn*                            Pawn                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFate                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EFate UPlayerInfoGIS::GetFate(const class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "GetFate");

	Params::PlayerInfoGIS_GetFate Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.GetHumanoidVariant
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* UPlayerInfoGIS::GetHumanoidVariant(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "GetHumanoidVariant");

	Params::PlayerInfoGIS_GetHumanoidVariant Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.GetScore
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FScore                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FScore UPlayerInfoGIS::GetScore(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "GetScore");

	Params::PlayerInfoGIS_GetScore Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.GetUpvotedPlayers
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   TargetPlayer                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<int32> UPlayerInfoGIS::GetUpvotedPlayers(int32 TargetPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "GetUpvotedPlayers");

	Params::PlayerInfoGIS_GetUpvotedPlayers Parms{};

	Parms.TargetPlayer = TargetPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.Kill
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDestiny                         Destiny                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::Kill(int32 PlayerId, const struct FDestiny& Destiny)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "Kill");

	Params::PlayerInfoGIS_Kill Parms{};

	Parms.PlayerId = PlayerId;
	Parms.Destiny = std::move(Destiny);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.KillWithFate
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EFate                                   Fate                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::KillWithFate(int32 PlayerId, EFate Fate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "KillWithFate");

	Params::PlayerInfoGIS_KillWithFate Parms{};

	Parms.PlayerId = PlayerId;
	Parms.Fate = Fate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.RemoveGlobalData
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UTransitionDataEntry*             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::RemoveGlobalData(const class UTransitionDataEntry* Key)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "RemoveGlobalData");

	Params::PlayerInfoGIS_RemoveGlobalData Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.RemovePlayerData
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UTransitionDataEntry*             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::RemovePlayerData(const class UTransitionDataEntry* Key, int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "RemovePlayerData");

	Params::PlayerInfoGIS_RemovePlayerData Parms{};

	Parms.Key = Key;
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.SaveGlobalBool
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UTransitionDataEntry*             Entry                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::SaveGlobalBool(const class UTransitionDataEntry* Entry, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "SaveGlobalBool");

	Params::PlayerInfoGIS_SaveGlobalBool Parms{};

	Parms.Entry = Entry;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.SaveGlobalFloat
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UTransitionDataEntry*             Entry                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::SaveGlobalFloat(const class UTransitionDataEntry* Entry, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "SaveGlobalFloat");

	Params::PlayerInfoGIS_SaveGlobalFloat Parms{};

	Parms.Entry = Entry;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.SaveGlobalInt
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UTransitionDataEntry*             Entry                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::SaveGlobalInt(const class UTransitionDataEntry* Entry, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "SaveGlobalInt");

	Params::PlayerInfoGIS_SaveGlobalInt Parms{};

	Parms.Entry = Entry;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.SaveGlobalObject
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UTransitionDataEntry*             Entry                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::SaveGlobalObject(const class UTransitionDataEntry* Entry, class UObject* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "SaveGlobalObject");

	Params::PlayerInfoGIS_SaveGlobalObject Parms{};

	Parms.Entry = Entry;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.SavePlayerBool
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UTransitionDataEntry*             Entry                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::SavePlayerBool(const class UTransitionDataEntry* Entry, int32 PlayerId, bool Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "SavePlayerBool");

	Params::PlayerInfoGIS_SavePlayerBool Parms{};

	Parms.Entry = Entry;
	Parms.PlayerId = PlayerId;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.SavePlayerFloat
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UTransitionDataEntry*             Entry                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::SavePlayerFloat(const class UTransitionDataEntry* Entry, int32 PlayerId, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "SavePlayerFloat");

	Params::PlayerInfoGIS_SavePlayerFloat Parms{};

	Parms.Entry = Entry;
	Parms.PlayerId = PlayerId;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.SavePlayerInt
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UTransitionDataEntry*             Entry                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::SavePlayerInt(const class UTransitionDataEntry* Entry, int32 PlayerId, int32 Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "SavePlayerInt");

	Params::PlayerInfoGIS_SavePlayerInt Parms{};

	Parms.Entry = Entry;
	Parms.PlayerId = PlayerId;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.SavePlayerObject
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UTransitionDataEntry*             Entry                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerInfoGIS::SavePlayerObject(const class UTransitionDataEntry* Entry, int32 PlayerId, class UObject* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "SavePlayerObject");

	Params::PlayerInfoGIS_SavePlayerObject Parms{};

	Parms.Entry = Entry;
	Parms.PlayerId = PlayerId;
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PlayerInfoGIS.ContainsGlobalData
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTransitionDataEntry*             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoGIS::ContainsGlobalData(const class UTransitionDataEntry* Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "ContainsGlobalData");

	Params::PlayerInfoGIS_ContainsGlobalData Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.ContainsPlayerData
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTransitionDataEntry*             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoGIS::ContainsPlayerData(const class UTransitionDataEntry* Key, int32 PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "ContainsPlayerData");

	Params::PlayerInfoGIS_ContainsPlayerData Parms{};

	Parms.Key = Key;
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.LoadGlobalBool
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTransitionDataEntry*             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoGIS::LoadGlobalBool(const class UTransitionDataEntry* Key, bool* Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "LoadGlobalBool");

	Params::PlayerInfoGIS_LoadGlobalBool Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.LoadGlobalFloat
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTransitionDataEntry*             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoGIS::LoadGlobalFloat(const class UTransitionDataEntry* Key, float* Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "LoadGlobalFloat");

	Params::PlayerInfoGIS_LoadGlobalFloat Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.LoadGlobalInt
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTransitionDataEntry*             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoGIS::LoadGlobalInt(const class UTransitionDataEntry* Key, int32* Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "LoadGlobalInt");

	Params::PlayerInfoGIS_LoadGlobalInt Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.LoadGlobalObject
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTransitionDataEntry*             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoGIS::LoadGlobalObject(const class UTransitionDataEntry* Key, class UObject** Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "LoadGlobalObject");

	Params::PlayerInfoGIS_LoadGlobalObject Parms{};

	Parms.Key = Key;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.LoadPlayerBool
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTransitionDataEntry*             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoGIS::LoadPlayerBool(const class UTransitionDataEntry* Key, int32 PlayerId, bool* Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "LoadPlayerBool");

	Params::PlayerInfoGIS_LoadPlayerBool Parms{};

	Parms.Key = Key;
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.LoadPlayerFloat
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTransitionDataEntry*             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoGIS::LoadPlayerFloat(const class UTransitionDataEntry* Key, int32 PlayerId, float* Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "LoadPlayerFloat");

	Params::PlayerInfoGIS_LoadPlayerFloat Parms{};

	Parms.Key = Key;
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.LoadPlayerInt
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTransitionDataEntry*             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoGIS::LoadPlayerInt(const class UTransitionDataEntry* Key, int32 PlayerId, int32* Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "LoadPlayerInt");

	Params::PlayerInfoGIS_LoadPlayerInt Parms{};

	Parms.Key = Key;
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function SCT.PlayerInfoGIS.LoadPlayerObject
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTransitionDataEntry*             Key                                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerInfoGIS::LoadPlayerObject(const class UTransitionDataEntry* Key, int32 PlayerId, class UObject** Value) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerInfoGIS", "LoadPlayerObject");

	Params::PlayerInfoGIS_LoadPlayerObject Parms{};

	Parms.Key = Key;
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Value != nullptr)
		*Value = Parms.Value;

	return Parms.ReturnValue;
}


// Function SCT.PlayerListWidget.PlayerStateAdded
// (Event, Public, BlueprintEvent)
// Parameters:
// class ASCTPlayerState*                  PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerListWidget::PlayerStateAdded(class ASCTPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerListWidget", "PlayerStateAdded");

	Params::PlayerListWidget_PlayerStateAdded Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.PlayerListWidget.PlayerStateRemoved
// (Event, Public, BlueprintEvent)
// Parameters:
// class ASCTPlayerState*                  PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerListWidget::PlayerStateRemoved(class ASCTPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerListWidget", "PlayerStateRemoved");

	Params::PlayerListWidget_PlayerStateRemoved Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.PlayerListWidget.PostLevelChange
// (Event, Public, BlueprintEvent)

void UPlayerListWidget::PostLevelChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerListWidget", "PostLevelChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.PlayerListWidget.PreLevelChange
// (Event, Public, BlueprintEvent)

void UPlayerListWidget::PreLevelChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerListWidget", "PreLevelChange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.PlayerProfileUserWidget.FindLevelFromExperience
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   CurrentExperience                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<int32>                           LevelRequirements                                      (ConstParm, Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// int32                                   OutLevel                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutPercentToNextLevel                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerProfileUserWidget::FindLevelFromExperience(const int32 CurrentExperience, const TArray<int32>& LevelRequirements, int32* OutLevel, float* OutPercentToNextLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerProfileUserWidget", "FindLevelFromExperience");

	Params::PlayerProfileUserWidget_FindLevelFromExperience Parms{};

	Parms.CurrentExperience = CurrentExperience;
	Parms.LevelRequirements = std::move(LevelRequirements);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLevel != nullptr)
		*OutLevel = Parms.OutLevel;

	if (OutPercentToNextLevel != nullptr)
		*OutPercentToNextLevel = Parms.OutPercentToNextLevel;
}


// Function SCT.PlayerStateEvent.Broadcast
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class ASCTPlayerState*                  PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerStateEvent::Broadcast(class ASCTPlayerState* PlayerState) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateEvent", "Broadcast");

	Params::PlayerStateEvent_Broadcast Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PowerRuntimeDataCacher.CacheRuntimeData
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FPowerRuntimeData                RuntimeData                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void IPowerRuntimeDataCacher::CacheRuntimeData(const struct FPowerRuntimeData& RuntimeData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PowerRuntimeDataCacher", "CacheRuntimeData");

	Params::PowerRuntimeDataCacher_CacheRuntimeData Parms{};

	Parms.RuntimeData = std::move(RuntimeData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.PS5GameStatsGIS.AddStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InStatName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5GameStatsGIS::AddStat(class APlayerController* InPlayerController, class FName InStatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5GameStatsGIS", "AddStat");

	Params::PS5GameStatsGIS_AddStat Parms{};

	Parms.InPlayerController = InPlayerController;
	Parms.InStatName = InStatName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5GameStatsGIS.AddStatByPlayerID
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InPlayerID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InStatName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5GameStatsGIS::AddStatByPlayerID(int32 InPlayerID, class FName InStatName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5GameStatsGIS", "AddStatByPlayerID");

	Params::PS5GameStatsGIS_AddStatByPlayerID Parms{};

	Parms.InPlayerID = InPlayerID;
	Parms.InStatName = InStatName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5GameStatsGIS.RunClientCommand
// (Final, Native, Public)
// Parameters:
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPS5GameStatsClientCommand              InClientCommand                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPS5GameStatsCommandData         InCommandData                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UPS5GameStatsGIS::RunClientCommand(class APlayerController* InPlayerController, EPS5GameStatsClientCommand InClientCommand, const struct FPS5GameStatsCommandData& InCommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5GameStatsGIS", "RunClientCommand");

	Params::PS5GameStatsGIS_RunClientCommand Parms{};

	Parms.InPlayerController = InPlayerController;
	Parms.InClientCommand = InClientCommand;
	Parms.InCommandData = std::move(InCommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.CancelMatches
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPS5MatchControllerGIS::CancelMatches(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "CancelMatches");

	Params::PS5MatchControllerGIS_CancelMatches Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PS5MatchControllerGIS.ClientCreateNewMatch
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ClientCreateNewMatch(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientCreateNewMatch");

	Params::PS5MatchControllerGIS_ClientCreateNewMatch Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ClientFinishMatch
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ClientFinishMatch(class APlayerController* PlayerController, const class FString& MatchID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientFinishMatch");

	Params::PS5MatchControllerGIS_ClientFinishMatch Parms{};

	Parms.PlayerController = PlayerController;
	Parms.MatchID = std::move(MatchID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ClientHasMatch
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPS5MatchControllerGIS::ClientHasMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientHasMatch");

	Params::PS5MatchControllerGIS_ClientHasMatch Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.PS5MatchControllerGIS.ClientJoinMatch
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ClientJoinMatch(class APlayerController* PlayerController, const class FString& MatchID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientJoinMatch");

	Params::PS5MatchControllerGIS_ClientJoinMatch Parms{};

	Parms.PlayerController = PlayerController;
	Parms.MatchID = std::move(MatchID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ClientLeaveMatch
// (Final, Native, Public)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ClientLeaveMatch(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientLeaveMatch");

	Params::PS5MatchControllerGIS_ClientLeaveMatch Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ClientReceiveServerClientStateData
// (Final, Native, Public)
// Parameters:
// struct FPS5MatchControllerClientStateDataPS5MatchControllerClientStateData                      (Parm, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ClientReceiveServerClientStateData(const struct FPS5MatchControllerClientStateData& PS5MatchControllerClientStateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientReceiveServerClientStateData");

	Params::PS5MatchControllerGIS_ClientReceiveServerClientStateData Parms{};

	Parms.PS5MatchControllerClientStateData = std::move(PS5MatchControllerClientStateData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ClientReportMatchEnd
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchEndData                    MatchEndData                                           (Parm, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ClientReportMatchEnd(class APlayerController* PlayerController, const class FString& MatchID, const struct FMatchEndData& MatchEndData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientReportMatchEnd");

	Params::PS5MatchControllerGIS_ClientReportMatchEnd Parms{};

	Parms.PlayerController = PlayerController;
	Parms.MatchID = std::move(MatchID);
	Parms.MatchEndData = std::move(MatchEndData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ClientResetActivity
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ClientResetActivity(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientResetActivity");

	Params::PS5MatchControllerGIS_ClientResetActivity Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ClientSaveMatch
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ClientSaveMatch(class APlayerController* PlayerController, const class FString& MatchID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientSaveMatch");

	Params::PS5MatchControllerGIS_ClientSaveMatch Parms{};

	Parms.PlayerController = PlayerController;
	Parms.MatchID = std::move(MatchID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ClientShowReviewMatchDialog
// (Final, Native, Public)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ClientShowReviewMatchDialog(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientShowReviewMatchDialog");

	Params::PS5MatchControllerGIS_ClientShowReviewMatchDialog Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ClientUpdateClientStates
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchEndData                    MatchData                                              (Parm, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ClientUpdateClientStates(class APlayerController* PlayerController, const class FString& MatchID, const struct FMatchEndData& MatchData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientUpdateClientStates");

	Params::PS5MatchControllerGIS_ClientUpdateClientStates Parms{};

	Parms.PlayerController = PlayerController;
	Parms.MatchID = std::move(MatchID);
	Parms.MatchData = std::move(MatchData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ClientUpdateDetailsEndMatch
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchEndData                    MatchEndData                                           (Parm, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ClientUpdateDetailsEndMatch(class APlayerController* PlayerController, const class FString& MatchID, const struct FMatchEndData& MatchEndData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientUpdateDetailsEndMatch");

	Params::PS5MatchControllerGIS_ClientUpdateDetailsEndMatch Parms{};

	Parms.PlayerController = PlayerController;
	Parms.MatchID = std::move(MatchID);
	Parms.MatchEndData = std::move(MatchEndData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ClientUpdateInitialMatchDetails
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ClientUpdateInitialMatchDetails(class APlayerController* PlayerController, const class FString& MatchID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientUpdateInitialMatchDetails");

	Params::PS5MatchControllerGIS_ClientUpdateInitialMatchDetails Parms{};

	Parms.PlayerController = PlayerController;
	Parms.MatchID = std::move(MatchID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ClientUpdateStatusStartMatch
// (Final, Native, Private)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MatchID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ClientUpdateStatusStartMatch(class APlayerController* PlayerController, const class FString& MatchID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ClientUpdateStatusStartMatch");

	Params::PS5MatchControllerGIS_ClientUpdateStatusStartMatch Parms{};

	Parms.PlayerController = PlayerController;
	Parms.MatchID = std::move(MatchID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.DoJoinClients
// (Final, Native, Private)

void UPS5MatchControllerGIS::DoJoinClients()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "DoJoinClients");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.DoJoins
// (Final, Native, Private)

void UPS5MatchControllerGIS::DoJoins()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "DoJoins");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.DoMatchFinishes
// (Final, Native, Private)

void UPS5MatchControllerGIS::DoMatchFinishes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "DoMatchFinishes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.DoRequestInitialUpdateDetails
// (Final, Native, Private)

void UPS5MatchControllerGIS::DoRequestInitialUpdateDetails()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "DoRequestInitialUpdateDetails");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.DoRequestMatchEndReport
// (Final, Native, Private)

void UPS5MatchControllerGIS::DoRequestMatchEndReport()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "DoRequestMatchEndReport");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.DoRequestNewMatch
// (Final, Native, Private)

void UPS5MatchControllerGIS::DoRequestNewMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "DoRequestNewMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.DoUpdateClientStates
// (Final, Native, Private)

void UPS5MatchControllerGIS::DoUpdateClientStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "DoUpdateClientStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.DoUpdateDetailsEndMatch
// (Final, Native, Private)

void UPS5MatchControllerGIS::DoUpdateDetailsEndMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "DoUpdateDetailsEndMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.DoUpdateGameStateClientStates
// (Final, Native, Private)

void UPS5MatchControllerGIS::DoUpdateGameStateClientStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "DoUpdateGameStateClientStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.DoUpdateStatusStartMatch
// (Final, Native, Private)

void UPS5MatchControllerGIS::DoUpdateStatusStartMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "DoUpdateStatusStartMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.LoadData
// (Final, Native, Public)
// Parameters:
// class UObject*                          Context                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::LoadData(class UObject* Context)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "LoadData");

	Params::PS5MatchControllerGIS_LoadData Parms{};

	Parms.Context = Context;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.RunClientCommand
// (Final, Native, Public)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPS5MatchClientCommand                  ClientCommand                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPS5MatchCommandData             CommandData                                            (Parm, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::RunClientCommand(class APlayerController* PlayerController, EPS5MatchClientCommand ClientCommand, const struct FPS5MatchCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "RunClientCommand");

	Params::PS5MatchControllerGIS_RunClientCommand Parms{};

	Parms.PlayerController = PlayerController;
	Parms.ClientCommand = ClientCommand;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ServerBeginMatch
// (Final, Native, Public)

void UPS5MatchControllerGIS::ServerBeginMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ServerBeginMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ServerClientJoinMatch
// (Final, Native, Public)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ServerClientJoinMatch(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ServerClientJoinMatch");

	Params::PS5MatchControllerGIS_ServerClientJoinMatch Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ServerEndMatch
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FMatchEndData                    MatchEndData                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ServerEndMatch(const struct FMatchEndData& MatchEndData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ServerEndMatch");

	Params::PS5MatchControllerGIS_ServerEndMatch Parms{};

	Parms.MatchEndData = std::move(MatchEndData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ServerProcessCommandResult
// (Final, Native, Public)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPS5MatchServerCommandResult            CommandResult                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPS5MatchCommandData             CommandData                                            (Parm, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ServerProcessCommandResult(class APlayerController* PlayerController, EPS5MatchServerCommandResult CommandResult, const struct FPS5MatchCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ServerProcessCommandResult");

	Params::PS5MatchControllerGIS_ServerProcessCommandResult Parms{};

	Parms.PlayerController = PlayerController;
	Parms.CommandResult = CommandResult;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ServerRemoveClient
// (Final, Native, Public)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPS5MatchControllerGIS::ServerRemoveClient(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ServerRemoveClient");

	Params::PS5MatchControllerGIS_ServerRemoveClient Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.PS5MatchControllerGIS.ServerStartNewSession
// (Final, Native, Public)

void UPS5MatchControllerGIS::ServerStartNewSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PS5MatchControllerGIS", "ServerStartNewSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.GetCloudStringDataCallbackProxy.GetCloudRecordValue
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// EUserRecordType                         UserRecord                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGetCloudStringDataCallbackProxy* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGetCloudStringDataCallbackProxy* UGetCloudStringDataCallbackProxy::GetCloudRecordValue(EUserRecordType UserRecord, const class FString& FieldName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GetCloudStringDataCallbackProxy", "GetCloudRecordValue");

	Params::GetCloudStringDataCallbackProxy_GetCloudRecordValue Parms{};

	Parms.UserRecord = UserRecord;
	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameInstance.DoPendingXboxLogin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCTGameInstance::DoPendingXboxLogin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "DoPendingXboxLogin");

	Params::SCTGameInstance_DoPendingXboxLogin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameInstance.GetCurrentXboxControllerID
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USCTGameInstance::GetCurrentXboxControllerID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "GetCurrentXboxControllerID");

	Params::SCTGameInstance_GetCurrentXboxControllerID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameInstance.GetLastControllerType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// ESCTControllerType                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ESCTControllerType USCTGameInstance::GetLastControllerType()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "GetLastControllerType");

	Params::SCTGameInstance_GetLastControllerType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameInstance.HasPendingXboxLogin
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCTGameInstance::HasPendingXboxLogin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "HasPendingXboxLogin");

	Params::SCTGameInstance_HasPendingXboxLogin Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameInstance.InitializeXboxUser
// (Final, Native, Public, BlueprintCallable)

void USCTGameInstance::InitializeXboxUser()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "InitializeXboxUser");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameInstance.IsXboxUserLoggedIn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USCTGameInstance::IsXboxUserLoggedIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "IsXboxUserLoggedIn");

	Params::SCTGameInstance_IsXboxUserLoggedIn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameInstance.K2_OnControllerConnectionStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    Connected                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   UserId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ControllerId                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCTGameInstance::K2_OnControllerConnectionStateChanged(bool Connected, int32 UserId, int32 ControllerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "K2_OnControllerConnectionStateChanged");

	Params::SCTGameInstance_K2_OnControllerConnectionStateChanged Parms{};

	Parms.Connected = Connected;
	Parms.UserId = UserId;
	Parms.ControllerId = ControllerId;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.SCTGameInstance.K2_OnXboxUserLoggedOut
// (Event, Public, BlueprintEvent)

void USCTGameInstance::K2_OnXboxUserLoggedOut()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "K2_OnXboxUserLoggedOut");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SCTGameInstance.OnLevelRemovedFromWorld
// (Final, Native, Private)
// Parameters:
// class ULevel*                           InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWorld*                           InWorld                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCTGameInstance::OnLevelRemovedFromWorld(class ULevel* InLevel, class UWorld* InWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "OnLevelRemovedFromWorld");

	Params::SCTGameInstance_OnLevelRemovedFromWorld Parms{};

	Parms.InLevel = InLevel;
	Parms.InWorld = InWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameInstance.OpenFinalLevel
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void USCTGameInstance::OpenFinalLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "OpenFinalLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameInstance.OpenFirstLevel
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void USCTGameInstance::OpenFirstLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "OpenFirstLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameInstance.OpenIntermediateLevel
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCTGameInstance::OpenIntermediateLevel(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "OpenIntermediateLevel");

	Params::SCTGameInstance_OpenIntermediateLevel Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameInstance.SaveController_OnInitialLoadComplete
// (Final, Native, Private)

void USCTGameInstance::SaveController_OnInitialLoadComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "SaveController_OnInitialLoadComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameInstance.UpdateControllerType
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FKey                             LastKeyPressed                                         (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCTGameInstance::UpdateControllerType(const struct FKey& LastKeyPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameInstance", "UpdateControllerType");

	Params::SCTGameInstance_UpdateControllerType Parms{};

	Parms.LastKeyPressed = std::move(LastKeyPressed);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameMode.CancelGame
// (Final, Native, Public)

void ASCTGameMode::CancelGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "CancelGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameMode.DisableEndConditionInDevelopment
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASCTGameMode::DisableEndConditionInDevelopment()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "DisableEndConditionInDevelopment");

	Params::SCTGameMode_DisableEndConditionInDevelopment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameMode.EndMatchWithCondition
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EEndConditions                          EndCondition                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTGameMode::EndMatchWithCondition(EEndConditions EndCondition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "EndMatchWithCondition");

	Params::SCTGameMode_EndMatchWithCondition Parms{};

	Parms.EndCondition = EndCondition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.SCTGameMode.GetAllAlivePersonoids
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ASCTPlayerState*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ASCTPlayerState*> ASCTGameMode::GetAllAlivePersonoids()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "GetAllAlivePersonoids");

	Params::SCTGameMode_GetAllAlivePersonoids Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameMode.GetAllAlivePlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ASCTPlayerState*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ASCTPlayerState*> ASCTGameMode::GetAllAlivePlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "GetAllAlivePlayers");

	Params::SCTGameMode_GetAllAlivePlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameMode.GetAllAliveResidents
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ASCTPlayerState*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ASCTPlayerState*> ASCTGameMode::GetAllAliveResidents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "GetAllAliveResidents");

	Params::SCTGameMode_GetAllAliveResidents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameMode.GetAllDeadPlayers
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ASCTPlayerState*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ASCTPlayerState*> ASCTGameMode::GetAllDeadPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "GetAllDeadPlayers");

	Params::SCTGameMode_GetAllDeadPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameMode.GetAllPersonoids
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ASCTPlayerState*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ASCTPlayerState*> ASCTGameMode::GetAllPersonoids()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "GetAllPersonoids");

	Params::SCTGameMode_GetAllPersonoids Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameMode.GetAllResidents
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class ASCTPlayerState*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ASCTPlayerState*> ASCTGameMode::GetAllResidents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "GetAllResidents");

	Params::SCTGameMode_GetAllResidents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameMode.GiveScore
// (Event, Public, BlueprintEvent)
// Parameters:
// class FName                             ScoreName                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASCTPlayerState*                  PlayerState                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTGameMode::GiveScore(class FName ScoreName, class ASCTPlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "GiveScore");

	Params::SCTGameMode_GiveScore Parms{};

	Parms.ScoreName = ScoreName;
	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.SCTGameMode.K2_OnCharacterDestiny
// (Event, Public, BlueprintEvent)
// Parameters:
// class AHumanoidCharacter*               HumanoidCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDestiny                         Destiny                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    IsPersonoid                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTGameMode::K2_OnCharacterDestiny(class AHumanoidCharacter* HumanoidCharacter, class AController* Controller, const struct FDestiny& Destiny, bool IsPersonoid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "K2_OnCharacterDestiny");

	Params::SCTGameMode_K2_OnCharacterDestiny Parms{};

	Parms.HumanoidCharacter = HumanoidCharacter;
	Parms.Controller = Controller;
	Parms.Destiny = std::move(Destiny);
	Parms.IsPersonoid = IsPersonoid;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.SCTGameMode.K2_ServerShutdownBegin
// (Event, Public, BlueprintEvent)

void ASCTGameMode::K2_ServerShutdownBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "K2_ServerShutdownBegin");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SCTGameMode.OnCharacterDestiny
// (Native, Public)
// Parameters:
// class AHumanoidCharacter*               HumanoidCharacter                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AController*                      Controller                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDestiny                         Destiny                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    IsPersonoid                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTGameMode::OnCharacterDestiny(class AHumanoidCharacter* HumanoidCharacter, class AController* Controller, const struct FDestiny& Destiny, bool IsPersonoid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "OnCharacterDestiny");

	Params::SCTGameMode_OnCharacterDestiny Parms{};

	Parms.HumanoidCharacter = HumanoidCharacter;
	Parms.Controller = Controller;
	Parms.Destiny = std::move(Destiny);
	Parms.IsPersonoid = IsPersonoid;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameMode.OnReceivedGenderPreference
// (Native, Public)
// Parameters:
// ECustomizationSavedGender               GenderSettings                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ASCTPlayerController*             PlayerController                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTGameMode::OnReceivedGenderPreference(ECustomizationSavedGender GenderSettings, class ASCTPlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "OnReceivedGenderPreference");

	Params::SCTGameMode_OnReceivedGenderPreference Parms{};

	Parms.GenderSettings = GenderSettings;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameMode.Respawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTGameMode::Respawn(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode", "Respawn");

	Params::SCTGameMode_Respawn Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameMode_Warmup.ReceiveSessionStillNotFullTimeout
// (Event, Public, BlueprintEvent)

void ASCTGameMode_Warmup::ReceiveSessionStillNotFullTimeout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode_Warmup", "ReceiveSessionStillNotFullTimeout");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SCTGameMode_Warmup.SessionStillNotFullTimeout
// (Final, Native, Private)

void ASCTGameMode_Warmup::SessionStillNotFullTimeout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode_Warmup", "SessionStillNotFullTimeout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameMode_Warmup.TravelToStartingArea
// (Final, Native, Private)

void ASCTGameMode_Warmup::TravelToStartingArea()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameMode_Warmup", "TravelToStartingArea");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState.CheckForReplicatedPlayerStates
// (Final, Native, Private)

void ASCTGameState::CheckForReplicatedPlayerStates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "CheckForReplicatedPlayerStates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState.K2_OnMatchStarted
// (Event, Protected, BlueprintEvent)

void ASCTGameState::K2_OnMatchStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "K2_OnMatchStarted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SCTGameState.MulticastOnFinishedChangingLevels
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ASCTGameState::MulticastOnFinishedChangingLevels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "MulticastOnFinishedChangingLevels");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState.MulticastOnStartingChangingLevels
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ASCTGameState::MulticastOnStartingChangingLevels()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "MulticastOnStartingChangingLevels");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState.OnRep_PS5MatchControllerClientStateData
// (Final, Native, Private)

void ASCTGameState::OnRep_PS5MatchControllerClientStateData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "OnRep_PS5MatchControllerClientStateData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState.OnRep_XboxGameSessionControllerClientStateData
// (Final, Native, Private)

void ASCTGameState::OnRep_XboxGameSessionControllerClientStateData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "OnRep_XboxGameSessionControllerClientStateData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState.RemoveAllPassengerLogs
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ASCTGameState::RemoveAllPassengerLogs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "RemoveAllPassengerLogs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState.SetEmergencyMeetingInProgress
// (Final, Native, Public)
// Parameters:
// bool                                    InProgress                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTGameState::SetEmergencyMeetingInProgress(bool InProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "SetEmergencyMeetingInProgress");

	Params::SCTGameState_SetEmergencyMeetingInProgress Parms{};

	Parms.InProgress = InProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState.SetPS5MatchControllerClientStateData
// (Final, Native, Public)
// Parameters:
// struct FPS5MatchControllerClientStateDataInPS5MatchControllerClientStateData                    (Parm, NativeAccessSpecifierPublic)

void ASCTGameState::SetPS5MatchControllerClientStateData(const struct FPS5MatchControllerClientStateData& InPS5MatchControllerClientStateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "SetPS5MatchControllerClientStateData");

	Params::SCTGameState_SetPS5MatchControllerClientStateData Parms{};

	Parms.InPS5MatchControllerClientStateData = std::move(InPS5MatchControllerClientStateData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState.SetPS5MatchID
// (Final, Native, Public)
// Parameters:
// class FString                           InMatchID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTGameState::SetPS5MatchID(const class FString& InMatchID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "SetPS5MatchID");

	Params::SCTGameState_SetPS5MatchID Parms{};

	Parms.InMatchID = std::move(InMatchID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState.SetTimesHasTravelled
// (Final, Native, Public)
// Parameters:
// int32                                   TimesTravelled                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTGameState::SetTimesHasTravelled(int32 TimesTravelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "SetTimesHasTravelled");

	Params::SCTGameState_SetTimesHasTravelled Parms{};

	Parms.TimesTravelled = TimesTravelled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState.SetXboxGameSessionControllerClientStateData
// (Final, Native, Public)
// Parameters:
// struct FXboxGameSessionControllerClientStateDataInXboxGameSessionControllerClientStateData             (Parm, NativeAccessSpecifierPublic)

void ASCTGameState::SetXboxGameSessionControllerClientStateData(const struct FXboxGameSessionControllerClientStateData& InXboxGameSessionControllerClientStateData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "SetXboxGameSessionControllerClientStateData");

	Params::SCTGameState_SetXboxGameSessionControllerClientStateData Parms{};

	Parms.InXboxGameSessionControllerClientStateData = std::move(InXboxGameSessionControllerClientStateData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState.SetXboxGameSessionID
// (Final, Native, Public)
// Parameters:
// class FString                           InGameSessionID                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTGameState::SetXboxGameSessionID(const class FString& InGameSessionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "SetXboxGameSessionID");

	Params::SCTGameState_SetXboxGameSessionID Parms{};

	Parms.InGameSessionID = std::move(InGameSessionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState.GetNumberOfTimesHasTravelled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASCTGameState::GetNumberOfTimesHasTravelled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "GetNumberOfTimesHasTravelled");

	Params::SCTGameState_GetNumberOfTimesHasTravelled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameState.GetPS5MatchID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ASCTGameState::GetPS5MatchID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "GetPS5MatchID");

	Params::SCTGameState_GetPS5MatchID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameState.GetXboxGameSessionID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ASCTGameState::GetXboxGameSessionID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "GetXboxGameSessionID");

	Params::SCTGameState_GetXboxGameSessionID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameState.HasTravelledBefore
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASCTGameState::HasTravelledBefore() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "HasTravelledBefore");

	Params::SCTGameState_HasTravelledBefore Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameState.IsBackfillLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASCTGameState::IsBackfillLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "IsBackfillLevel");

	Params::SCTGameState_IsBackfillLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameState.IsFirstLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASCTGameState::IsFirstLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState", "IsFirstLevel");

	Params::SCTGameState_IsFirstLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameState_Match.MatchEnded
// (Event, Protected, BlueprintEvent)
// Parameters:
// struct FMatchEndData                    EndData                                                (Parm, NativeAccessSpecifierPublic)

void ASCTGameState_Match::MatchEnded(const struct FMatchEndData& EndData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState_Match", "MatchEnded");

	Params::SCTGameState_Match_MatchEnded Parms{};

	Parms.EndData = std::move(EndData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.SCTGameState_Match.OnRep_MatchEndData
// (Final, Native, Protected)

void ASCTGameState_Match::OnRep_MatchEndData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState_Match", "OnRep_MatchEndData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState_Match.SetMatchEndState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FMatchEndData                    EndData                                                (Parm, NativeAccessSpecifierPublic)

void ASCTGameState_Match::SetMatchEndState(const struct FMatchEndData& EndData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState_Match", "SetMatchEndState");

	Params::SCTGameState_Match_SetMatchEndState Parms{};

	Parms.EndData = std::move(EndData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.GetCloudIntDataCallbackProxy.GetCloudRecordValue
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// EUserRecordType                         UserRecord                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGetCloudIntDataCallbackProxy*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGetCloudIntDataCallbackProxy* UGetCloudIntDataCallbackProxy::GetCloudRecordValue(EUserRecordType UserRecord, const class FString& FieldName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GetCloudIntDataCallbackProxy", "GetCloudRecordValue");

	Params::GetCloudIntDataCallbackProxy_GetCloudRecordValue Parms{};

	Parms.UserRecord = UserRecord;
	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameState_Warmup.CancelStart
// (Net, NetReliable, Native, Event, NetMulticast, Public)

void ASCTGameState_Warmup::CancelStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState_Warmup", "CancelStart");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState_Warmup.DestroyAllCharacters
// (Final, Native, Protected)

void ASCTGameState_Warmup::DestroyAllCharacters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState_Warmup", "DestroyAllCharacters");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState_Warmup.OnCancelStart
// (Event, Public, BlueprintEvent)

void ASCTGameState_Warmup::OnCancelStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState_Warmup", "OnCancelStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SCTGameState_Warmup.OnClientGoodbyeTick
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   TimeLeft                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTGameState_Warmup::OnClientGoodbyeTick(int32 TimeLeft)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState_Warmup", "OnClientGoodbyeTick");

	Params::SCTGameState_Warmup_OnClientGoodbyeTick Parms{};

	Parms.TimeLeft = TimeLeft;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.SCTGameState_Warmup.OnRep_ClientGoodbyeCountdown
// (Final, Native, Protected)

void ASCTGameState_Warmup::OnRep_ClientGoodbyeCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState_Warmup", "OnRep_ClientGoodbyeCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameState_Warmup.OnRep_ServerStartTime
// (Event, Protected, BlueprintEvent)

void ASCTGameState_Warmup::OnRep_ServerStartTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameState_Warmup", "OnRep_ServerStartTime");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SCTGameUserSettings.GetSCTGameUserSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class USCTGameUserSettings*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USCTGameUserSettings* USCTGameUserSettings::GetSCTGameUserSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SCTGameUserSettings", "GetSCTGameUserSettings");

	Params::SCTGameUserSettings_GetSCTGameUserSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameUserSettings.ApplySoundSettings
// (Final, Native, Public, BlueprintCallable)

void USCTGameUserSettings::ApplySoundSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameUserSettings", "ApplySoundSettings");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTGameUserSettings.GetMasterSoundVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USCTGameUserSettings::GetMasterSoundVolume()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameUserSettings", "GetMasterSoundVolume");

	Params::SCTGameUserSettings_GetMasterSoundVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTGameUserSettings.SetMasterSoundVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Volume                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCTGameUserSettings::SetMasterSoundVolume(float Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTGameUserSettings", "SetMasterSoundVolume");

	Params::SCTGameUserSettings_SetMasterSoundVolume Parms{};

	Parms.Volume = Volume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTKeySelector.SetActionMapping
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FInputChord                      Chord                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCTKeySelector::SetActionMapping(const struct FInputChord& Chord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTKeySelector", "SetActionMapping");

	Params::SCTKeySelector_SetActionMapping Parms{};

	Parms.Chord = std::move(Chord);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTKeySelector.SetGamepadStyle
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FInputChord                      Chord                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCTKeySelector::SetGamepadStyle(const struct FInputChord& Chord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTKeySelector", "SetGamepadStyle");

	Params::SCTKeySelector_SetGamepadStyle Parms{};

	Parms.Chord = std::move(Chord);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.SCTKeySelector.SetKeyboardStyle
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FInputChord                      Chord                                                  (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCTKeySelector::SetKeyboardStyle(const struct FInputChord& Chord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTKeySelector", "SetKeyboardStyle");

	Params::SCTKeySelector_SetKeyboardStyle Parms{};

	Parms.Chord = std::move(Chord);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.SCTKismetArrayLibrary.Array_ShuffleFromSeed
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<int32>                           TargetArray                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCTKismetArrayLibrary::Array_ShuffleFromSeed(const TArray<int32>& TargetArray, int32 Seed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SCTKismetArrayLibrary", "Array_ShuffleFromSeed");

	Params::SCTKismetArrayLibrary_Array_ShuffleFromSeed Parms{};

	Parms.TargetArray = std::move(TargetArray);
	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTLoadingScreenWidget.Start
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           PendingURL                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCTLoadingScreenWidget::Start(const class FString& PendingURL)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTLoadingScreenWidget", "Start");

	Params::SCTLoadingScreenWidget_Start Parms{};

	Parms.PendingURL = std::move(PendingURL);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.GetUserPresenceStatusCallbackProxy.GetPresenceStatusByUserId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAccelByteGIS*                    AccelByteGIS                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGetUserPresenceStatusCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGetUserPresenceStatusCallbackProxy* UGetUserPresenceStatusCallbackProxy::GetPresenceStatusByUserId(const class FString& UserId, class UAccelByteGIS* AccelByteGIS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GetUserPresenceStatusCallbackProxy", "GetPresenceStatusByUserId");

	Params::GetUserPresenceStatusCallbackProxy_GetPresenceStatusByUserId Parms{};

	Parms.UserId = std::move(UserId);
	Parms.AccelByteGIS = AccelByteGIS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTPlayerController.AchievementGrantedError
// (Final, Native, Protected)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::AchievementGrantedError(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "AchievementGrantedError");

	Params::SCTPlayerController_AchievementGrantedError Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.AchievementGrantedSucceeded
// (Final, Native, Protected)
// Parameters:
// class UFCTAchievement*                  AchievementInfo                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::AchievementGrantedSucceeded(class UFCTAchievement* AchievementInfo, const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "AchievementGrantedSucceeded");

	Params::SCTPlayerController_AchievementGrantedSucceeded Parms{};

	Parms.AchievementInfo = AchievementInfo;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ClientGetSessionID
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// class FString                           SessionID                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::ClientGetSessionID(const class FString& SessionID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ClientGetSessionID");

	Params::SCTPlayerController_ClientGetSessionID Parms{};

	Parms.SessionID = std::move(SessionID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ClientOnGrantedPassengerLogInformation
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// struct FPassengerLogInformation         LogInformation                                         (Parm, NativeAccessSpecifierPublic)

void ASCTPlayerController::ClientOnGrantedPassengerLogInformation(const struct FPassengerLogInformation& LogInformation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ClientOnGrantedPassengerLogInformation");

	Params::SCTPlayerController_ClientOnGrantedPassengerLogInformation Parms{};

	Parms.LogInformation = std::move(LogInformation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.CloseVirtualKeyboard
// (Final, Native, Public, BlueprintCallable)

void ASCTPlayerController::CloseVirtualKeyboard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "CloseVirtualKeyboard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ForceDestroyLoadingScreen
// (Final, Exec, Native, Public)

void ASCTPlayerController::ForceDestroyLoadingScreen()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ForceDestroyLoadingScreen");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.GrantAchievement
// (Net, NetReliable, Native, Event, Public, NetClient, BlueprintCallable)
// Parameters:
// class FName                             AchievementName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::GrantAchievement(class FName AchievementName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "GrantAchievement");

	Params::SCTPlayerController_GrantAchievement Parms{};

	Parms.AchievementName = AchievementName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.HandlePushToTalkSharedChannel
// (Final, Native, Protected)
// Parameters:
// bool                                    IsPressed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::HandlePushToTalkSharedChannel(bool IsPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "HandlePushToTalkSharedChannel");

	Params::SCTPlayerController_HandlePushToTalkSharedChannel Parms{};

	Parms.IsPressed = IsPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.K2_OnGrantedPassengerLogInformation
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPassengerLogInformation         LogInformation                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ASCTPlayerController::K2_OnGrantedPassengerLogInformation(const struct FPassengerLogInformation& LogInformation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "K2_OnGrantedPassengerLogInformation");

	Params::SCTPlayerController_K2_OnGrantedPassengerLogInformation Parms{};

	Parms.LogInformation = std::move(LogInformation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.SCTPlayerController.K2_PreClientTravel
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           PendingURL                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETravelType                             TravelType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsSeamlessTravel                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::K2_PreClientTravel(const class FString& PendingURL, ETravelType TravelType, bool bIsSeamlessTravel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "K2_PreClientTravel");

	Params::SCTPlayerController_K2_PreClientTravel Parms{};

	Parms.PendingURL = std::move(PendingURL);
	Parms.TravelType = TravelType;
	Parms.bIsSeamlessTravel = bIsSeamlessTravel;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.SCTPlayerController.LeavePS5Match
// (Final, Native, Public, BlueprintCallable)

void ASCTPlayerController::LeavePS5Match()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "LeavePS5Match");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.LeaveXboxGameSession
// (Final, Native, Public, BlueprintCallable)

void ASCTPlayerController::LeaveXboxGameSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "LeaveXboxGameSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.OnSetUserCustomization
// (Event, Public, BlueprintEvent)

void ASCTPlayerController::OnSetUserCustomization()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "OnSetUserCustomization");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SCTPlayerController.OnSkillcheckGamepadAxis
// (Final, Native, Private)
// Parameters:
// float                                   Val                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::OnSkillcheckGamepadAxis(float Val)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "OnSkillcheckGamepadAxis");

	Params::SCTPlayerController_OnSkillcheckGamepadAxis Parms{};

	Parms.Val = Val;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.QuitToMainMenu
// (BlueprintCosmetic, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Reason                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ASCTPlayerController::QuitToMainMenu(const class FText& Reason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "QuitToMainMenu");

	Params::SCTPlayerController_QuitToMainMenu Parms{};

	Parms.Reason = std::move(Reason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.RunPS5GameStatsClientCommand
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EPS5GameStatsClientCommand              ClientCommand                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPS5GameStatsCommandData         CommandData                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)

void ASCTPlayerController::RunPS5GameStatsClientCommand(EPS5GameStatsClientCommand ClientCommand, const struct FPS5GameStatsCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "RunPS5GameStatsClientCommand");

	Params::SCTPlayerController_RunPS5GameStatsClientCommand Parms{};

	Parms.ClientCommand = ClientCommand;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.RunPS5MatchClientCommand
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EPS5MatchClientCommand                  ClientCommand                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPS5MatchCommandData             CommandData                                            (Parm, NativeAccessSpecifierPublic)

void ASCTPlayerController::RunPS5MatchClientCommand(EPS5MatchClientCommand ClientCommand, const struct FPS5MatchCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "RunPS5MatchClientCommand");

	Params::SCTPlayerController_RunPS5MatchClientCommand Parms{};

	Parms.ClientCommand = ClientCommand;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.RunXboxGameSessionClientCommand
// (Net, NetReliable, Native, Event, Public, NetClient)
// Parameters:
// EXboxGameSessionClientCommand           ClientCommand                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FXboxGameSessionCommandData      CommandData                                            (Parm, NativeAccessSpecifierPublic)

void ASCTPlayerController::RunXboxGameSessionClientCommand(EXboxGameSessionClientCommand ClientCommand, const struct FXboxGameSessionCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "RunXboxGameSessionClientCommand");

	Params::SCTPlayerController_RunXboxGameSessionClientCommand Parms{};

	Parms.ClientCommand = ClientCommand;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ServerPS5MatchCommand
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EPS5MatchServerCommandResult            CommandResult                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPS5MatchCommandData             CommandData                                            (Parm, NativeAccessSpecifierPublic)

void ASCTPlayerController::ServerPS5MatchCommand(EPS5MatchServerCommandResult CommandResult, const struct FPS5MatchCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ServerPS5MatchCommand");

	Params::SCTPlayerController_ServerPS5MatchCommand Parms{};

	Parms.CommandResult = CommandResult;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ServerSetAccelByteBlockingList
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<class FString>                   BlockedByAccelByteIDs                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASCTPlayerController::ServerSetAccelByteBlockingList(const TArray<class FString>& BlockedByAccelByteIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ServerSetAccelByteBlockingList");

	Params::SCTPlayerController_ServerSetAccelByteBlockingList Parms{};

	Parms.BlockedByAccelByteIDs = std::move(BlockedByAccelByteIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ServerSetAccelByteBlockList
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<class FString>                   BlockedAccelByteIDs                                    (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASCTPlayerController::ServerSetAccelByteBlockList(const TArray<class FString>& BlockedAccelByteIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ServerSetAccelByteBlockList");

	Params::SCTPlayerController_ServerSetAccelByteBlockList Parms{};

	Parms.BlockedAccelByteIDs = std::move(BlockedAccelByteIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ServerSetAccelByteDisallowList
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<class FString>                   DisallowedAccelByteIDs                                 (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASCTPlayerController::ServerSetAccelByteDisallowList(const TArray<class FString>& DisallowedAccelByteIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ServerSetAccelByteDisallowList");

	Params::SCTPlayerController_ServerSetAccelByteDisallowList Parms{};

	Parms.DisallowedAccelByteIDs = std::move(DisallowedAccelByteIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ServerSetAccelByteID
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           InAccelByteID                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::ServerSetAccelByteID(const class FString& InAccelByteID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ServerSetAccelByteID");

	Params::SCTPlayerController_ServerSetAccelByteID Parms{};

	Parms.InAccelByteID = std::move(InAccelByteID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ServerSetSonyBlockList
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<class FString>                   BlockedPSNIDs                                          (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASCTPlayerController::ServerSetSonyBlockList(const TArray<class FString>& BlockedPSNIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ServerSetSonyBlockList");

	Params::SCTPlayerController_ServerSetSonyBlockList Parms{};

	Parms.BlockedPSNIDs = std::move(BlockedPSNIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ServerSetSonyInfo
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           PSNID                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInRunningOnPS5                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::ServerSetSonyInfo(const class FString& PSNID, bool bInRunningOnPS5)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ServerSetSonyInfo");

	Params::SCTPlayerController_ServerSetSonyInfo Parms{};

	Parms.PSNID = std::move(PSNID);
	Parms.bInRunningOnPS5 = bInRunningOnPS5;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ServerSetSteamUserID
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::ServerSetSteamUserID(const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ServerSetSteamUserID");

	Params::SCTPlayerController_ServerSetSteamUserID Parms{};

	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ServerSetXboxBlockList
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<class FString>                   BlockedXboxLiveIDs                                     (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASCTPlayerController::ServerSetXboxBlockList(const TArray<class FString>& BlockedXboxLiveIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ServerSetXboxBlockList");

	Params::SCTPlayerController_ServerSetXboxBlockList Parms{};

	Parms.BlockedXboxLiveIDs = std::move(BlockedXboxLiveIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ServerSetXboxDisallowList
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// TArray<class FString>                   DisallowedXboxLiveIDs                                  (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ASCTPlayerController::ServerSetXboxDisallowList(const TArray<class FString>& DisallowedXboxLiveIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ServerSetXboxDisallowList");

	Params::SCTPlayerController_ServerSetXboxDisallowList Parms{};

	Parms.DisallowedXboxLiveIDs = std::move(DisallowedXboxLiveIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ServerSetXboxInfo
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// class FString                           XboxLiveID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::ServerSetXboxInfo(const class FString& XboxLiveID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ServerSetXboxInfo");

	Params::SCTPlayerController_ServerSetXboxInfo Parms{};

	Parms.XboxLiveID = std::move(XboxLiveID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ServerXboxGameSessionCommand
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// EXboxGameSessionServerCommandResult     CommandResult                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FXboxGameSessionCommandData      CommandData                                            (Parm, NativeAccessSpecifierPublic)

void ASCTPlayerController::ServerXboxGameSessionCommand(EXboxGameSessionServerCommandResult CommandResult, const struct FXboxGameSessionCommandData& CommandData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ServerXboxGameSessionCommand");

	Params::SCTPlayerController_ServerXboxGameSessionCommand Parms{};

	Parms.CommandResult = CommandResult;
	Parms.CommandData = std::move(CommandData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.SetAirlockWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::SetAirlockWidget(bool bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "SetAirlockWidget");

	Params::SCTPlayerController_SetAirlockWidget Parms{};

	Parms.bIsVisible = bIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.SetEmergencyWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::SetEmergencyWidget(bool bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "SetEmergencyWidget");

	Params::SCTPlayerController_SetEmergencyWidget Parms{};

	Parms.bIsVisible = bIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.SetMapVotingWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::SetMapVotingWidget(bool bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "SetMapVotingWidget");

	Params::SCTPlayerController_SetMapVotingWidget Parms{};

	Parms.bIsVisible = bIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.SetPawnAccelByteID
// (Final, Native, Public, BlueprintCallable)

void ASCTPlayerController::SetPawnAccelByteID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "SetPawnAccelByteID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.SetPlayerListWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsVisible                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::SetPlayerListWidget(bool bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "SetPlayerListWidget");

	Params::SCTPlayerController_SetPlayerListWidget Parms{};

	Parms.bIsVisible = bIsVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.SetVOIPCommunication
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    Enable                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController::SetVOIPCommunication(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "SetVOIPCommunication");

	Params::SCTPlayerController_SetVOIPCommunication Parms{};

	Parms.Enable = Enable;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.ToggleInGameMenu
// (Final, Native, Public, BlueprintCallable)

void ASCTPlayerController::ToggleInGameMenu()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "ToggleInGameMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController.GetAccelbyteID
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ASCTPlayerController::GetAccelbyteID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "GetAccelbyteID");

	Params::SCTPlayerController_GetAccelbyteID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTPlayerController.GetModal
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UModal*                           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UModal* ASCTPlayerController::GetModal() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "GetModal");

	Params::SCTPlayerController_GetModal Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTPlayerController.GetSymbolPuzzleComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USymbolPuzzleComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USymbolPuzzleComponent* ASCTPlayerController::GetSymbolPuzzleComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "GetSymbolPuzzleComponent");

	Params::SCTPlayerController_GetSymbolPuzzleComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTPlayerController.GetWidgetOrganizer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWidgetOrganizer*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWidgetOrganizer* ASCTPlayerController::GetWidgetOrganizer() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController", "GetWidgetOrganizer");

	Params::SCTPlayerController_GetWidgetOrganizer Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTPlayerController_Match.EndConsoleOnlineMode
// (Final, Native, Public, BlueprintCallable)

void ASCTPlayerController_Match::EndConsoleOnlineMode()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController_Match", "EndConsoleOnlineMode");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController_Match.Server_ProxyVoteOnLevel
// (Net, NetReliable, Native, Event, Public, NetServer, NetValidate)
// Parameters:
// int32                                   LevelIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASCTPlayerController_Match::Server_ProxyVoteOnLevel(int32 LevelIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController_Match", "Server_ProxyVoteOnLevel");

	Params::SCTPlayerController_Match_Server_ProxyVoteOnLevel Parms{};

	Parms.LevelIndex = LevelIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerController_Warmup.Server_ApplyCustomGameSettings
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// struct FCustomGameSettings              CustomSettings                                         (ConstParm, Parm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ASCTPlayerController_Warmup::Server_ApplyCustomGameSettings(const struct FCustomGameSettings& CustomSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerController_Warmup", "Server_ApplyCustomGameSettings");

	Params::SCTPlayerController_Warmup_Server_ApplyCustomGameSettings Parms{};

	Parms.CustomSettings = std::move(CustomSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.GrantPassengerLog
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPassengerLogInformation         PassengerLogInformation                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ASCTPlayerState::GrantPassengerLog(const struct FPassengerLogInformation& PassengerLogInformation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "GrantPassengerLog");

	Params::SCTPlayerState_GrantPassengerLog Parms{};

	Parms.PassengerLogInformation = std::move(PassengerLogInformation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.K2_OnRep_ABUserID
// (Event, Public, BlueprintEvent)

void ASCTPlayerState::K2_OnRep_ABUserID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "K2_OnRep_ABUserID");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SCTPlayerState.OnRep_ABUserID
// (Final, Native, Public)

void ASCTPlayerState::OnRep_ABUserID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_ABUserID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_AccelByteIDsToBlock
// (Final, Native, Private)

void ASCTPlayerState::OnRep_AccelByteIDsToBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_AccelByteIDsToBlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_BlockedByAccelByteIDs
// (Final, Native, Private)

void ASCTPlayerState::OnRep_BlockedByAccelByteIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_BlockedByAccelByteIDs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_BlockedByPSNIDs
// (Final, Native, Private)

void ASCTPlayerState::OnRep_BlockedByPSNIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_BlockedByPSNIDs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_BlockedByXboxLiveIDs
// (Final, Native, Private)

void ASCTPlayerState::OnRep_BlockedByXboxLiveIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_BlockedByXboxLiveIDs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_DisallowedAccelByteIDs
// (Final, Native, Private)

void ASCTPlayerState::OnRep_DisallowedAccelByteIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_DisallowedAccelByteIDs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_DisallowedXboxLiveIDs
// (Final, Native, Private)

void ASCTPlayerState::OnRep_DisallowedXboxLiveIDs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_DisallowedXboxLiveIDs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_Fate
// (Native, Public)

void ASCTPlayerState::OnRep_Fate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_Fate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_HiddenAgendaDescription
// (Event, Public, BlueprintEvent)

void ASCTPlayerState::OnRep_HiddenAgendaDescription()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_HiddenAgendaDescription");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SCTPlayerState.OnRep_HiddenAgendaProgression
// (Event, Public, BlueprintEvent)

void ASCTPlayerState::OnRep_HiddenAgendaProgression()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_HiddenAgendaProgression");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SCTPlayerState.OnRep_HiddenAgendaState
// (Event, Public, BlueprintEvent)

void ASCTPlayerState::OnRep_HiddenAgendaState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_HiddenAgendaState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SCTPlayerState.OnRep_IdentificationColor
// (Final, Native, Private)

void ASCTPlayerState::OnRep_IdentificationColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_IdentificationColor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_PassengerLogInfo
// (Final, Native, Private)

void ASCTPlayerState::OnRep_PassengerLogInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_PassengerLogInfo");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_PSNID
// (Final, Native, Protected)

void ASCTPlayerState::OnRep_PSNID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_PSNID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_PSNIDsToBlock
// (Final, Native, Private)

void ASCTPlayerState::OnRep_PSNIDsToBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_PSNIDsToBlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_RunningOnPS5
// (Final, Native, Protected)

void ASCTPlayerState::OnRep_RunningOnPS5()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_RunningOnPS5");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_SteamUserID
// (Final, Native, Protected)

void ASCTPlayerState::OnRep_SteamUserID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_SteamUserID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_TotalDownVotes
// (Final, Native, Private)

void ASCTPlayerState::OnRep_TotalDownVotes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_TotalDownVotes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_TotalUpVotes
// (Final, Native, Private)

void ASCTPlayerState::OnRep_TotalUpVotes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_TotalUpVotes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_XboxLiveID
// (Final, Native, Protected)

void ASCTPlayerState::OnRep_XboxLiveID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_XboxLiveID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.OnRep_XboxLiveIDsToBlock
// (Final, Native, Private)

void ASCTPlayerState::OnRep_XboxLiveIDsToBlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "OnRep_XboxLiveIDsToBlock");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.RemoveAllPassengerLogs
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ASCTPlayerState::RemoveAllPassengerLogs()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "RemoveAllPassengerLogs");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SCTPlayerState.GetLatestPassengerLog
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPassengerLogInformation         ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPassengerLogInformation ASCTPlayerState::GetLatestPassengerLog() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "GetLatestPassengerLog");

	Params::SCTPlayerState_GetLatestPassengerLog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTPlayerState.GetVoteSum
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ASCTPlayerState::GetVoteSum() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "GetVoteSum");

	Params::SCTPlayerState_GetVoteSum Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTPlayerState.HasPassengerLog
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASCTPlayerState::HasPassengerLog() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTPlayerState", "HasPassengerLog");

	Params::SCTPlayerState_HasPassengerLog Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SCTWidgetComponent.K2_InitWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// class UWidget*                          InitializedWidget                                      (Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USCTWidgetComponent::K2_InitWidget(class UWidget* InitializedWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SCTWidgetComponent", "K2_InitWidget");

	Params::SCTWidgetComponent_K2_InitWidget Parms{};

	Parms.InitializedWidget = InitializedWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.SettingsObject.Apply
// (Native, Public, BlueprintCallable)

void USettingsObject::Apply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsObject", "Apply");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SettingsObject.K2_Apply
// (Event, Protected, BlueprintEvent)

void USettingsObject::K2_Apply()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsObject", "K2_Apply");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SettingsObject.K2_Loaded
// (Event, Protected, BlueprintEvent)

void USettingsObject::K2_Loaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsObject", "K2_Loaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.SettingsObject.K2_Revert
// (Event, Protected, BlueprintEvent)
// Parameters:
// class USettingsObject*                  CachedData                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USettingsObject::K2_Revert(const class USettingsObject* CachedData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsObject", "K2_Revert");

	Params::SettingsObject_K2_Revert Parms{};

	Parms.CachedData = CachedData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.SettingsObject.Reset
// (Native, Public, BlueprintCallable)

void USettingsObject::Reset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SettingsObject", "Reset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SteamUserIDChanged.Broadcast
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class FString                           SteamID                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USteamUserIDChanged::Broadcast(const class FString& SteamID, int32 PlayerId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SteamUserIDChanged", "Broadcast");

	Params::SteamUserIDChanged_Broadcast Parms{};

	Parms.SteamID = std::move(SteamID);
	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.SubMenuUserWidget.AddMenuItemWithEvent
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Title                                                  (Parm, NativeAccessSpecifierPublic)
// TDelegate<void()>                       InOnPressed                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   Width                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USubMenuSelectionButtonUserWidget*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USubMenuSelectionButtonUserWidget* USubMenuUserWidget::AddMenuItemWithEvent(const class FText& Title, const TDelegate<void()>& InOnPressed, float Width)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubMenuUserWidget", "AddMenuItemWithEvent");

	Params::SubMenuUserWidget_AddMenuItemWithEvent Parms{};

	Parms.Title = std::move(Title);
	Parms.InOnPressed = InOnPressed;
	Parms.Width = Width;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SymbolPuzzleWidget.ReceivedSeed
// (Event, Public, BlueprintEvent)
// Parameters:
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USymbolPuzzleWidget::ReceivedSeed(int32 Seed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SymbolPuzzleWidget", "ReceivedSeed");

	Params::SymbolPuzzleWidget_ReceivedSeed Parms{};

	Parms.Seed = Seed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function SCT.SymbolPuzzleWidget.SymbolSelected
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USymbolPuzzleWidget::SymbolSelected(int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SymbolPuzzleWidget", "SymbolSelected");

	Params::SymbolPuzzleWidget_SymbolSelected Parms{};

	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ThumbsVoteInfoComponent.DownVote
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThumbsVoteInfoComponent::DownVote(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThumbsVoteInfoComponent", "DownVote");

	Params::ThumbsVoteInfoComponent_DownVote Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ThumbsVoteInfoComponent.RemoveVotes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThumbsVoteInfoComponent::RemoveVotes(int32 Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThumbsVoteInfoComponent", "RemoveVotes");

	Params::ThumbsVoteInfoComponent_RemoveVotes Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ThumbsVoteInfoComponent.ReplicateToServer
// (Final, Native, Private)

void UThumbsVoteInfoComponent::ReplicateToServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThumbsVoteInfoComponent", "ReplicateToServer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ThumbsVoteInfoComponent.Server_SetVotes
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// TArray<int32>                           RemovedVotes                                           (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           UpVotes                                                (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<int32>                           DownVotes                                              (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UThumbsVoteInfoComponent::Server_SetVotes(const TArray<int32>& RemovedVotes, const TArray<int32>& UpVotes, const TArray<int32>& DownVotes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThumbsVoteInfoComponent", "Server_SetVotes");

	Params::ThumbsVoteInfoComponent_Server_SetVotes Parms{};

	Parms.RemovedVotes = std::move(RemovedVotes);
	Parms.UpVotes = std::move(UpVotes);
	Parms.DownVotes = std::move(DownVotes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ThumbsVoteInfoComponent.UpVote
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// int32                                   PlayerId                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UThumbsVoteInfoComponent::UpVote(int32 PlayerId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThumbsVoteInfoComponent", "UpVote");

	Params::ThumbsVoteInfoComponent_UpVote Parms{};

	Parms.PlayerId = PlayerId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.ThumbsVoteInfoComponent.GetAllOtherThumbsVoteComponents
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UThumbsVoteInfoComponent*> ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UThumbsVoteInfoComponent*> UThumbsVoteInfoComponent::GetAllOtherThumbsVoteComponents() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThumbsVoteInfoComponent", "GetAllOtherThumbsVoteComponents");

	Params::ThumbsVoteInfoComponent_GetAllOtherThumbsVoteComponents Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ThumbsVoteInfoComponent.GetOwnerPlayerID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UThumbsVoteInfoComponent::GetOwnerPlayerID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThumbsVoteInfoComponent", "GetOwnerPlayerID");

	Params::ThumbsVoteInfoComponent_GetOwnerPlayerID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ThumbsVoteInfoComponent.HasDownvotedPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThumbsVoteInfoComponent::HasDownvotedPlayer(int32 Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThumbsVoteInfoComponent", "HasDownvotedPlayer");

	Params::ThumbsVoteInfoComponent_HasDownvotedPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.ThumbsVoteInfoComponent.HasUpvotedPlayer
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Player                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UThumbsVoteInfoComponent::HasUpvotedPlayer(int32 Player) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ThumbsVoteInfoComponent", "HasUpvotedPlayer");

	Params::ThumbsVoteInfoComponent_HasUpvotedPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.UserDataCallbackProxy.GetUserData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UUserDataCallbackProxy*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UUserDataCallbackProxy* UUserDataCallbackProxy::GetUserData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UserDataCallbackProxy", "GetUserData");

	Params::UserDataCallbackProxy_GetUserData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTAuthUpdateUserCallbackProxy.UpdateUser
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           DisplayName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           BirthDate                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Email                                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTAuthUpdateUserCallbackProxy*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTAuthUpdateUserCallbackProxy* UFCTAuthUpdateUserCallbackProxy::UpdateUser(const class FString& DisplayName, const class FString& BirthDate, const class FString& Email)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTAuthUpdateUserCallbackProxy", "UpdateUser");

	Params::FCTAuthUpdateUserCallbackProxy_UpdateUser Parms{};

	Parms.DisplayName = std::move(DisplayName);
	Parms.BirthDate = std::move(BirthDate);
	Parms.Email = std::move(Email);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.GetCloudFloatDataCallbackProxy.GetCloudRecordValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EUserRecordType                         UserRecord                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGetCloudFloatDataCallbackProxy*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGetCloudFloatDataCallbackProxy* UGetCloudFloatDataCallbackProxy::GetCloudRecordValue(EUserRecordType UserRecord, const class FString& FieldName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GetCloudFloatDataCallbackProxy", "GetCloudRecordValue");

	Params::GetCloudFloatDataCallbackProxy_GetCloudRecordValue Parms{};

	Parms.UserRecord = UserRecord;
	Parms.FieldName = std::move(FieldName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.SetCloudFloatDataCallbackProxy.SetCloudRecordValue
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// EUserRecordType                         UserRecord                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           FieldName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AddValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USetCloudFloatDataCallbackProxy*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USetCloudFloatDataCallbackProxy* USetCloudFloatDataCallbackProxy::SetCloudRecordValue(EUserRecordType UserRecord, const class FString& FieldName, const float AddValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SetCloudFloatDataCallbackProxy", "SetCloudRecordValue");

	Params::SetCloudFloatDataCallbackProxy_SetCloudRecordValue Parms{};

	Parms.UserRecord = UserRecord;
	Parms.FieldName = std::move(FieldName);
	Parms.AddValue = AddValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CloudCustomizationDataCallbackProxy.GetPublicUserCustomizationRecordByGender
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Male                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCloudCustomizationDataCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCloudCustomizationDataCallbackProxy* UCloudCustomizationDataCallbackProxy::GetPublicUserCustomizationRecordByGender(const class FString& UserId, bool Male)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudCustomizationDataCallbackProxy", "GetPublicUserCustomizationRecordByGender");

	Params::CloudCustomizationDataCallbackProxy_GetPublicUserCustomizationRecordByGender Parms{};

	Parms.UserId = std::move(UserId);
	Parms.Male = Male;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CloudCustomizationDataCallbackProxy.GetPublicUserCustomizationRecordBySelectedGender
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           UserId                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCloudCustomizationDataCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCloudCustomizationDataCallbackProxy* UCloudCustomizationDataCallbackProxy::GetPublicUserCustomizationRecordBySelectedGender(const class FString& UserId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudCustomizationDataCallbackProxy", "GetPublicUserCustomizationRecordBySelectedGender");

	Params::CloudCustomizationDataCallbackProxy_GetPublicUserCustomizationRecordBySelectedGender Parms{};

	Parms.UserId = std::move(UserId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CloudCustomizationDataCallbackProxy.GetUserCustomizationRecordByGender
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    Male                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCloudCustomizationDataCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCloudCustomizationDataCallbackProxy* UCloudCustomizationDataCallbackProxy::GetUserCustomizationRecordByGender(bool Male)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudCustomizationDataCallbackProxy", "GetUserCustomizationRecordByGender");

	Params::CloudCustomizationDataCallbackProxy_GetUserCustomizationRecordByGender Parms{};

	Parms.Male = Male;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CloudCustomizationDataCallbackProxy.GetUserCustomizationRecordBySelectedGender
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCloudCustomizationDataCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCloudCustomizationDataCallbackProxy* UCloudCustomizationDataCallbackProxy::GetUserCustomizationRecordBySelectedGender()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudCustomizationDataCallbackProxy", "GetUserCustomizationRecordBySelectedGender");

	Params::CloudCustomizationDataCallbackProxy_GetUserCustomizationRecordBySelectedGender Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.CloudCustomizationDataCallbackProxy.SetUserCustomizationRecord
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FCloudCustomizationPayload       MalePayload                                            (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FCloudCustomizationPayload       FemalePayload                                          (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    MaleIsSelected                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCloudCustomizationDataCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCloudCustomizationDataCallbackProxy* UCloudCustomizationDataCallbackProxy::SetUserCustomizationRecord(const struct FCloudCustomizationPayload& MalePayload, const struct FCloudCustomizationPayload& FemalePayload, bool MaleIsSelected)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("CloudCustomizationDataCallbackProxy", "SetUserCustomizationRecord");

	Params::CloudCustomizationDataCallbackProxy_SetUserCustomizationRecord Parms{};

	Parms.MalePayload = std::move(MalePayload);
	Parms.FemalePayload = std::move(FemalePayload);
	Parms.MaleIsSelected = MaleIsSelected;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.FCTUpdateUserProfileCustomAttributesCallbackProxy.UpdateUserProfileCustomAttributes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UFCTUpdateUserProfileCustomAttributesCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UFCTUpdateUserProfileCustomAttributesCallbackProxy* UFCTUpdateUserProfileCustomAttributesCallbackProxy::UpdateUserProfileCustomAttributes(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("FCTUpdateUserProfileCustomAttributesCallbackProxy", "UpdateUserProfileCustomAttributes");

	Params::FCTUpdateUserProfileCustomAttributesCallbackProxy_UpdateUserProfileCustomAttributes Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.UserInputSettings.GetFloatValue
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InfoKey                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FallbackValue                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UUserInputSettings::GetFloatValue(const class FName& InfoKey, float FallbackValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInputSettings", "GetFloatValue");

	Params::UserInputSettings_GetFloatValue Parms{};

	Parms.InfoKey = InfoKey;
	Parms.FallbackValue = FallbackValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.UserInputSettings.GetSubComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UInputSettingsSubComponent>SubComponentType                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UInputSettingsSubComponent*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UInputSettingsSubComponent* UUserInputSettings::GetSubComponent(TSubclassOf<class UInputSettingsSubComponent> SubComponentType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInputSettings", "GetSubComponent");

	Params::UserInputSettings_GetSubComponent Parms{};

	Parms.SubComponentType = SubComponentType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.UserInputSettings.SetFloatValue
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FName                             InfoKey                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UUserInputSettings::SetFloatValue(const class FName& InfoKey, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInputSettings", "SetFloatValue");

	Params::UserInputSettings_SetFloatValue Parms{};

	Parms.InfoKey = InfoKey;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.UserInputSettings.IsKeyBound
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             Name_0                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FInputChord                      Key                                                    (ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UUserInputSettings::IsKeyBound(const class FName& Name_0, const struct FInputChord& Key) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("UserInputSettings", "IsKeyBound");

	Params::UserInputSettings_IsKeyBound Parms{};

	Parms.Name_0 = Name_0;
	Parms.Key = std::move(Key);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function SCT.WetnessAttributeSet.OnRep_MaxWetness
// (Native, Protected)

void UWetnessAttributeSet::OnRep_MaxWetness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WetnessAttributeSet", "OnRep_MaxWetness");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.WetnessAttributeSet.OnRep_Wetness
// (Native, Protected)

void UWetnessAttributeSet::OnRep_Wetness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WetnessAttributeSet", "OnRep_Wetness");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.WorldSettingsSCT.OnRep_OxygenLevel
// (Final, Native, Protected)

void AWorldSettingsSCT::OnRep_OxygenLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldSettingsSCT", "OnRep_OxygenLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.WorldSettingsSCT.OxygenTick
// (Final, Native, Private)

void AWorldSettingsSCT::OxygenTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldSettingsSCT", "OxygenTick");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxLoginWidget.OnButtonAPressed
// (Event, Public, BlueprintEvent)

void UXboxLoginWidget::OnButtonAPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxLoginWidget", "OnButtonAPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.XboxLoginWidget.OnLoginFailure
// (Event, Public, BlueprintEvent)

void UXboxLoginWidget::OnLoginFailure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxLoginWidget", "OnLoginFailure");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.XboxLoginWidget.OnLoginSuccess
// (Event, Public, BlueprintEvent)

void UXboxLoginWidget::OnLoginSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxLoginWidget", "OnLoginSuccess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function SCT.XboxLoginWidget.WaitForButtonPress
// (Final, Native, Public, BlueprintCallable)

void UXboxLoginWidget::WaitForButtonPress()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxLoginWidget", "WaitForButtonPress");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function SCT.XboxUserPrivilegeManagerGIS.ClearCache
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInClearUserCacheOnly                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UXboxUserPrivilegeManagerGIS::ClearCache(bool bInClearUserCacheOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("XboxUserPrivilegeManagerGIS", "ClearCache");

	Params::XboxUserPrivilegeManagerGIS_ClearCache Parms{};

	Parms.bInClearUserCacheOnly = bInClearUserCacheOnly;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function SCT.BlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy.CheckMultipleCommunicationPrivileges
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerController*                InPlayerController                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   InXboxLiveUserIDs                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bInForceUpdate                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy* UBlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy::CheckMultipleCommunicationPrivileges(class UObject* WorldContextObject, class APlayerController* InPlayerController, const TArray<class FString>& InXboxLiveUserIDs, bool bInForceUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy", "CheckMultipleCommunicationPrivileges");

	Params::BlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy_CheckMultipleCommunicationPrivileges Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InPlayerController = InPlayerController;
	Parms.InXboxLiveUserIDs = std::move(InXboxLiveUserIDs);
	Parms.bInForceUpdate = bInForceUpdate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

