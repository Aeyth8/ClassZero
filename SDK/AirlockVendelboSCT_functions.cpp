#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AirlockVendelboSCT

#include "Basic.hpp"

#include "AirlockVendelboSCT_classes.hpp"
#include "AirlockVendelboSCT_parameters.hpp"


namespace SDK
{

// Function AirlockVendelboSCT.AirlockVendelboSCT_C.ExecuteUbergraph_AirlockVendelboSCT
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::ExecuteUbergraph_AirlockVendelboSCT(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "ExecuteUbergraph_AirlockVendelboSCT");

	Params::AirlockVendelboSCT_C_ExecuteUbergraph_AirlockVendelboSCT Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.MatchEnded
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// EEndConditions                          End_Condition                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::MatchEnded(EEndConditions End_Condition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "MatchEnded");

	Params::AirlockVendelboSCT_C_MatchEnded Parms{};

	Parms.End_Condition = End_Condition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.Audio Countdown Stop
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::Audio_Countdown_Stop()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "Audio Countdown Stop");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.Audio Countdown Start
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::Audio_Countdown_Start()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "Audio Countdown Start");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.ClearInterviewTimer
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::ClearInterviewTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "ClearInterviewTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.LogOutBPI
// (Public, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::LogOutBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "LogOutBPI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.AllPlayersPresent
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::AllPlayersPresent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "AllPlayersPresent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InfoStageAll
// (Net, NetReliable, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   StatementType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class ACharacter*>               Characters                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AAirlockVendelboSCT_C::InfoStageAll(uint8 StatementType, const TArray<class ACharacter*>& Characters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InfoStageAll");

	Params::AirlockVendelboSCT_C_InfoStageAll Parms{};

	Parms.StatementType = StatementType;
	Parms.Characters = std::move(Characters);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.VoteGivenMulticast
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::VoteGivenMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "VoteGivenMulticast");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.CloseDoor
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::CloseDoor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "CloseDoor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.AirlockFinishedServer
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::AirlockFinishedServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "AirlockFinishedServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.StartAirlock
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::StartAirlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "StartAirlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.OpenDoorMulticast
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::OpenDoorMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "OpenDoorMulticast");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.FlushDoomed
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::FlushDoomed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "FlushDoomed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.SkipAirlockStage
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::SkipAirlockStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "SkipAirlockStage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AAirlockVendelboSCT_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.TrustVoteExpired
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::TrustVoteExpired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "TrustVoteExpired");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.ClearTrustVoteTimer
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::ClearTrustVoteTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "ClearTrustVoteTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.TrustVote
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Yes                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class ACharacter*                       VotingCharacter                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::TrustVote(bool Yes, const class ACharacter*& VotingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "TrustVote");

	Params::AirlockVendelboSCT_C_TrustVote Parms{};

	Parms.Yes = Yes;
	Parms.VotingCharacter = VotingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.SetupTrustVoteParameters
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::SetupTrustVoteParameters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "SetupTrustVoteParameters");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.AirlockVote
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       Character                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ACharacter*                       VotingCharacter                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::AirlockVote(const class ACharacter*& Character, const class ACharacter*& VotingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "AirlockVote");

	Params::AirlockVendelboSCT_C_AirlockVote Parms{};

	Parms.Character = Character;
	Parms.VotingCharacter = VotingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.DeathVoteExpired
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::DeathVoteExpired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "DeathVoteExpired");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.ClearDeathVoteTimer
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::ClearDeathVoteTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "ClearDeathVoteTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.SetupDeathVoteParameters
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::SetupDeathVoteParameters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "SetupDeathVoteParameters");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.ClearPassengerLogVoteTimer
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::ClearPassengerLogVoteTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "ClearPassengerLogVoteTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.PassengerLogVoteExpiration
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::PassengerLogVoteExpiration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "PassengerLogVoteExpiration");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.SetupPassengerLogVoteParameters
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::SetupPassengerLogVoteParameters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "SetupPassengerLogVoteParameters");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.PassengerLogVote
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       TargetCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ACharacter*                       VotingCharacter                                        (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::PassengerLogVote(class ACharacter* TargetCharacter, const class ACharacter*& VotingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "PassengerLogVote");

	Params::AirlockVendelboSCT_C_PassengerLogVote Parms{};

	Parms.TargetCharacter = TargetCharacter;
	Parms.VotingCharacter = VotingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InterviewStageFinished
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ACharacter*>               CharactersInterviewed                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AAirlockVendelboSCT_C::InterviewStageFinished(const TArray<class ACharacter*>& CharactersInterviewed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InterviewStageFinished");

	Params::AirlockVendelboSCT_C_InterviewStageFinished Parms{};

	Parms.CharactersInterviewed = std::move(CharactersInterviewed);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InterviewTimer
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::InterviewTimer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InterviewTimer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InterviewFinishedMulticast
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::InterviewFinishedMulticast()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InterviewFinishedMulticast");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InitiateInterviewStage
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ACharacter*>               Characters                                             (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AAirlockVendelboSCT_C::InitiateInterviewStage(const TArray<class ACharacter*>& Characters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InitiateInterviewStage");

	Params::AirlockVendelboSCT_C_InitiateInterviewStage Parms{};

	Parms.Characters = std::move(Characters);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InterviewPlayerMulticast
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       CharacterForInterview                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::InterviewPlayerMulticast(const class ACharacter* CharacterForInterview)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InterviewPlayerMulticast");

	Params::AirlockVendelboSCT_C_InterviewPlayerMulticast Parms{};

	Parms.CharacterForInterview = CharacterForInterview;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.PassengerLogVoteStageFinished
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::PassengerLogVoteStageFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "PassengerLogVoteStageFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InitiateDeathVoteStage
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ACharacter*>               Players                                                (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AAirlockVendelboSCT_C::InitiateDeathVoteStage(const TArray<class ACharacter*>& Players)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InitiateDeathVoteStage");

	Params::AirlockVendelboSCT_C_InitiateDeathVoteStage Parms{};

	Parms.Players = std::move(Players);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.RevealPassengerLog
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::RevealPassengerLog(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "RevealPassengerLog");

	Params::AirlockVendelboSCT_C_RevealPassengerLog Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InitiateTrustVoteStage
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::InitiateTrustVoteStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InitiateTrustVoteStage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.PassengerLogVoteBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           AirlockTarget                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ACharacter*                       TargetCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ACharacter*                       VotingCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::PassengerLogVoteBPI(class AActor* AirlockTarget, class ACharacter* TargetCharacter, class ACharacter* VotingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "PassengerLogVoteBPI");

	Params::AirlockVendelboSCT_C_PassengerLogVoteBPI Parms{};

	Parms.AirlockTarget = AirlockTarget;
	Parms.TargetCharacter = TargetCharacter;
	Parms.VotingCharacter = VotingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InitiatePassengerLogVoteDisplay
// (Net, NetReliable, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ACharacter*>               Characters                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class ACharacter*>               DoomedCharacters_0                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// uint8                                   ExpectedVotes                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::InitiatePassengerLogVoteDisplay(TArray<class ACharacter*>& Characters, const TArray<class ACharacter*>& DoomedCharacters_0, uint8 ExpectedVotes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InitiatePassengerLogVoteDisplay");

	Params::AirlockVendelboSCT_C_InitiatePassengerLogVoteDisplay Parms{};

	Parms.Characters = std::move(Characters);
	Parms.DoomedCharacters_0 = std::move(DoomedCharacters_0);
	Parms.ExpectedVotes = ExpectedVotes;

	UObject::ProcessEvent(Func, &Parms);

	Characters = std::move(Parms.Characters);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InitiatePassengerLogStage
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::InitiatePassengerLogStage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InitiatePassengerLogStage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.DeathVoteStageFinished
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::DeathVoteStageFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "DeathVoteStageFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.TrustVoteBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetAirlock                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Yes                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class ACharacter*                       VotingCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::TrustVoteBPI(class AActor* TargetAirlock, bool Yes, class ACharacter* VotingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "TrustVoteBPI");

	Params::AirlockVendelboSCT_C_TrustVoteBPI Parms{};

	Parms.TargetAirlock = TargetAirlock;
	Parms.Yes = Yes;
	Parms.VotingCharacter = VotingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.TrustVoteAll
// (Net, NetReliable, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ACharacter*>               DoomedCharacters_0                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// uint8                                   ExpectedVotes                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::TrustVoteAll(const TArray<class ACharacter*>& DoomedCharacters_0, uint8 ExpectedVotes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "TrustVoteAll");

	Params::AirlockVendelboSCT_C_TrustVoteAll Parms{};

	Parms.DoomedCharacters_0 = std::move(DoomedCharacters_0);
	Parms.ExpectedVotes = ExpectedVotes;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.AirlockFinished
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::AirlockFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "AirlockFinished");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.EliminationVoteBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           AirlockTarget                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ACharacter*                       VotedCharacter                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ACharacter*                       VotingCharacter                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::EliminationVoteBPI(class AActor* AirlockTarget, class ACharacter* VotedCharacter, class ACharacter* VotingCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "EliminationVoteBPI");

	Params::AirlockVendelboSCT_C_EliminationVoteBPI Parms{};

	Parms.AirlockTarget = AirlockTarget;
	Parms.VotedCharacter = VotedCharacter;
	Parms.VotingCharacter = VotingCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InitiateDeathVoteUI
// (Net, NetReliable, NetMulticast, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ACharacter*>               PlayersAlive                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class ACharacter*>               DoomedCharacters_0                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// uint8                                   ExpectedVotes                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::InitiateDeathVoteUI(const TArray<class ACharacter*>& PlayersAlive, const TArray<class ACharacter*>& DoomedCharacters_0, uint8 ExpectedVotes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InitiateDeathVoteUI");

	Params::AirlockVendelboSCT_C_InitiateDeathVoteUI Parms{};

	Parms.PlayersAlive = std::move(PlayersAlive);
	Parms.DoomedCharacters_0 = std::move(DoomedCharacters_0);
	Parms.ExpectedVotes = ExpectedVotes;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.BeginAirlockDeliberations
// (BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::BeginAirlockDeliberations()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "BeginAirlockDeliberations");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.SetViewTarget
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::SetViewTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "SetViewTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InitiateAirlockSequenceBPI
// (Public, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::InitiateAirlockSequenceBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InitiateAirlockSequenceBPI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.DisplayAirlockWidgetBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Show                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::DisplayAirlockWidgetBPI(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "DisplayAirlockWidgetBPI");

	Params::AirlockVendelboSCT_C_DisplayAirlockWidgetBPI Parms{};

	Parms.Show = Show;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.AddAlcoholBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   InputValue                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Delay                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::AddAlcoholBPI(float InputValue, bool Delay)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "AddAlcoholBPI");

	Params::AirlockVendelboSCT_C_AddAlcoholBPI Parms{};

	Parms.InputValue = InputValue;
	Parms.Delay = Delay;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.TeleportLocationRotationBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          TargetLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         TargetRotation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::TeleportLocationRotationBPI(const struct FVector& TargetLocation, const struct FRotator& TargetRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "TeleportLocationRotationBPI");

	Params::AirlockVendelboSCT_C_TeleportLocationRotationBPI Parms{};

	Parms.TargetLocation = std::move(TargetLocation);
	Parms.TargetRotation = std::move(TargetRotation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.EnableIK&AimDelayBPI
// (Public, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::EnableIK_AimDelayBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "EnableIK&AimDelayBPI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.SetDestinyBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EFate                                   Fate                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Impulse                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::SetDestinyBPI(EFate Fate, const struct FVector& Impulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "SetDestinyBPI");

	Params::AirlockVendelboSCT_C_SetDestinyBPI Parms{};

	Parms.Fate = Fate;
	Parms.Impulse = std::move(Impulse);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.StartElevatorBPI
// (Public, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::StartElevatorBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "StartElevatorBPI");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.SetAimingStateBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Aiming                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// uint8                                   AimType                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::SetAimingStateBPI(bool Aiming, uint8 AimType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "SetAimingStateBPI");

	Params::AirlockVendelboSCT_C_SetAimingStateBPI Parms{};

	Parms.Aiming = Aiming;
	Parms.AimType = AimType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.RagdollCharacterBPI
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ToRagdoll                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          OptionalImpulse                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Force                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::RagdollCharacterBPI(bool ToRagdoll, float Duration, const struct FVector& OptionalImpulse, bool Force)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "RagdollCharacterBPI");

	Params::AirlockVendelboSCT_C_RagdollCharacterBPI Parms{};

	Parms.ToRagdoll = ToRagdoll;
	Parms.Duration = Duration;
	Parms.OptionalImpulse = std::move(OptionalImpulse);
	Parms.Force = Force;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.OpenFlushDoor__UpdateFunc
// (BlueprintEvent)

void AAirlockVendelboSCT_C::OpenFlushDoor__UpdateFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "OpenFlushDoor__UpdateFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.OpenFlushDoor__FinishedFunc
// (BlueprintEvent)

void AAirlockVendelboSCT_C::OpenFlushDoor__FinishedFunc()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "OpenFlushDoor__FinishedFunc");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.UserConstructionScript
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.Airlock Widget and Camera
// (Public, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::Airlock_Widget_and_Camera()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "Airlock Widget and Camera");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.TeleportAllPlayersToAirlock
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::TeleportAllPlayersToAirlock()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "TeleportAllPlayersToAirlock");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.CheckDeathRequirement
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    SomeoneShouldDie                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32                                   HowManyShouldDie                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::CheckDeathRequirement(bool* SomeoneShouldDie, int32* HowManyShouldDie)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "CheckDeathRequirement");

	Params::AirlockVendelboSCT_C_CheckDeathRequirement Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SomeoneShouldDie != nullptr)
		*SomeoneShouldDie = Parms.SomeoneShouldDie;

	if (HowManyShouldDie != nullptr)
		*HowManyShouldDie = Parms.HowManyShouldDie;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.PlayerIDToDestination
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ReturnLocation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         ReturnRotation                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::PlayerIDToDestination(int32 Index_0, struct FVector* ReturnLocation, struct FRotator* ReturnRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "PlayerIDToDestination");

	Params::AirlockVendelboSCT_C_PlayerIDToDestination Parms{};

	Parms.Index_0 = Index_0;

	UObject::ProcessEvent(Func, &Parms);

	if (ReturnLocation != nullptr)
		*ReturnLocation = std::move(Parms.ReturnLocation);

	if (ReturnRotation != nullptr)
		*ReturnRotation = std::move(Parms.ReturnRotation);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.CountVote
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       Character                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::CountVote(const class ACharacter*& Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "CountVote");

	Params::AirlockVendelboSCT_C_CountVote Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.FindHighestVote
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Deadlock                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<class ACharacter*>               DeadlockedCharacters                                   (Parm, OutParm)
// class ACharacter*                       CharacterVotedOut                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::FindHighestVote(bool* Deadlock, TArray<class ACharacter*>* DeadlockedCharacters, class ACharacter** CharacterVotedOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "FindHighestVote");

	Params::AirlockVendelboSCT_C_FindHighestVote Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Deadlock != nullptr)
		*Deadlock = Parms.Deadlock;

	if (DeadlockedCharacters != nullptr)
		*DeadlockedCharacters = std::move(Parms.DeadlockedCharacters);

	if (CharacterVotedOut != nullptr)
		*CharacterVotedOut = Parms.CharacterVotedOut;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.ReturnControlToPlayer
// (Public, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::ReturnControlToPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "ReturnControlToPlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.AnyPersonoidsLeft
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    PersonoidPresent                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::AnyPersonoidsLeft(bool* PersonoidPresent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "AnyPersonoidsLeft");

	Params::AirlockVendelboSCT_C_AnyPersonoidsLeft Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PersonoidPresent != nullptr)
		*PersonoidPresent = Parms.PersonoidPresent;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.RemoveFromArray
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ACharacter*>               InputArray                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class ACharacter*>               ArrayToRemove                                          (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class ACharacter*>               CleanedArray                                           (Parm, OutParm)

void AAirlockVendelboSCT_C::RemoveFromArray(TArray<class ACharacter*>& InputArray, TArray<class ACharacter*>& ArrayToRemove, TArray<class ACharacter*>* CleanedArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "RemoveFromArray");

	Params::AirlockVendelboSCT_C_RemoveFromArray Parms{};

	Parms.InputArray = std::move(InputArray);
	Parms.ArrayToRemove = std::move(ArrayToRemove);

	UObject::ProcessEvent(Func, &Parms);

	InputArray = std::move(Parms.InputArray);
	ArrayToRemove = std::move(Parms.ArrayToRemove);

	if (CleanedArray != nullptr)
		*CleanedArray = std::move(Parms.CleanedArray);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.FindAnyPassengerLogs
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    PassengerLogPresent                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<class ACharacter*>               PassengerLogCandidates                                 (Parm, OutParm)

void AAirlockVendelboSCT_C::FindAnyPassengerLogs(bool* PassengerLogPresent, TArray<class ACharacter*>* PassengerLogCandidates)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "FindAnyPassengerLogs");

	Params::AirlockVendelboSCT_C_FindAnyPassengerLogs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PassengerLogPresent != nullptr)
		*PassengerLogPresent = Parms.PassengerLogPresent;

	if (PassengerLogCandidates != nullptr)
		*PassengerLogCandidates = std::move(Parms.PassengerLogCandidates);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.ResetVoting
// (Public, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::ResetVoting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "ResetVoting");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.GetHeadCameraTransform
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ACharacter*                       Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Offset                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform                       NewParam                                               (Parm, OutParm, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::GetHeadCameraTransform(class ACharacter* Character, float Offset, struct FTransform* NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "GetHeadCameraTransform");

	Params::AirlockVendelboSCT_C_GetHeadCameraTransform Parms{};

	Parms.Character = Character;
	Parms.Offset = Offset;

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = std::move(Parms.NewParam);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.SetupInterviewWidget
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::SetupInterviewWidget(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "SetupInterviewWidget");

	Params::AirlockVendelboSCT_C_SetupInterviewWidget Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.RemoveSelfFromArray
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class ACharacter*>               InputArray                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class ACharacter*>               OutputArray                                            (Parm, OutParm)

void AAirlockVendelboSCT_C::RemoveSelfFromArray(TArray<class ACharacter*>& InputArray, TArray<class ACharacter*>* OutputArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "RemoveSelfFromArray");

	Params::AirlockVendelboSCT_C_RemoveSelfFromArray Parms{};

	Parms.InputArray = std::move(InputArray);

	UObject::ProcessEvent(Func, &Parms);

	InputArray = std::move(Parms.InputArray);

	if (OutputArray != nullptr)
		*OutputArray = std::move(Parms.OutputArray);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.SetupTrustVoteFunction
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::SetupTrustVoteFunction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "SetupTrustVoteFunction");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.GetAlivePlayersExcludingDoomed
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class ACharacter*>               AlivePlayers                                           (Parm, OutParm)

void AAirlockVendelboSCT_C::GetAlivePlayersExcludingDoomed(TArray<class ACharacter*>* AlivePlayers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "GetAlivePlayersExcludingDoomed");

	Params::AirlockVendelboSCT_C_GetAlivePlayersExcludingDoomed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AlivePlayers != nullptr)
		*AlivePlayers = std::move(Parms.AlivePlayers);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.GetPassengerLogsAliveExcludingDoomed
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   TotalAmountOfLogs                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class ACharacter*>               CharactersWithLogs                                     (Parm, OutParm)

void AAirlockVendelboSCT_C::GetPassengerLogsAliveExcludingDoomed(int32* TotalAmountOfLogs, TArray<class ACharacter*>* CharactersWithLogs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "GetPassengerLogsAliveExcludingDoomed");

	Params::AirlockVendelboSCT_C_GetPassengerLogsAliveExcludingDoomed Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (TotalAmountOfLogs != nullptr)
		*TotalAmountOfLogs = Parms.TotalAmountOfLogs;

	if (CharactersWithLogs != nullptr)
		*CharactersWithLogs = std::move(Parms.CharactersWithLogs);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.ClearAllInProgressStages
// (Public, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::ClearAllInProgressStages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "ClearAllInProgressStages");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.SetupDeathVoteFunction
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ACharacter*>               PlayersForVote                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AAirlockVendelboSCT_C::SetupDeathVoteFunction(const TArray<class ACharacter*>& PlayersForVote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "SetupDeathVoteFunction");

	Params::AirlockVendelboSCT_C_SetupDeathVoteFunction Parms{};

	Parms.PlayersForVote = std::move(PlayersForVote);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.SetupPassengerLogVoteFunction
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ACharacter*>               PlayersForVote                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)

void AAirlockVendelboSCT_C::SetupPassengerLogVoteFunction(const TArray<class ACharacter*>& PlayersForVote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "SetupPassengerLogVoteFunction");

	Params::AirlockVendelboSCT_C_SetupPassengerLogVoteFunction Parms{};

	Parms.PlayersForVote = std::move(PlayersForVote);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.AutomationTestingTimes
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float AAirlockVendelboSCT_C::AutomationTestingTimes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "AutomationTestingTimes");

	Params::AirlockVendelboSCT_C_AutomationTestingTimes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.AutomaticEliminationVote
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::AutomaticEliminationVote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "AutomaticEliminationVote");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.AutomaticPassengerLogVote
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::AutomaticPassengerLogVote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "AutomaticPassengerLogVote");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.ServerTimeToOffset
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float                                   ServerTime                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DecimalDelay                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Offset                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::ServerTimeToOffset(float ServerTime, float* DecimalDelay, int32* Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "ServerTimeToOffset");

	Params::AirlockVendelboSCT_C_ServerTimeToOffset Parms{};

	Parms.ServerTime = ServerTime;

	UObject::ProcessEvent(Func, &Parms);

	if (DecimalDelay != nullptr)
		*DecimalDelay = Parms.DecimalDelay;

	if (Offset != nullptr)
		*Offset = Parms.Offset;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.GetFlushLocation
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue_Location                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::GetFlushLocation(struct FVector* ReturnValue_Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "GetFlushLocation");

	Params::AirlockVendelboSCT_C_GetFlushLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ReturnValue_Location != nullptr)
		*ReturnValue_Location = std::move(Parms.ReturnValue_Location);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.EnablePlayerMovement
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::EnablePlayerMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "EnablePlayerMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.PrintStringDebug
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           InString                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::PrintStringDebug(const class FString& InString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "PrintStringDebug");

	Params::AirlockVendelboSCT_C_PrintStringDebug Parms{};

	Parms.InString = std::move(InString);

	UObject::ProcessEvent(Func, &Parms);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.GetInfoText
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// uint8                                   StatementType                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class ACharacter*>               Characters                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)

class FText AAirlockVendelboSCT_C::GetInfoText(uint8 StatementType, TArray<class ACharacter*>& Characters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "GetInfoText");

	Params::AirlockVendelboSCT_C_GetInfoText Parms{};

	Parms.StatementType = StatementType;
	Parms.Characters = std::move(Characters);

	UObject::ProcessEvent(Func, &Parms);

	Characters = std::move(Parms.Characters);

	return Parms.ReturnValue;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.NamesToString
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class ACharacter*>               Characters                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)

class FText AAirlockVendelboSCT_C::NamesToString(TArray<class ACharacter*>& Characters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "NamesToString");

	Params::AirlockVendelboSCT_C_NamesToString Parms{};

	Parms.Characters = std::move(Characters);

	UObject::ProcessEvent(Func, &Parms);

	Characters = std::move(Parms.Characters);

	return Parms.ReturnValue;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.GetRandomText
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class FText>                     TextArray                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)

class FText AAirlockVendelboSCT_C::GetRandomText(const TArray<class FText>& TextArray)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "GetRandomText");

	Params::AirlockVendelboSCT_C_GetRandomText Parms{};

	Parms.TextArray = std::move(TextArray);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.GetRandomPlayersText
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class FText>                     TextArray                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TArray<class ACharacter*>               Characters                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)

class FText AAirlockVendelboSCT_C::GetRandomPlayersText(const TArray<class FText>& TextArray, TArray<class ACharacter*>& Characters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "GetRandomPlayersText");

	Params::AirlockVendelboSCT_C_GetRandomPlayersText Parms{};

	Parms.TextArray = std::move(TextArray);
	Parms.Characters = std::move(Characters);

	UObject::ProcessEvent(Func, &Parms);

	Characters = std::move(Parms.Characters);

	return Parms.ReturnValue;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.SimulateDisconnect
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void AAirlockVendelboSCT_C::SimulateDisconnect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "SimulateDisconnect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.IsAliveBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Alive                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::IsAliveBPI(bool* Alive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "IsAliveBPI");

	Params::AirlockVendelboSCT_C_IsAliveBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Alive != nullptr)
		*Alive = Parms.Alive;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.GetHeldLogInfoBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// EPassengerLogFactType                   FactType                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FPlayerData>              Players                                                (Parm, OutParm)
// bool                                    HasLog                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::GetHeldLogInfoBPI(EPassengerLogFactType* FactType, TArray<struct FPlayerData>* Players, bool* HasLog)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "GetHeldLogInfoBPI");

	Params::AirlockVendelboSCT_C_GetHeldLogInfoBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FactType != nullptr)
		*FactType = Parms.FactType;

	if (Players != nullptr)
		*Players = std::move(Parms.Players);

	if (HasLog != nullptr)
		*HasLog = Parms.HasLog;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.IsPersonoidBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsPersonoid                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::IsPersonoidBPI(bool* IsPersonoid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "IsPersonoidBPI");

	Params::AirlockVendelboSCT_C_IsPersonoidBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsPersonoid != nullptr)
		*IsPersonoid = Parms.IsPersonoid;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.GetPlayerNameBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           Name_0                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void AAirlockVendelboSCT_C::GetPlayerNameBPI(class FString* Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "GetPlayerNameBPI");

	Params::AirlockVendelboSCT_C_GetPlayerNameBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.IsFemaleBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AAirlockVendelboSCT_C::IsFemaleBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "IsFemaleBPI");

	Params::AirlockVendelboSCT_C_IsFemaleBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.GetAbilitySystemComponentBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class UAbilitySystemComponent* AAirlockVendelboSCT_C::GetAbilitySystemComponentBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "GetAbilitySystemComponentBPI");

	Params::AirlockVendelboSCT_C_GetAbilitySystemComponentBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.GetPortrait
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class UTexture2D* AAirlockVendelboSCT_C::GetPortrait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "GetPortrait");

	Params::AirlockVendelboSCT_C_GetPortrait Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.GetHomingTargetBPI
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class USceneComponent* AAirlockVendelboSCT_C::GetHomingTargetBPI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "GetHomingTargetBPI");

	Params::AirlockVendelboSCT_C_GetHomingTargetBPI Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.IsPlayerBlocked
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState*                     Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bLocked                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::IsPlayerBlocked(class APlayerState* Player, bool* bLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "IsPlayerBlocked");

	Params::AirlockVendelboSCT_C_IsPlayerBlocked Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	if (bLocked != nullptr)
		*bLocked = Parms.bLocked;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.IsPlayerConsoleCommunicationBlocked
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState*                     Player                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bLocked                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::IsPlayerConsoleCommunicationBlocked(class APlayerState* Player, bool* bLocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "IsPlayerConsoleCommunicationBlocked");

	Params::AirlockVendelboSCT_C_IsPlayerConsoleCommunicationBlocked Parms{};

	Parms.Player = Player;

	UObject::ProcessEvent(Func, &Parms);

	if (bLocked != nullptr)
		*bLocked = Parms.bLocked;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.Server_LatentInteractionSuccess
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InteractingActorIsCharacter                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           InteractingInstigator                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           InteractionFacilitator                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Void                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::Server_LatentInteractionSuccess(bool InteractingActorIsCharacter, class AActor* InteractingInstigator, class AActor* InteractionFacilitator, bool* Void)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "Server_LatentInteractionSuccess");

	Params::AirlockVendelboSCT_C_Server_LatentInteractionSuccess Parms{};

	Parms.InteractingActorIsCharacter = InteractingActorIsCharacter;
	Parms.InteractingInstigator = InteractingInstigator;
	Parms.InteractionFacilitator = InteractionFacilitator;

	UObject::ProcessEvent(Func, &Parms);

	if (Void != nullptr)
		*Void = Parms.Void;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InteractReleased
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InteractingActorIsCharacter                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Void                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::InteractReleased(bool InteractingActorIsCharacter, class AActor* InteractingActor, bool* Void)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InteractReleased");

	Params::AirlockVendelboSCT_C_InteractReleased Parms{};

	Parms.InteractingActorIsCharacter = InteractingActorIsCharacter;
	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);

	if (Void != nullptr)
		*Void = Parms.Void;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.GetCanInteract
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsSimulated                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    InteractingActorIsCharacter                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    CanInteract                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::GetCanInteract(bool IsSimulated, bool InteractingActorIsCharacter, class AActor* InteractingActor, bool* CanInteract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "GetCanInteract");

	Params::AirlockVendelboSCT_C_GetCanInteract Parms{};

	Parms.IsSimulated = IsSimulated;
	Parms.InteractingActorIsCharacter = InteractingActorIsCharacter;
	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);

	if (CanInteract != nullptr)
		*CanInteract = Parms.CanInteract;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.InteractPressed
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InteractingActorIsCharacter                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       InteractedHitResult                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void AAirlockVendelboSCT_C::InteractPressed(bool InteractingActorIsCharacter, class AActor* InteractingActor, const struct FHitResult& InteractedHitResult, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "InteractPressed");

	Params::AirlockVendelboSCT_C_InteractPressed Parms{};

	Parms.InteractingActorIsCharacter = InteractingActorIsCharacter;
	Parms.InteractingActor = InteractingActor;
	Parms.InteractedHitResult = std::move(InteractedHitResult);

	UObject::ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function AirlockVendelboSCT.AirlockVendelboSCT_C.ShouldDisableAirlock
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool AAirlockVendelboSCT_C::ShouldDisableAirlock() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AirlockVendelboSCT_C", "ShouldDisableAirlock");

	Params::AirlockVendelboSCT_C_ShouldDisableAirlock Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

