#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SCT

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "AccelByteUe4Sdk_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK
{

// Enum SCT.EFate
// NumValues: 0x0019
enum class EFate : uint8
{
	Unspecified                              = 0,
	Spaced                                   = 1,
	KilledByPlayer                           = 2,
	EnvironmentHazard                        = 3,
	DeathBySyringe                           = 4,
	Escaped                                  = 5,
	Disconnected                             = 6,
	Suffocated                               = 7,
	TrustConsensus                           = 8,
	ShutdownCAIN                             = 9,
	LastResidentStanding                     = 10,
	ResidentEliminated                       = 11,
	Electrocuted                             = 12,
	Crushed                                  = 13,
	Drowned                                  = 14,
	Burned                                   = 15,
	Frozen                                   = 16,
	Deceived                                 = 17,
	MasterOfDeception                        = 18,
	Outsmarted                               = 19,
	Reserved1                                = 20,
	Reserved2                                = 21,
	Reserved3                                = 22,
	None                                     = 23,
	EFate_MAX                                = 24,
};

// Enum SCT.EOxygenState
// NumValues: 0x0006
enum class EOxygenState : uint8
{
	None                                     = 0,
	Normal                                   = 1,
	Low                                      = 2,
	Critical                                 = 3,
	Empty                                    = 4,
	EOxygenState_MAX                         = 5,
};

// Enum SCT.EInventorySlotID
// NumValues: 0x0004
enum class EInventorySlotID : uint8
{
	None                                     = 0,
	Slot1                                    = 1,
	Slot2                                    = 2,
	EInventorySlotID_MAX                     = 3,
};

// Enum SCT.EInteractionCoopReceiverState
// NumValues: 0x0005
enum class EInteractionCoopReceiverState : uint8
{
	AwaitingStartConditions                  = 0,
	Ready                                    = 1,
	OnCooldown                               = 2,
	Disabled                                 = 3,
	EInteractionCoopReceiverState_MAX        = 4,
};

// Enum SCT.EEndConditions
// NumValues: 0x0009
enum class EEndConditions : uint8
{
	None                                     = 0,
	OnlyPersonoidsRemain                     = 1,
	AllPlayersAreDead                        = 2,
	CAINWasShutDown                          = 3,
	CAINReachedButPersonoidPresent           = 4,
	AllVoteYesInAirlock_OnlyResidents        = 5,
	AllVoteYesInAirlock_PersonoidPresent     = 6,
	OnlyOneResidentAlive                     = 7,
	EEndConditions_MAX                       = 8,
};

// Enum SCT.EPlayerFaction
// NumValues: 0x0004
enum class EPlayerFaction : uint8
{
	None                                     = 0,
	Personoid                                = 1,
	Resident                                 = 2,
	EPlayerFaction_MAX                       = 3,
};

// Enum SCT.EPlayerCustomizationGender
// NumValues: 0x0004
enum class EPlayerCustomizationGender : uint8
{
	Male                                     = 0,
	Female                                   = 1,
	Both                                     = 2,
	EPlayerCustomizationGender_MAX           = 3,
};

// Enum SCT.EPlayerCustomizationType
// NumValues: 0x0009
enum class EPlayerCustomizationType : uint8
{
	Head                                     = 0,
	Body                                     = 1,
	Legs                                     = 2,
	Feet                                     = 3,
	Eyewear                                  = 4,
	Accessory                                = 5,
	FacialHair                               = 6,
	Appearance                               = 7,
	EPlayerCustomizationType_MAX             = 8,
};

// Enum SCT.EScoreCondition
// NumValues: 0x0003
enum class EScoreCondition : uint8
{
	None                                     = 0,
	OnSuccessful                             = 1,
	EScoreCondition_MAX                      = 2,
};

// Enum SCT.EAgendaObjectState
// NumValues: 0x0005
enum class EAgendaObjectState : uint8
{
	None                                     = 0,
	InProgress                               = 1,
	Succeeded                                = 2,
	Failed                                   = 3,
	EAgendaObjectState_MAX                   = 4,
};

// Enum SCT.ECharacterInput
// NumValues: 0x000C
enum class ECharacterInput : uint8
{
	None                                     = 0,
	ConfirmAbility                           = 1,
	CancelAbility                            = 2,
	PrimaryUseRoleItem                       = 3,
	SecondaryUseRoleItem                     = 4,
	PrimaryInteract                          = 5,
	SecondaryInteract                        = 6,
	FirstSkill                               = 7,
	SecondSkill                              = 8,
	ThirdSkill                               = 9,
	WalkSlowly                               = 10,
	ECharacterInput_MAX                      = 11,
};

// Enum SCT.EContextPriority
// NumValues: 0x0004
enum class EContextPriority : uint8
{
	Low                                      = 0,
	Normal                                   = 50,
	High                                     = 100,
	EContextPriority_MAX                     = 101,
};

// Enum SCT.ESCTControllerType
// NumValues: 0x0005
enum class ESCTControllerType : uint8
{
	Keyboard                                 = 0,
	Xbox                                     = 1,
	PS4                                      = 2,
	PS5                                      = 3,
	ESCTControllerType_MAX                   = 4,
};

// Enum SCT.ECustomizationOption
// NumValues: 0x000B
enum class ECustomizationOption : uint8
{
	Head                                     = 0,
	Body                                     = 1,
	Legs                                     = 2,
	Feet                                     = 3,
	Eyewear                                  = 4,
	Accessory                                = 5,
	Preset                                   = 6,
	SkinTone                                 = 7,
	HairColor                                = 8,
	EyeColor                                 = 9,
	ECustomizationOption_MAX                 = 10,
};

// Enum SCT.EVruumbaCustomizationType
// NumValues: 0x0004
enum class EVruumbaCustomizationType : uint8
{
	Body                                     = 0,
	Antenna                                  = 1,
	Particles                                = 2,
	EVruumbaCustomizationType_MAX            = 3,
};

// Enum SCT.EItemQuality
// NumValues: 0x0006
enum class EItemQuality : uint8
{
	Classic                                  = 0,
	Elegant                                  = 1,
	Luxurious                                = 2,
	Extravagent                              = 3,
	Premium                                  = 4,
	EItemQuality_MAX                         = 5,
};

// Enum SCT.EUserRecordType
// NumValues: 0x0008
enum class EUserRecordType : uint8
{
	PublicProfileInfo                        = 0,
	PrivateProfileInfo                       = 1,
	VirtualPurchasesInfo                     = 2,
	CustomizationInfo                        = 3,
	BoundPlatformIDsInfo                     = 4,
	EmotesInfo                               = 5,
	RecentlyPlayedWithInfo                   = 6,
	EUserRecordType_MAX                      = 7,
};

// Enum SCT.FFCTFriendListType
// NumValues: 0x0007
enum class EFFCTFriendListType : uint8
{
	FriendList                               = 0,
	IncomingList                             = 1,
	OutgoingList                             = 2,
	SearchList                               = 3,
	RecentList                               = 4,
	PartyList                                = 5,
	FFCTFriendListType_MAX                   = 6,
};

// Enum SCT.ERankedType
// NumValues: 0x0003
enum class ERankedType : uint8
{
	UserRanked                               = 0,
	TopRanked                                = 1,
	ERankedType_MAX                          = 2,
};

// Enum SCT.EFriendsSortType
// NumValues: 0x0005
enum class EFriendsSortType : uint8
{
	Ascending                                = 0,
	Descending                               = 1,
	OnlineOnly                               = 2,
	Platform                                 = 3,
	EFriendsSortType_MAX                     = 4,
};

// Enum SCT.EPremiumCurrency
// NumValues: 0x0003
enum class EPremiumCurrency : uint8
{
	InfinityCoin                             = 0,
	MoonDust                                 = 1,
	EPremiumCurrency_MAX                     = 2,
};

// Enum SCT.EWinningFaction
// NumValues: 0x0004
enum class EWinningFaction : uint8
{
	RESIDENT                                 = 0,
	PERSONOID                                = 1,
	TIE                                      = 2,
	EWinningFaction_MAX                      = 3,
};

// Enum SCT.EMatchEndReason
// NumValues: 0x0004
enum class EMatchEndReason : uint8
{
	MATCHENDED                               = 0,
	SERVERTIMEOUT                            = 1,
	SERVERSHUTDOWN                           = 2,
	EMatchEndReason_MAX                      = 3,
};

// Enum SCT.EMapName
// NumValues: 0x0008
enum class EMapName : uint8
{
	LOBBY                                    = 0,
	MALL                                     = 1,
	RESTAURANT                               = 2,
	CASINO                                   = 3,
	RESORT                                   = 4,
	BOTANICAL_GARDEN                         = 5,
	SERVER_ROOM                              = 6,
	EMapName_MAX                             = 7,
};

// Enum SCT.ECustomizationSavedGender
// NumValues: 0x0004
enum class ECustomizationSavedGender : uint8
{
	Random                                   = 0,
	Male                                     = 1,
	Female                                   = 2,
	ECustomizationSavedGender_MAX            = 3,
};

// Enum SCT.EGlobalServerStatistics
// NumValues: 0x0022
enum class EGlobalServerStatistics : uint8
{
	PersonoidWins                            = 0,
	ResidentWins                             = 1,
	BottlesThrown                            = 2,
	KeycardsUsed                             = 3,
	EndCond_None                             = 4,
	EndCond_OnlyPersonoidsRemain             = 5,
	EndCond_AllPlayersAreDead                = 6,
	EndCond_CainWasShutdown                  = 7,
	EndCond_CainReachedButPersonoidPresent   = 8,
	EndCond_AllVoteYesInAirlockOnlyResidents = 9,
	EndCond_AllVoteYesInAirlockPersonoidsPresent = 10,
	EndCond_OnlyOneResidentAlive             = 11,
	Fate_None                                = 12,
	Fate_Unspecified                         = 13,
	Fate_Spaced                              = 14,
	Fate_KilledByPlayer                      = 15,
	Fate_EnvironmentalHazard                 = 16,
	Fate_DeathBySyringe                      = 17,
	Fate_Escaped                             = 18,
	Fate_Disconnected                        = 19,
	Fate_Suffocated                          = 20,
	Fate_TrustConcensus                      = 21,
	Fate_ShutdownCain                        = 22,
	Fate_LastResidentStanding                = 23,
	Fate_ResidentEliminated                  = 24,
	Fate_Electrocuted                        = 25,
	Fate_Crushed                             = 26,
	Fate_Drowned                             = 27,
	Fate_Burned                              = 28,
	Fate_Frozen                              = 29,
	Fate_Deceived                            = 30,
	Fate_MasterOfDeception                   = 31,
	Fate_Outsmarted                          = 32,
	EGlobalServerStatistics_MAX              = 33,
};

// Enum SCT.EBoolExecs
// NumValues: 0x0004
enum class EBoolExecs : uint8
{
	Execute                                  = 0,
	Success                                  = 1,
	Fail                                     = 2,
	EBoolExecs_MAX                           = 3,
};

// Enum SCT.EGlobalClientStatistics
// NumValues: 0x0005
enum class EGlobalClientStatistics : uint8
{
	BottlesThrown                            = 0,
	KeycardsUsed                             = 1,
	VivoxLoginSuccess                        = 2,
	VivoxLoginFail                           = 3,
	EGlobalClientStatistics_MAX              = 4,
};

// Enum SCT.EItemAction
// NumValues: 0x0005
enum class EItemAction : uint8
{
	PICKEDUP                                 = 0,
	DROPPED                                  = 1,
	USED                                     = 2,
	USED_ON                                  = 3,
	EItemAction_MAX                          = 4,
};

// Enum SCT.EGameRecordType
// NumValues: 0x0002
enum class EGameRecordType : uint8
{
	PlayerGlobals                            = 0,
	EGameRecordType_MAX                      = 1,
};

// Enum SCT.EDispatcherState
// NumValues: 0x0004
enum class EDispatcherState : uint8
{
	Idle                                     = 0,
	Active                                   = 1,
	Succeeded                                = 2,
	EDispatcherState_MAX                     = 3,
};

// Enum SCT.EInteractionType
// NumValues: 0x0012
enum class EInteractionType : uint8
{
	None                                     = 0,
	GrabItem                                 = 1,
	Hacking                                  = 2,
	OxygenOutlet                             = 3,
	PushButton                               = 4,
	RepairButton                             = 5,
	GrabItemFast                             = 6,
	PickupSyringe                            = 7,
	WallShortcutEnter                        = 8,
	WallShortcutExit                         = 9,
	Fiddle                                   = 10,
	PassengerLog                             = 11,
	FixOxygen                                = 12,
	LightFire                                = 13,
	ThrowLifeBuoy                            = 14,
	KeycardHandin                            = 15,
	PickupSyringePadLocked                   = 16,
	EInteractionType_MAX                     = 17,
};

// Enum SCT.EVoteState
// NumValues: 0x0004
enum class SCT::EVoteState : uint32
{
	NotStarted                               = 0,
	InProgress                               = 1,
	Finished                                 = 2,
	EVoteState_MAX                           = 3,
};

// Enum SCT.EModal
// NumValues: 0x000E
enum class EModal : uint16
{
	None                                     = 0,
	InGame                                   = 1,
	Airlock                                  = 2,
	SkillCheck                               = 4,
	Puzzle                                   = 8,
	ItemWheel                                = 16,
	Character                                = 32,
	ThumbVote                                = 64,
	SpectatorHUD                             = 128,
	EmergencyMeeting                         = 256,
	EmoteWheel                               = 512,
	PlayerList                               = 1024,
	MapVoting                                = 2048,
	EModal_MAX                               = 2049,
};

// Enum SCT.EPS5GameStatsClientCommand
// NumValues: 0x0002
enum class EPS5GameStatsClientCommand : uint8
{
	AddStat                                  = 0,
	EPS5GameStatsClientCommand_MAX           = 1,
};

// Enum SCT.EPS5GameStatType
// NumValues: 0x0005
enum class EPS5GameStatType : uint8
{
	None                                     = 0,
	FireExtinguish                           = 1,
	OxygenRefill                             = 2,
	KeycardInsert                            = 3,
	EPS5GameStatType_MAX                     = 4,
};

// Enum SCT.EPS5MatchClientCommand
// NumValues: 0x0009
enum class EPS5MatchClientCommand : uint8
{
	CreateMatch                              = 0,
	UpdateInitialMatchDetails                = 1,
	ClientJoinMatch                          = 2,
	UpdateStatusStartMatch                   = 3,
	UpdateClientStates                       = 4,
	UpdateDetailsEndMatch                    = 5,
	ReportMatchEnd                           = 6,
	ClientFinishMatch                        = 7,
	EPS5MatchClientCommand_MAX               = 8,
};

// Enum SCT.EPS5MatchServerCommandResult
// NumValues: 0x0010
enum class EPS5MatchServerCommandResult : uint8
{
	CreatedMatch                             = 0,
	CreateMatchFailed                        = 1,
	UpdatedInitialMatchDetails               = 2,
	UpdateInitialMatchDetailsFailed          = 3,
	ClientJoinedMatch                        = 4,
	ClientJoinMatchFailed                    = 5,
	ClientLeftMatch                          = 6,
	UpdatedStatusStartMatch                  = 7,
	UpdateStatusStartMatchFailed             = 8,
	UpdatedClientStates                      = 9,
	UpdateClientStatesFailed                 = 10,
	UpdatedDetailsEndMatch                   = 11,
	UpdateDetailsEndMatchFailed              = 12,
	ReportedMatchEnd                         = 13,
	ReportMatchEndFailed                     = 14,
	EPS5MatchServerCommandResult_MAX         = 15,
};

// Enum SCT.EPS5MatchClientState
// NumValues: 0x0008
enum class EPS5MatchClientState : uint8
{
	None                                     = 0,
	RequestJoinMatch                         = 1,
	RequestingJoinMatch                      = 2,
	JoinedMatch                              = 3,
	JoinedMatchNonPS5                        = 4,
	LeftMatch                                = 5,
	LeftMatchNonPS5                          = 6,
	EPS5MatchClientState_MAX                 = 7,
};

// Enum SCT.EPS5MatchServerState
// NumValues: 0x0010
enum class EPS5MatchServerState : uint8
{
	None                                     = 0,
	RequestNewMatch                          = 1,
	RequestingNewMatch                       = 2,
	RequestUpdateInitialMatchDetails         = 3,
	RequestingUpdateInitialMatchDetails      = 4,
	DoJoins                                  = 5,
	WaitStartMatch                           = 6,
	RequestUpdateStatusStartMatch            = 7,
	RequestingUpdateStatusStartMatch         = 8,
	PlayingMatch                             = 9,
	RequestUpdateDetailsEndMatch             = 10,
	RequestingUpdateDetailsEndMatch          = 11,
	RequestMatchEndReport                    = 12,
	RequestingMatchEndReport                 = 13,
	MatchEnded                               = 14,
	EPS5MatchServerState_MAX                 = 15,
};

// Enum SCT.ESkillcheckEndCondition
// NumValues: 0x0004
enum class ESkillcheckEndCondition : uint8
{
	None                                     = 0,
	Infinite                                 = 1,
	Waves                                    = 2,
	ESkillcheckEndCondition_MAX              = 3,
};

// Enum SCT.ETag
// NumValues: 0x0022
enum class ETag : uint8
{
	None                                     = 0,
	Item_Passive                             = 1,
	Item_Unique                              = 2,
	Item_PassengerLog                        = 3,
	Buff_GodLungs                            = 4,
	Skill_Hidden                             = 5,
	Interaction_Type                         = 6,
	Interaction_Type_Duration                = 7,
	Interaction_Type_Immediate               = 8,
	Interaction_Trigger_OnDispatched         = 9,
	Effect_Cooldown                          = 10,
	Effect_Silence                           = 11,
	Effect_SetByCaller_Oxygen                = 12,
	ContextSensitive                         = 13,
	ContextSensitive_Tangible                = 14,
	ContextSensitive_Interactable            = 15,
	CharacterType_Resident                   = 16,
	CharacterType_Personoid                  = 17,
	CharacterType_Spectator                  = 18,
	CharacterState_UsingPower                = 19,
	State_CharacterState_Dead                = 20,
	State_CharacterState_Grabbed             = 21,
	State_CharacterState_Consciousness_Unconscious = 22,
	State_CharacterState_Immovable           = 23,
	State_CharacterState_LockRotation        = 24,
	State_CharacterState_DeathTimerImmunity  = 25,
	State_CharacterState_Inactive            = 26,
	State_CharacterState_Inactive_LevelTransition = 27,
	State_CharacterState_Inactive_Airlock    = 28,
	State_CharacterState_Burning             = 29,
	State_CharacterState_Freezing            = 30,
	State_CharacterState_Drowning            = 31,
	State_CharacterState_Electrocuting       = 32,
	ETag_MAX                                 = 33,
};

// Enum SCT.EWidgetBehaviour
// NumValues: 0x0003
enum class EWidgetBehaviour : uint8
{
	None                                     = 0,
	DestroyOnServerTravel                    = 1,
	EWidgetBehaviour_MAX                     = 2,
};

// Enum SCT.EXboxGameSessionClientCommand
// NumValues: 0x0005
enum class EXboxGameSessionClientCommand : uint8
{
	CreateGameSession                        = 0,
	ClientCreateGameSessionReservation       = 1,
	ClientJoinGameSession                    = 2,
	ClientFinishGameSession                  = 3,
	EXboxGameSessionClientCommand_MAX        = 4,
};

// Enum SCT.EXboxGameSessionServerCommandResult
// NumValues: 0x0008
enum class EXboxGameSessionServerCommandResult : uint8
{
	CreatedGameSession                       = 0,
	CreateGameSessionFailed                  = 1,
	ClientGameSessionReserved                = 2,
	ClientGameSessionReservationFailed       = 3,
	ClientJoinedGameSession                  = 4,
	ClientJoinGameSessionFailed              = 5,
	ClientLeftGameSession                    = 6,
	EXboxGameSessionServerCommandResult_MAX  = 7,
};

// Enum SCT.EXboxGameSessionClientState
// NumValues: 0x000A
enum class EXboxGameSessionClientState : uint8
{
	None                                     = 0,
	RequestGameSessionReservation            = 1,
	RequestingGameSessionReservation         = 2,
	RequestJoinGameSession                   = 3,
	RequestingJoinGameSession                = 4,
	JoinedGameSession                        = 5,
	JoinedGameSessionNonXbox                 = 6,
	LeftGameSession                          = 7,
	LeftGameSessionNonXbox                   = 9,
	EXboxGameSessionClientState_MAX          = 10,
};

// Enum SCT.EXboxGameSessionServerState
// NumValues: 0x000B
enum class EXboxGameSessionServerState : uint8
{
	None                                     = 0,
	RequestNewGameSession                    = 1,
	RequestingNewGameSession                 = 2,
	DoReservations                           = 3,
	DoingReservations                        = 4,
	DoJoins                                  = 5,
	WaitStartGameSession                     = 6,
	PlayingGameSession                       = 7,
	RequestingGameSessionEnd                 = 8,
	GameSessionEnded                         = 9,
	EXboxGameSessionServerState_MAX          = 10,
};

// ScriptStruct SCT.PlayerCategoryStringList
// 0x0010 (0x0010 - 0x0000)
struct FPlayerCategoryStringList final
{
public:
	TArray<class FString>                         ItemNames;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCategoryStringList) == 0x000008, "Wrong alignment on FPlayerCategoryStringList");
static_assert(sizeof(FPlayerCategoryStringList) == 0x000010, "Wrong size on FPlayerCategoryStringList");
static_assert(offsetof(FPlayerCategoryStringList, ItemNames) == 0x000000, "Member 'FPlayerCategoryStringList::ItemNames' has a wrong offset!");

// ScriptStruct SCT.CachedAxes
// 0x0050 (0x0050 - 0x0000)
struct FCachedAxes final
{
public:
	struct FInputAxisKeyMapping                   Keyboard;                                          // 0x0000(0x0028)(NativeAccessSpecifierPublic)
	struct FInputAxisKeyMapping                   Gamepad;                                           // 0x0028(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCachedAxes) == 0x000008, "Wrong alignment on FCachedAxes");
static_assert(sizeof(FCachedAxes) == 0x000050, "Wrong size on FCachedAxes");
static_assert(offsetof(FCachedAxes, Keyboard) == 0x000000, "Member 'FCachedAxes::Keyboard' has a wrong offset!");
static_assert(offsetof(FCachedAxes, Gamepad) == 0x000028, "Member 'FCachedAxes::Gamepad' has a wrong offset!");

// ScriptStruct SCT.CachedActions
// 0x0050 (0x0050 - 0x0000)
struct FCachedActions final
{
public:
	struct FInputActionKeyMapping                 Keyboard;                                          // 0x0000(0x0028)(NativeAccessSpecifierPublic)
	struct FInputActionKeyMapping                 Gamepad;                                           // 0x0028(0x0028)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FCachedActions) == 0x000008, "Wrong alignment on FCachedActions");
static_assert(sizeof(FCachedActions) == 0x000050, "Wrong size on FCachedActions");
static_assert(offsetof(FCachedActions, Keyboard) == 0x000000, "Member 'FCachedActions::Keyboard' has a wrong offset!");
static_assert(offsetof(FCachedActions, Gamepad) == 0x000028, "Member 'FCachedActions::Gamepad' has a wrong offset!");

// ScriptStruct SCT.CachedInput
// 0x00A8 (0x00A8 - 0x0000)
struct FCachedInput final
{
public:
	struct FCachedAxes                            Axes;                                              // 0x0000(0x0050)(NativeAccessSpecifierPublic)
	struct FCachedActions                         Actions;                                           // 0x0050(0x0050)(NativeAccessSpecifierPublic)
	bool                                          Toggle;                                            // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCachedInput) == 0x000008, "Wrong alignment on FCachedInput");
static_assert(sizeof(FCachedInput) == 0x0000A8, "Wrong size on FCachedInput");
static_assert(offsetof(FCachedInput, Axes) == 0x000000, "Member 'FCachedInput::Axes' has a wrong offset!");
static_assert(offsetof(FCachedInput, Actions) == 0x000050, "Member 'FCachedInput::Actions' has a wrong offset!");
static_assert(offsetof(FCachedInput, Toggle) == 0x0000A0, "Member 'FCachedInput::Toggle' has a wrong offset!");

// ScriptStruct SCT.ContextSpec
// 0x00C0 (0x00C0 - 0x0000)
struct FContextSpec final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnDistanceChanged;                                 // 0x0008(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnVisibilityChanged;                               // 0x0018(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCenterChanged;                                   // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDotProductChanged;                               // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemoved;                                         // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnScreenPositionChanged;                           // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UContextStaticMeshComponent> Target;                                            // 0x0078(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Distance;                                          // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DotProduct;                                        // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x008C(0x000C)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistToScreenCenter;                                // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SensorActor;                                       // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UContextSensor*                         Sensor;                                            // 0x00A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       Camera;                                            // 0x00B0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContextSpec) == 0x000008, "Wrong alignment on FContextSpec");
static_assert(sizeof(FContextSpec) == 0x0000C0, "Wrong size on FContextSpec");
static_assert(offsetof(FContextSpec, OnDistanceChanged) == 0x000008, "Member 'FContextSpec::OnDistanceChanged' has a wrong offset!");
static_assert(offsetof(FContextSpec, OnVisibilityChanged) == 0x000018, "Member 'FContextSpec::OnVisibilityChanged' has a wrong offset!");
static_assert(offsetof(FContextSpec, OnCenterChanged) == 0x000028, "Member 'FContextSpec::OnCenterChanged' has a wrong offset!");
static_assert(offsetof(FContextSpec, OnDotProductChanged) == 0x000038, "Member 'FContextSpec::OnDotProductChanged' has a wrong offset!");
static_assert(offsetof(FContextSpec, OnChanged) == 0x000048, "Member 'FContextSpec::OnChanged' has a wrong offset!");
static_assert(offsetof(FContextSpec, OnRemoved) == 0x000058, "Member 'FContextSpec::OnRemoved' has a wrong offset!");
static_assert(offsetof(FContextSpec, OnScreenPositionChanged) == 0x000068, "Member 'FContextSpec::OnScreenPositionChanged' has a wrong offset!");
static_assert(offsetof(FContextSpec, Target) == 0x000078, "Member 'FContextSpec::Target' has a wrong offset!");
static_assert(offsetof(FContextSpec, bIsVisible) == 0x000080, "Member 'FContextSpec::bIsVisible' has a wrong offset!");
static_assert(offsetof(FContextSpec, Distance) == 0x000084, "Member 'FContextSpec::Distance' has a wrong offset!");
static_assert(offsetof(FContextSpec, DotProduct) == 0x000088, "Member 'FContextSpec::DotProduct' has a wrong offset!");
static_assert(offsetof(FContextSpec, Center) == 0x00008C, "Member 'FContextSpec::Center' has a wrong offset!");
static_assert(offsetof(FContextSpec, DistToScreenCenter) == 0x000098, "Member 'FContextSpec::DistToScreenCenter' has a wrong offset!");
static_assert(offsetof(FContextSpec, SensorActor) == 0x0000A0, "Member 'FContextSpec::SensorActor' has a wrong offset!");
static_assert(offsetof(FContextSpec, Sensor) == 0x0000A8, "Member 'FContextSpec::Sensor' has a wrong offset!");
static_assert(offsetof(FContextSpec, Camera) == 0x0000B0, "Member 'FContextSpec::Camera' has a wrong offset!");

// ScriptStruct SCT.FCTServerTelemetryEndMatchModel
// 0x0030 (0x0030 - 0x0000)
struct FFCTServerTelemetryEndMatchModel final
{
public:
	class FString                                 WinningFaction;                                    // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionDuration;                                   // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndReason;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTServerTelemetryEndMatchModel) == 0x000008, "Wrong alignment on FFCTServerTelemetryEndMatchModel");
static_assert(sizeof(FFCTServerTelemetryEndMatchModel) == 0x000030, "Wrong size on FFCTServerTelemetryEndMatchModel");
static_assert(offsetof(FFCTServerTelemetryEndMatchModel, WinningFaction) == 0x000000, "Member 'FFCTServerTelemetryEndMatchModel::WinningFaction' has a wrong offset!");
static_assert(offsetof(FFCTServerTelemetryEndMatchModel, SessionDuration) == 0x000010, "Member 'FFCTServerTelemetryEndMatchModel::SessionDuration' has a wrong offset!");
static_assert(offsetof(FFCTServerTelemetryEndMatchModel, EndReason) == 0x000020, "Member 'FFCTServerTelemetryEndMatchModel::EndReason' has a wrong offset!");

// ScriptStruct SCT.FCTUserBan
// 0x0088 (0x0088 - 0x0000)
struct FFCTUserBan final
{
public:
	class FString                                 Ban;                                               // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BanId;                                             // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Comment;                                           // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CreatedAt;                                         // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EndDate;                                           // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisabledDate;                                      // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserId;                                            // 0x0078(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTUserBan) == 0x000008, "Wrong alignment on FFCTUserBan");
static_assert(sizeof(FFCTUserBan) == 0x000088, "Wrong size on FFCTUserBan");
static_assert(offsetof(FFCTUserBan, Ban) == 0x000000, "Member 'FFCTUserBan::Ban' has a wrong offset!");
static_assert(offsetof(FFCTUserBan, BanId) == 0x000010, "Member 'FFCTUserBan::BanId' has a wrong offset!");
static_assert(offsetof(FFCTUserBan, Comment) == 0x000020, "Member 'FFCTUserBan::Comment' has a wrong offset!");
static_assert(offsetof(FFCTUserBan, CreatedAt) == 0x000030, "Member 'FFCTUserBan::CreatedAt' has a wrong offset!");
static_assert(offsetof(FFCTUserBan, Enabled) == 0x000040, "Member 'FFCTUserBan::Enabled' has a wrong offset!");
static_assert(offsetof(FFCTUserBan, EndDate) == 0x000048, "Member 'FFCTUserBan::EndDate' has a wrong offset!");
static_assert(offsetof(FFCTUserBan, DisabledDate) == 0x000058, "Member 'FFCTUserBan::DisabledDate' has a wrong offset!");
static_assert(offsetof(FFCTUserBan, Reason) == 0x000068, "Member 'FFCTUserBan::Reason' has a wrong offset!");
static_assert(offsetof(FFCTUserBan, UserId) == 0x000078, "Member 'FFCTUserBan::UserId' has a wrong offset!");

// ScriptStruct SCT.CustomGameSettings
// 0x0034 (0x0034 - 0x0000)
struct FCustomGameSettings final
{
public:
	int32                                         MinPersonoids;                                     // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPersonoids;                                     // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IntermediateLevels;                                // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AmountOfSyringes;                                  // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OxygenMultiplier;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OxygenCanisterMultiplier;                          // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OxygenOutletSabotageMultiplier;                    // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OxygenGeneratorRepairMultiplier;                   // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OxygenGeneratorSabotageMultiplier;                 // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OxygenGeneratorFailedMultiplier;                   // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenPersonoids;                                 // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCatastropheEventEnabled;                          // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x2];                                       // 0x002A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PassengerLogSpawnMultiplier;                       // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDefault;                                        // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomGameSettings) == 0x000004, "Wrong alignment on FCustomGameSettings");
static_assert(sizeof(FCustomGameSettings) == 0x000034, "Wrong size on FCustomGameSettings");
static_assert(offsetof(FCustomGameSettings, MinPersonoids) == 0x000000, "Member 'FCustomGameSettings::MinPersonoids' has a wrong offset!");
static_assert(offsetof(FCustomGameSettings, MaxPersonoids) == 0x000004, "Member 'FCustomGameSettings::MaxPersonoids' has a wrong offset!");
static_assert(offsetof(FCustomGameSettings, IntermediateLevels) == 0x000008, "Member 'FCustomGameSettings::IntermediateLevels' has a wrong offset!");
static_assert(offsetof(FCustomGameSettings, AmountOfSyringes) == 0x00000C, "Member 'FCustomGameSettings::AmountOfSyringes' has a wrong offset!");
static_assert(offsetof(FCustomGameSettings, OxygenMultiplier) == 0x000010, "Member 'FCustomGameSettings::OxygenMultiplier' has a wrong offset!");
static_assert(offsetof(FCustomGameSettings, OxygenCanisterMultiplier) == 0x000014, "Member 'FCustomGameSettings::OxygenCanisterMultiplier' has a wrong offset!");
static_assert(offsetof(FCustomGameSettings, OxygenOutletSabotageMultiplier) == 0x000018, "Member 'FCustomGameSettings::OxygenOutletSabotageMultiplier' has a wrong offset!");
static_assert(offsetof(FCustomGameSettings, OxygenGeneratorRepairMultiplier) == 0x00001C, "Member 'FCustomGameSettings::OxygenGeneratorRepairMultiplier' has a wrong offset!");
static_assert(offsetof(FCustomGameSettings, OxygenGeneratorSabotageMultiplier) == 0x000020, "Member 'FCustomGameSettings::OxygenGeneratorSabotageMultiplier' has a wrong offset!");
static_assert(offsetof(FCustomGameSettings, OxygenGeneratorFailedMultiplier) == 0x000024, "Member 'FCustomGameSettings::OxygenGeneratorFailedMultiplier' has a wrong offset!");
static_assert(offsetof(FCustomGameSettings, bHiddenPersonoids) == 0x000028, "Member 'FCustomGameSettings::bHiddenPersonoids' has a wrong offset!");
static_assert(offsetof(FCustomGameSettings, bCatastropheEventEnabled) == 0x000029, "Member 'FCustomGameSettings::bCatastropheEventEnabled' has a wrong offset!");
static_assert(offsetof(FCustomGameSettings, PassengerLogSpawnMultiplier) == 0x00002C, "Member 'FCustomGameSettings::PassengerLogSpawnMultiplier' has a wrong offset!");
static_assert(offsetof(FCustomGameSettings, bIsDefault) == 0x000030, "Member 'FCustomGameSettings::bIsDefault' has a wrong offset!");

// ScriptStruct SCT.BoundContextSpec
// 0x0040 (0x0040 - 0x0000)
struct FBoundContextSpec final
{
public:
	TWeakObjectPtr<class UContextStaticMeshComponent> Target;                                            // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputActionKeyMapping                 KeyMapping;                                        // 0x0008(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bIsResident;                                       // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPersonoid;                                      // 0x0031(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPower*                                 Power;                                             // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBoundContextSpec) == 0x000008, "Wrong alignment on FBoundContextSpec");
static_assert(sizeof(FBoundContextSpec) == 0x000040, "Wrong size on FBoundContextSpec");
static_assert(offsetof(FBoundContextSpec, Target) == 0x000000, "Member 'FBoundContextSpec::Target' has a wrong offset!");
static_assert(offsetof(FBoundContextSpec, KeyMapping) == 0x000008, "Member 'FBoundContextSpec::KeyMapping' has a wrong offset!");
static_assert(offsetof(FBoundContextSpec, bIsResident) == 0x000030, "Member 'FBoundContextSpec::bIsResident' has a wrong offset!");
static_assert(offsetof(FBoundContextSpec, bIsPersonoid) == 0x000031, "Member 'FBoundContextSpec::bIsPersonoid' has a wrong offset!");
static_assert(offsetof(FBoundContextSpec, Power) == 0x000038, "Member 'FBoundContextSpec::Power' has a wrong offset!");

// ScriptStruct SCT.CustomizationQualityItemTableRow
// 0x0008 (0x0010 - 0x0008)
struct FCustomizationQualityItemTableRow : public FTableRowBase
{
public:
	EItemQuality                                  Quality;                                           // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomizationQualityItemTableRow) == 0x000008, "Wrong alignment on FCustomizationQualityItemTableRow");
static_assert(sizeof(FCustomizationQualityItemTableRow) == 0x000010, "Wrong size on FCustomizationQualityItemTableRow");
static_assert(offsetof(FCustomizationQualityItemTableRow, Quality) == 0x000008, "Member 'FCustomizationQualityItemTableRow::Quality' has a wrong offset!");

// ScriptStruct SCT.VruumbaCustomizationTableRow
// 0x0058 (0x0068 - 0x0010)
struct FVruumbaCustomizationTableRow : public FCustomizationQualityItemTableRow
{
public:
	int32                                         UnlockLevel;                                       // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TokenCost;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             IconThumbnail;                                     // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AchievementCode;                                   // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EntitlementCode;                                   // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Sku;                                               // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0050(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVruumbaCustomizationTableRow) == 0x000008, "Wrong alignment on FVruumbaCustomizationTableRow");
static_assert(sizeof(FVruumbaCustomizationTableRow) == 0x000068, "Wrong size on FVruumbaCustomizationTableRow");
static_assert(offsetof(FVruumbaCustomizationTableRow, UnlockLevel) == 0x000010, "Member 'FVruumbaCustomizationTableRow::UnlockLevel' has a wrong offset!");
static_assert(offsetof(FVruumbaCustomizationTableRow, TokenCost) == 0x000014, "Member 'FVruumbaCustomizationTableRow::TokenCost' has a wrong offset!");
static_assert(offsetof(FVruumbaCustomizationTableRow, IconThumbnail) == 0x000018, "Member 'FVruumbaCustomizationTableRow::IconThumbnail' has a wrong offset!");
static_assert(offsetof(FVruumbaCustomizationTableRow, AchievementCode) == 0x000020, "Member 'FVruumbaCustomizationTableRow::AchievementCode' has a wrong offset!");
static_assert(offsetof(FVruumbaCustomizationTableRow, EntitlementCode) == 0x000030, "Member 'FVruumbaCustomizationTableRow::EntitlementCode' has a wrong offset!");
static_assert(offsetof(FVruumbaCustomizationTableRow, Sku) == 0x000040, "Member 'FVruumbaCustomizationTableRow::Sku' has a wrong offset!");
static_assert(offsetof(FVruumbaCustomizationTableRow, Description) == 0x000050, "Member 'FVruumbaCustomizationTableRow::Description' has a wrong offset!");

// ScriptStruct SCT.VruumbaParticlesCustomizationItemTableRow
// 0x0008 (0x0070 - 0x0068)
struct FVruumbaParticlesCustomizationItemTableRow final : public FVruumbaCustomizationTableRow
{
public:
	class UParticleSystem*                        ParticleSystem;                                    // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVruumbaParticlesCustomizationItemTableRow) == 0x000008, "Wrong alignment on FVruumbaParticlesCustomizationItemTableRow");
static_assert(sizeof(FVruumbaParticlesCustomizationItemTableRow) == 0x000070, "Wrong size on FVruumbaParticlesCustomizationItemTableRow");
static_assert(offsetof(FVruumbaParticlesCustomizationItemTableRow, ParticleSystem) == 0x000068, "Member 'FVruumbaParticlesCustomizationItemTableRow::ParticleSystem' has a wrong offset!");

// ScriptStruct SCT.FCTUserBansPayload
// 0x0010 (0x0010 - 0x0000)
struct FFCTUserBansPayload final
{
public:
	TArray<struct FFCTUserBan>                    Data;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTUserBansPayload) == 0x000008, "Wrong alignment on FFCTUserBansPayload");
static_assert(sizeof(FFCTUserBansPayload) == 0x000010, "Wrong size on FFCTUserBansPayload");
static_assert(offsetof(FFCTUserBansPayload, Data) == 0x000000, "Member 'FFCTUserBansPayload::Data' has a wrong offset!");

// ScriptStruct SCT.Destiny
// 0x0010 (0x0010 - 0x0000)
struct FDestiny final
{
public:
	EFate                                         Fate;                                              // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OptionalImpulse;                                   // 0x0004(0x000C)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDestiny) == 0x000004, "Wrong alignment on FDestiny");
static_assert(sizeof(FDestiny) == 0x000010, "Wrong size on FDestiny");
static_assert(offsetof(FDestiny, Fate) == 0x000000, "Member 'FDestiny::Fate' has a wrong offset!");
static_assert(offsetof(FDestiny, OptionalImpulse) == 0x000004, "Member 'FDestiny::OptionalImpulse' has a wrong offset!");

// ScriptStruct SCT.ExternalLocalizationData
// 0x00C0 (0x00C0 - 0x0000)
struct FExternalLocalizationData final
{
public:
	class FString                                 En;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Pt;                                                // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Zh;                                                // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Yi;                                                // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Fr;                                                // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 De;                                                // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Ja;                                                // 0x0060(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Ko;                                                // 0x0070(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Ru;                                                // 0x0080(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Es;                                                // 0x0090(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Th;                                                // 0x00A0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Ar;                                                // 0x00B0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FExternalLocalizationData) == 0x000008, "Wrong alignment on FExternalLocalizationData");
static_assert(sizeof(FExternalLocalizationData) == 0x0000C0, "Wrong size on FExternalLocalizationData");
static_assert(offsetof(FExternalLocalizationData, En) == 0x000000, "Member 'FExternalLocalizationData::En' has a wrong offset!");
static_assert(offsetof(FExternalLocalizationData, Pt) == 0x000010, "Member 'FExternalLocalizationData::Pt' has a wrong offset!");
static_assert(offsetof(FExternalLocalizationData, Zh) == 0x000020, "Member 'FExternalLocalizationData::Zh' has a wrong offset!");
static_assert(offsetof(FExternalLocalizationData, Yi) == 0x000030, "Member 'FExternalLocalizationData::Yi' has a wrong offset!");
static_assert(offsetof(FExternalLocalizationData, Fr) == 0x000040, "Member 'FExternalLocalizationData::Fr' has a wrong offset!");
static_assert(offsetof(FExternalLocalizationData, De) == 0x000050, "Member 'FExternalLocalizationData::De' has a wrong offset!");
static_assert(offsetof(FExternalLocalizationData, Ja) == 0x000060, "Member 'FExternalLocalizationData::Ja' has a wrong offset!");
static_assert(offsetof(FExternalLocalizationData, Ko) == 0x000070, "Member 'FExternalLocalizationData::Ko' has a wrong offset!");
static_assert(offsetof(FExternalLocalizationData, Ru) == 0x000080, "Member 'FExternalLocalizationData::Ru' has a wrong offset!");
static_assert(offsetof(FExternalLocalizationData, Es) == 0x000090, "Member 'FExternalLocalizationData::Es' has a wrong offset!");
static_assert(offsetof(FExternalLocalizationData, Th) == 0x0000A0, "Member 'FExternalLocalizationData::Th' has a wrong offset!");
static_assert(offsetof(FExternalLocalizationData, Ar) == 0x0000B0, "Member 'FExternalLocalizationData::Ar' has a wrong offset!");

// ScriptStruct SCT.DLCPackData
// 0x0170 (0x0170 - 0x0000)
struct FDLCPackData final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SteamID;                                           // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Ps4Id;                                             // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Ps5Id;                                             // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EpicId;                                            // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 XboxId;                                            // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoadOrder;                                         // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Discount;                                          // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ThumbnailUrlDoubleSpan;                            // 0x0078(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ThumbnailUrlSingleSpan;                            // 0x0088(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExternalLocalizationData              Lang;                                              // 0x00A0(0x00C0)(NativeAccessSpecifierPublic)
	bool                                          bIsNew;                                            // 0x0160(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoubleSpan;                                       // 0x0161(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_162[0x6];                                      // 0x0162(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2DDynamic*                      ThumbnailTexture;                                  // 0x0168(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLCPackData) == 0x000008, "Wrong alignment on FDLCPackData");
static_assert(sizeof(FDLCPackData) == 0x000170, "Wrong size on FDLCPackData");
static_assert(offsetof(FDLCPackData, Name) == 0x000000, "Member 'FDLCPackData::Name' has a wrong offset!");
static_assert(offsetof(FDLCPackData, Description) == 0x000010, "Member 'FDLCPackData::Description' has a wrong offset!");
static_assert(offsetof(FDLCPackData, SteamID) == 0x000020, "Member 'FDLCPackData::SteamID' has a wrong offset!");
static_assert(offsetof(FDLCPackData, Ps4Id) == 0x000030, "Member 'FDLCPackData::Ps4Id' has a wrong offset!");
static_assert(offsetof(FDLCPackData, Ps5Id) == 0x000040, "Member 'FDLCPackData::Ps5Id' has a wrong offset!");
static_assert(offsetof(FDLCPackData, EpicId) == 0x000050, "Member 'FDLCPackData::EpicId' has a wrong offset!");
static_assert(offsetof(FDLCPackData, XboxId) == 0x000060, "Member 'FDLCPackData::XboxId' has a wrong offset!");
static_assert(offsetof(FDLCPackData, LoadOrder) == 0x000070, "Member 'FDLCPackData::LoadOrder' has a wrong offset!");
static_assert(offsetof(FDLCPackData, Discount) == 0x000074, "Member 'FDLCPackData::Discount' has a wrong offset!");
static_assert(offsetof(FDLCPackData, ThumbnailUrlDoubleSpan) == 0x000078, "Member 'FDLCPackData::ThumbnailUrlDoubleSpan' has a wrong offset!");
static_assert(offsetof(FDLCPackData, ThumbnailUrlSingleSpan) == 0x000088, "Member 'FDLCPackData::ThumbnailUrlSingleSpan' has a wrong offset!");
static_assert(offsetof(FDLCPackData, Enabled) == 0x000098, "Member 'FDLCPackData::Enabled' has a wrong offset!");
static_assert(offsetof(FDLCPackData, Lang) == 0x0000A0, "Member 'FDLCPackData::Lang' has a wrong offset!");
static_assert(offsetof(FDLCPackData, bIsNew) == 0x000160, "Member 'FDLCPackData::bIsNew' has a wrong offset!");
static_assert(offsetof(FDLCPackData, bDoubleSpan) == 0x000161, "Member 'FDLCPackData::bDoubleSpan' has a wrong offset!");
static_assert(offsetof(FDLCPackData, ThumbnailTexture) == 0x000168, "Member 'FDLCPackData::ThumbnailTexture' has a wrong offset!");

// ScriptStruct SCT.PlayerCustomizationFeature
// 0x0000 (0x0008 - 0x0008)
struct FPlayerCustomizationFeature : public FTableRowBase
{
};
static_assert(alignof(FPlayerCustomizationFeature) == 0x000008, "Wrong alignment on FPlayerCustomizationFeature");
static_assert(sizeof(FPlayerCustomizationFeature) == 0x000008, "Wrong size on FPlayerCustomizationFeature");

// ScriptStruct SCT.InteractionPayload
// 0x0030 (0x0030 - 0x0000)
struct FInteractionPayload final
{
public:
	class AActor*                                 ActivatingActor;                                   // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                             Inventory;                                         // 0x0008(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPower*                                 Power;                                             // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAbilitySystemComponentSCT*             AbilitySystemComponent;                            // 0x0018(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ASCTPlayerController*                   PlayerController;                                  // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInteractionPayload) == 0x000008, "Wrong alignment on FInteractionPayload");
static_assert(sizeof(FInteractionPayload) == 0x000030, "Wrong size on FInteractionPayload");
static_assert(offsetof(FInteractionPayload, ActivatingActor) == 0x000000, "Member 'FInteractionPayload::ActivatingActor' has a wrong offset!");
static_assert(offsetof(FInteractionPayload, Inventory) == 0x000008, "Member 'FInteractionPayload::Inventory' has a wrong offset!");
static_assert(offsetof(FInteractionPayload, Power) == 0x000010, "Member 'FInteractionPayload::Power' has a wrong offset!");
static_assert(offsetof(FInteractionPayload, AbilitySystemComponent) == 0x000018, "Member 'FInteractionPayload::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(FInteractionPayload, PlayerController) == 0x000020, "Member 'FInteractionPayload::PlayerController' has a wrong offset!");
static_assert(offsetof(FInteractionPayload, PlayerId) == 0x000028, "Member 'FInteractionPayload::PlayerId' has a wrong offset!");

// ScriptStruct SCT.CloudCustomizationSetting
// 0x000C (0x000C - 0x0000)
struct FCloudCustomizationSetting final
{
public:
	int32                                         MeshIndex;                                         // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrimaryMatIndex;                                   // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondaryMatIndex;                                 // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloudCustomizationSetting) == 0x000004, "Wrong alignment on FCloudCustomizationSetting");
static_assert(sizeof(FCloudCustomizationSetting) == 0x00000C, "Wrong size on FCloudCustomizationSetting");
static_assert(offsetof(FCloudCustomizationSetting, MeshIndex) == 0x000000, "Member 'FCloudCustomizationSetting::MeshIndex' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationSetting, PrimaryMatIndex) == 0x000004, "Member 'FCloudCustomizationSetting::PrimaryMatIndex' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationSetting, SecondaryMatIndex) == 0x000008, "Member 'FCloudCustomizationSetting::SecondaryMatIndex' has a wrong offset!");

// ScriptStruct SCT.EndOfLevelTelemetryPayload
// 0x0020 (0x0020 - 0x0000)
struct FEndOfLevelTelemetryPayload final
{
public:
	class FString                                 Map;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayersKilled;                                     // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MatchEnded;                                        // 0x0014(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalLevelTime;                                    // 0x0018(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEndOfLevelTelemetryPayload) == 0x000008, "Wrong alignment on FEndOfLevelTelemetryPayload");
static_assert(sizeof(FEndOfLevelTelemetryPayload) == 0x000020, "Wrong size on FEndOfLevelTelemetryPayload");
static_assert(offsetof(FEndOfLevelTelemetryPayload, Map) == 0x000000, "Member 'FEndOfLevelTelemetryPayload::Map' has a wrong offset!");
static_assert(offsetof(FEndOfLevelTelemetryPayload, PlayersKilled) == 0x000010, "Member 'FEndOfLevelTelemetryPayload::PlayersKilled' has a wrong offset!");
static_assert(offsetof(FEndOfLevelTelemetryPayload, MatchEnded) == 0x000014, "Member 'FEndOfLevelTelemetryPayload::MatchEnded' has a wrong offset!");
static_assert(offsetof(FEndOfLevelTelemetryPayload, TotalLevelTime) == 0x000018, "Member 'FEndOfLevelTelemetryPayload::TotalLevelTime' has a wrong offset!");

// ScriptStruct SCT.Score
// 0x0020 (0x0020 - 0x0000)
struct FScore final
{
public:
	int32                                         EndScenario;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Progression;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Deception;                                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Sabotage;                                          // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Deduction;                                         // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Collaboration;                                     // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalPersonoid;                                    // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalResident;                                     // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScore) == 0x000004, "Wrong alignment on FScore");
static_assert(sizeof(FScore) == 0x000020, "Wrong size on FScore");
static_assert(offsetof(FScore, EndScenario) == 0x000000, "Member 'FScore::EndScenario' has a wrong offset!");
static_assert(offsetof(FScore, Progression) == 0x000004, "Member 'FScore::Progression' has a wrong offset!");
static_assert(offsetof(FScore, Deception) == 0x000008, "Member 'FScore::Deception' has a wrong offset!");
static_assert(offsetof(FScore, Sabotage) == 0x00000C, "Member 'FScore::Sabotage' has a wrong offset!");
static_assert(offsetof(FScore, Deduction) == 0x000010, "Member 'FScore::Deduction' has a wrong offset!");
static_assert(offsetof(FScore, Collaboration) == 0x000014, "Member 'FScore::Collaboration' has a wrong offset!");
static_assert(offsetof(FScore, TotalPersonoid) == 0x000018, "Member 'FScore::TotalPersonoid' has a wrong offset!");
static_assert(offsetof(FScore, TotalResident) == 0x00001C, "Member 'FScore::TotalResident' has a wrong offset!");

// ScriptStruct SCT.ScoreEntry
// 0x000C (0x000C - 0x0000)
struct FScoreEntry final
{
public:
	class FName                                   RowName;                                           // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FScoreEntry) == 0x000004, "Wrong alignment on FScoreEntry");
static_assert(sizeof(FScoreEntry) == 0x00000C, "Wrong size on FScoreEntry");
static_assert(offsetof(FScoreEntry, RowName) == 0x000000, "Member 'FScoreEntry::RowName' has a wrong offset!");
static_assert(offsetof(FScoreEntry, Amount) == 0x000008, "Member 'FScoreEntry::Amount' has a wrong offset!");

// ScriptStruct SCT.PlayerEndData
// 0x00A8 (0x00A8 - 0x0000)
struct FPlayerEndData final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerFaction                                Faction;                                           // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           IdentificationColor;                               // 0x001C(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFate                                         Fate;                                              // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScore                                 Score;                                             // 0x0030(0x0020)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 SteamID;                                           // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PSNID;                                             // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccelByteId;                                       // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunningOnPS5;                                     // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 XboxLiveID;                                        // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FScoreEntry>                    ScoreEntries;                                      // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerEndData) == 0x000008, "Wrong alignment on FPlayerEndData");
static_assert(sizeof(FPlayerEndData) == 0x0000A8, "Wrong size on FPlayerEndData");
static_assert(offsetof(FPlayerEndData, PlayerId) == 0x000000, "Member 'FPlayerEndData::PlayerId' has a wrong offset!");
static_assert(offsetof(FPlayerEndData, Name) == 0x000008, "Member 'FPlayerEndData::Name' has a wrong offset!");
static_assert(offsetof(FPlayerEndData, Faction) == 0x000018, "Member 'FPlayerEndData::Faction' has a wrong offset!");
static_assert(offsetof(FPlayerEndData, IdentificationColor) == 0x00001C, "Member 'FPlayerEndData::IdentificationColor' has a wrong offset!");
static_assert(offsetof(FPlayerEndData, Fate) == 0x00002C, "Member 'FPlayerEndData::Fate' has a wrong offset!");
static_assert(offsetof(FPlayerEndData, Score) == 0x000030, "Member 'FPlayerEndData::Score' has a wrong offset!");
static_assert(offsetof(FPlayerEndData, SteamID) == 0x000050, "Member 'FPlayerEndData::SteamID' has a wrong offset!");
static_assert(offsetof(FPlayerEndData, PSNID) == 0x000060, "Member 'FPlayerEndData::PSNID' has a wrong offset!");
static_assert(offsetof(FPlayerEndData, AccelByteId) == 0x000070, "Member 'FPlayerEndData::AccelByteId' has a wrong offset!");
static_assert(offsetof(FPlayerEndData, bRunningOnPS5) == 0x000080, "Member 'FPlayerEndData::bRunningOnPS5' has a wrong offset!");
static_assert(offsetof(FPlayerEndData, XboxLiveID) == 0x000088, "Member 'FPlayerEndData::XboxLiveID' has a wrong offset!");
static_assert(offsetof(FPlayerEndData, ScoreEntries) == 0x000098, "Member 'FPlayerEndData::ScoreEntries' has a wrong offset!");

// ScriptStruct SCT.MatchEndData
// 0x0018 (0x0018 - 0x0000)
struct FMatchEndData final
{
public:
	TArray<struct FPlayerEndData>                 PlayerData;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EEndConditions                                EndCondition;                                      // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchEndData) == 0x000008, "Wrong alignment on FMatchEndData");
static_assert(sizeof(FMatchEndData) == 0x000018, "Wrong size on FMatchEndData");
static_assert(offsetof(FMatchEndData, PlayerData) == 0x000000, "Member 'FMatchEndData::PlayerData' has a wrong offset!");
static_assert(offsetof(FMatchEndData, EndCondition) == 0x000010, "Member 'FMatchEndData::EndCondition' has a wrong offset!");

// ScriptStruct SCT.ContextSpecUpdateSettings
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x04) FContextSpecUpdateSettings final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FContextSpecUpdateSettings) == 0x000004, "Wrong alignment on FContextSpecUpdateSettings");
static_assert(sizeof(FContextSpecUpdateSettings) == 0x000008, "Wrong size on FContextSpecUpdateSettings");

// ScriptStruct SCT.FCTFriendProfile
// 0x0060 (0x0060 - 0x0000)
struct FFCTFriendProfile final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Username;                                          // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserId;                                            // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformId;                                        // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformName;                                      // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAvailability                                 OnlineStatus;                                      // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERelationshipStatusCode                       Relationship;                                      // 0x0051(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              LastPlayedWith;                                    // 0x0058(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTFriendProfile) == 0x000008, "Wrong alignment on FFCTFriendProfile");
static_assert(sizeof(FFCTFriendProfile) == 0x000060, "Wrong size on FFCTFriendProfile");
static_assert(offsetof(FFCTFriendProfile, DisplayName) == 0x000000, "Member 'FFCTFriendProfile::DisplayName' has a wrong offset!");
static_assert(offsetof(FFCTFriendProfile, Username) == 0x000010, "Member 'FFCTFriendProfile::Username' has a wrong offset!");
static_assert(offsetof(FFCTFriendProfile, UserId) == 0x000020, "Member 'FFCTFriendProfile::UserId' has a wrong offset!");
static_assert(offsetof(FFCTFriendProfile, PlatformId) == 0x000030, "Member 'FFCTFriendProfile::PlatformId' has a wrong offset!");
static_assert(offsetof(FFCTFriendProfile, PlatformName) == 0x000040, "Member 'FFCTFriendProfile::PlatformName' has a wrong offset!");
static_assert(offsetof(FFCTFriendProfile, OnlineStatus) == 0x000050, "Member 'FFCTFriendProfile::OnlineStatus' has a wrong offset!");
static_assert(offsetof(FFCTFriendProfile, Relationship) == 0x000051, "Member 'FFCTFriendProfile::Relationship' has a wrong offset!");
static_assert(offsetof(FFCTFriendProfile, LastPlayedWith) == 0x000058, "Member 'FFCTFriendProfile::LastPlayedWith' has a wrong offset!");

// ScriptStruct SCT.FCTFriendsList
// 0x0028 (0x0028 - 0x0000)
struct FFCTFriendsList final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FFCTFriendProfile>              Profiles;                                          // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         OnlineCount;                                       // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OfflineCount;                                      // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTFriendsList) == 0x000008, "Wrong alignment on FFCTFriendsList");
static_assert(sizeof(FFCTFriendsList) == 0x000028, "Wrong size on FFCTFriendsList");
static_assert(offsetof(FFCTFriendsList, UserId) == 0x000000, "Member 'FFCTFriendsList::UserId' has a wrong offset!");
static_assert(offsetof(FFCTFriendsList, Profiles) == 0x000010, "Member 'FFCTFriendsList::Profiles' has a wrong offset!");
static_assert(offsetof(FFCTFriendsList, OnlineCount) == 0x000020, "Member 'FFCTFriendsList::OnlineCount' has a wrong offset!");
static_assert(offsetof(FFCTFriendsList, OfflineCount) == 0x000024, "Member 'FFCTFriendsList::OfflineCount' has a wrong offset!");

// ScriptStruct SCT.PS5MatchCommandData
// 0x0030 (0x0030 - 0x0000)
struct FPS5MatchCommandData final
{
public:
	class FString                                 MatchID;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchEndData                          MatchEndData;                                      // 0x0010(0x0018)(NativeAccessSpecifierPublic)
	bool                                          bHasRateLimitError;                                // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPS5MatchCommandData) == 0x000008, "Wrong alignment on FPS5MatchCommandData");
static_assert(sizeof(FPS5MatchCommandData) == 0x000030, "Wrong size on FPS5MatchCommandData");
static_assert(offsetof(FPS5MatchCommandData, MatchID) == 0x000000, "Member 'FPS5MatchCommandData::MatchID' has a wrong offset!");
static_assert(offsetof(FPS5MatchCommandData, MatchEndData) == 0x000010, "Member 'FPS5MatchCommandData::MatchEndData' has a wrong offset!");
static_assert(offsetof(FPS5MatchCommandData, bHasRateLimitError) == 0x000028, "Member 'FPS5MatchCommandData::bHasRateLimitError' has a wrong offset!");

// ScriptStruct SCT.PlayerCustomizationItem
// 0x00A0 (0x00A8 - 0x0008)
struct FPlayerCustomizationItem final : public FTableRowBase
{
public:
	class UStreamableRenderAsset*                 AppearanceMesh;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              PrimaryStyleMaterials;                             // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              SecondaryStyleMaterials;                           // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         UnlockLevel;                                       // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TokenCost;                                         // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 PatternCost;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             IconThumbnail;                                     // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             CharacterMask;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AchievementCode;                                   // 0x0058(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EntitlementCode;                                   // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DLCPackId;                                         // 0x0078(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UnlockRequirementText;                             // 0x0080(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoMaskLegs;                                        // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleWithoutOwning;                              // 0x00A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A2[0x6];                                       // 0x00A2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerCustomizationItem) == 0x000008, "Wrong alignment on FPlayerCustomizationItem");
static_assert(sizeof(FPlayerCustomizationItem) == 0x0000A8, "Wrong size on FPlayerCustomizationItem");
static_assert(offsetof(FPlayerCustomizationItem, AppearanceMesh) == 0x000008, "Member 'FPlayerCustomizationItem::AppearanceMesh' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, PrimaryStyleMaterials) == 0x000010, "Member 'FPlayerCustomizationItem::PrimaryStyleMaterials' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, SecondaryStyleMaterials) == 0x000020, "Member 'FPlayerCustomizationItem::SecondaryStyleMaterials' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, UnlockLevel) == 0x000030, "Member 'FPlayerCustomizationItem::UnlockLevel' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, TokenCost) == 0x000034, "Member 'FPlayerCustomizationItem::TokenCost' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, PatternCost) == 0x000038, "Member 'FPlayerCustomizationItem::PatternCost' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, IconThumbnail) == 0x000048, "Member 'FPlayerCustomizationItem::IconThumbnail' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, CharacterMask) == 0x000050, "Member 'FPlayerCustomizationItem::CharacterMask' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, AchievementCode) == 0x000058, "Member 'FPlayerCustomizationItem::AchievementCode' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, EntitlementCode) == 0x000068, "Member 'FPlayerCustomizationItem::EntitlementCode' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, DLCPackId) == 0x000078, "Member 'FPlayerCustomizationItem::DLCPackId' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, UnlockRequirementText) == 0x000080, "Member 'FPlayerCustomizationItem::UnlockRequirementText' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, Description) == 0x000090, "Member 'FPlayerCustomizationItem::Description' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, DoMaskLegs) == 0x0000A0, "Member 'FPlayerCustomizationItem::DoMaskLegs' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItem, VisibleWithoutOwning) == 0x0000A1, "Member 'FPlayerCustomizationItem::VisibleWithoutOwning' has a wrong offset!");

// ScriptStruct SCT.PlayerEntitlementCustomizationItem
// 0x00C8 (0x00C8 - 0x0000)
struct FPlayerEntitlementCustomizationItem final
{
public:
	class FString                                 ItemId;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Sku;                                               // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerCustomizationItem               Entitlement;                                       // 0x0020(0x00A8)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerEntitlementCustomizationItem) == 0x000008, "Wrong alignment on FPlayerEntitlementCustomizationItem");
static_assert(sizeof(FPlayerEntitlementCustomizationItem) == 0x0000C8, "Wrong size on FPlayerEntitlementCustomizationItem");
static_assert(offsetof(FPlayerEntitlementCustomizationItem, ItemId) == 0x000000, "Member 'FPlayerEntitlementCustomizationItem::ItemId' has a wrong offset!");
static_assert(offsetof(FPlayerEntitlementCustomizationItem, Sku) == 0x000010, "Member 'FPlayerEntitlementCustomizationItem::Sku' has a wrong offset!");
static_assert(offsetof(FPlayerEntitlementCustomizationItem, Entitlement) == 0x000020, "Member 'FPlayerEntitlementCustomizationItem::Entitlement' has a wrong offset!");

// ScriptStruct SCT.FCTAchievementList
// 0x0028 (0x0028 - 0x0000)
struct FFCTAchievementList final
{
public:
	TArray<class UFCTAchievement*>                Achievements;                                      // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         UnlockedCount;                                     // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalCount;                                        // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UFCTAchievement*>                RecentlyUnlockedAchievements;                      // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTAchievementList) == 0x000008, "Wrong alignment on FFCTAchievementList");
static_assert(sizeof(FFCTAchievementList) == 0x000028, "Wrong size on FFCTAchievementList");
static_assert(offsetof(FFCTAchievementList, Achievements) == 0x000000, "Member 'FFCTAchievementList::Achievements' has a wrong offset!");
static_assert(offsetof(FFCTAchievementList, UnlockedCount) == 0x000010, "Member 'FFCTAchievementList::UnlockedCount' has a wrong offset!");
static_assert(offsetof(FFCTAchievementList, TotalCount) == 0x000014, "Member 'FFCTAchievementList::TotalCount' has a wrong offset!");
static_assert(offsetof(FFCTAchievementList, RecentlyUnlockedAchievements) == 0x000018, "Member 'FFCTAchievementList::RecentlyUnlockedAchievements' has a wrong offset!");

// ScriptStruct SCT.VruumbaSkeletalMeshCustomizationItemTableRow
// 0x0018 (0x0080 - 0x0068)
struct FVruumbaSkeletalMeshCustomizationItemTableRow : public FVruumbaCustomizationTableRow
{
public:
	class USkeletalMesh*                          Mesh;                                              // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              Materials;                                         // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVruumbaSkeletalMeshCustomizationItemTableRow) == 0x000008, "Wrong alignment on FVruumbaSkeletalMeshCustomizationItemTableRow");
static_assert(sizeof(FVruumbaSkeletalMeshCustomizationItemTableRow) == 0x000080, "Wrong size on FVruumbaSkeletalMeshCustomizationItemTableRow");
static_assert(offsetof(FVruumbaSkeletalMeshCustomizationItemTableRow, Mesh) == 0x000068, "Member 'FVruumbaSkeletalMeshCustomizationItemTableRow::Mesh' has a wrong offset!");
static_assert(offsetof(FVruumbaSkeletalMeshCustomizationItemTableRow, Materials) == 0x000070, "Member 'FVruumbaSkeletalMeshCustomizationItemTableRow::Materials' has a wrong offset!");

// ScriptStruct SCT.VruumbaAnimatedMeshCustomizationItemTableRow
// 0x0008 (0x0088 - 0x0080)
struct FVruumbaAnimatedMeshCustomizationItemTableRow final : public FVruumbaSkeletalMeshCustomizationItemTableRow
{
public:
	TSubclassOf<class UObject>                    AnimationClass;                                    // 0x0080(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVruumbaAnimatedMeshCustomizationItemTableRow) == 0x000008, "Wrong alignment on FVruumbaAnimatedMeshCustomizationItemTableRow");
static_assert(sizeof(FVruumbaAnimatedMeshCustomizationItemTableRow) == 0x000088, "Wrong size on FVruumbaAnimatedMeshCustomizationItemTableRow");
static_assert(offsetof(FVruumbaAnimatedMeshCustomizationItemTableRow, AnimationClass) == 0x000080, "Member 'FVruumbaAnimatedMeshCustomizationItemTableRow::AnimationClass' has a wrong offset!");

// ScriptStruct SCT.CloudTrophy
// 0x0038 (0x0040 - 0x0008)
struct FCloudTrophy final : public FTableRowBase
{
public:
	class UStaticMesh*                            TrophyMesh;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FriendlyName;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Code;                                              // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloudTrophy) == 0x000008, "Wrong alignment on FCloudTrophy");
static_assert(sizeof(FCloudTrophy) == 0x000040, "Wrong size on FCloudTrophy");
static_assert(offsetof(FCloudTrophy, TrophyMesh) == 0x000008, "Member 'FCloudTrophy::TrophyMesh' has a wrong offset!");
static_assert(offsetof(FCloudTrophy, FriendlyName) == 0x000010, "Member 'FCloudTrophy::FriendlyName' has a wrong offset!");
static_assert(offsetof(FCloudTrophy, Description) == 0x000020, "Member 'FCloudTrophy::Description' has a wrong offset!");
static_assert(offsetof(FCloudTrophy, Code) == 0x000030, "Member 'FCloudTrophy::Code' has a wrong offset!");

// ScriptStruct SCT.CloudTrophyInfo
// 0x0020 (0x0020 - 0x0000)
struct FCloudTrophyInfo final
{
public:
	TArray<struct FCloudTrophy>                   SelectedTrophies;                                  // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCloudTrophy>                   UnlockedTrophies;                                  // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloudTrophyInfo) == 0x000008, "Wrong alignment on FCloudTrophyInfo");
static_assert(sizeof(FCloudTrophyInfo) == 0x000020, "Wrong size on FCloudTrophyInfo");
static_assert(offsetof(FCloudTrophyInfo, SelectedTrophies) == 0x000000, "Member 'FCloudTrophyInfo::SelectedTrophies' has a wrong offset!");
static_assert(offsetof(FCloudTrophyInfo, UnlockedTrophies) == 0x000010, "Member 'FCloudTrophyInfo::UnlockedTrophies' has a wrong offset!");

// ScriptStruct SCT.LevelVoteData
// 0x0050 (0x0050 - 0x0000)
struct FLevelVoteData final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LevelPath;                                         // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectionWeight;                                   // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        Image;                                             // 0x0038(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelVoteData) == 0x000008, "Wrong alignment on FLevelVoteData");
static_assert(sizeof(FLevelVoteData) == 0x000050, "Wrong size on FLevelVoteData");
static_assert(offsetof(FLevelVoteData, DisplayName) == 0x000000, "Member 'FLevelVoteData::DisplayName' has a wrong offset!");
static_assert(offsetof(FLevelVoteData, LevelPath) == 0x000018, "Member 'FLevelVoteData::LevelPath' has a wrong offset!");
static_assert(offsetof(FLevelVoteData, SelectionWeight) == 0x000030, "Member 'FLevelVoteData::SelectionWeight' has a wrong offset!");
static_assert(offsetof(FLevelVoteData, Image) == 0x000038, "Member 'FLevelVoteData::Image' has a wrong offset!");

// ScriptStruct SCT.SelectedLevelData
// 0x0058 (0x0058 - 0x0000)
struct FSelectedLevelData final
{
public:
	struct FLevelVoteData                         LevelData;                                         // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         LevelIndex;                                        // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CountdownEndServerTime;                            // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSelectedLevelData) == 0x000008, "Wrong alignment on FSelectedLevelData");
static_assert(sizeof(FSelectedLevelData) == 0x000058, "Wrong size on FSelectedLevelData");
static_assert(offsetof(FSelectedLevelData, LevelData) == 0x000000, "Member 'FSelectedLevelData::LevelData' has a wrong offset!");
static_assert(offsetof(FSelectedLevelData, LevelIndex) == 0x000050, "Member 'FSelectedLevelData::LevelIndex' has a wrong offset!");
static_assert(offsetof(FSelectedLevelData, CountdownEndServerTime) == 0x000054, "Member 'FSelectedLevelData::CountdownEndServerTime' has a wrong offset!");

// ScriptStruct SCT.FCTServiceMessage
// 0x0038 (0x0038 - 0x0000)
struct FFCTServiceMessage final
{
public:
	bool                                          Enabled;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BackgroundUrl;                                     // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MessageLink;                                       // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTServiceMessage) == 0x000008, "Wrong alignment on FFCTServiceMessage");
static_assert(sizeof(FFCTServiceMessage) == 0x000038, "Wrong size on FFCTServiceMessage");
static_assert(offsetof(FFCTServiceMessage, Enabled) == 0x000000, "Member 'FFCTServiceMessage::Enabled' has a wrong offset!");
static_assert(offsetof(FFCTServiceMessage, Message) == 0x000008, "Member 'FFCTServiceMessage::Message' has a wrong offset!");
static_assert(offsetof(FFCTServiceMessage, BackgroundUrl) == 0x000018, "Member 'FFCTServiceMessage::BackgroundUrl' has a wrong offset!");
static_assert(offsetof(FFCTServiceMessage, MessageLink) == 0x000028, "Member 'FFCTServiceMessage::MessageLink' has a wrong offset!");

// ScriptStruct SCT.FCTUserLeaderboardEntry
// 0x0018 (0x0018 - 0x0000)
struct FFCTUserLeaderboardEntry final
{
public:
	class FString                                 DisplayName;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Points;                                            // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTUserLeaderboardEntry) == 0x000008, "Wrong alignment on FFCTUserLeaderboardEntry");
static_assert(sizeof(FFCTUserLeaderboardEntry) == 0x000018, "Wrong size on FFCTUserLeaderboardEntry");
static_assert(offsetof(FFCTUserLeaderboardEntry, DisplayName) == 0x000000, "Member 'FFCTUserLeaderboardEntry::DisplayName' has a wrong offset!");
static_assert(offsetof(FFCTUserLeaderboardEntry, Rank) == 0x000010, "Member 'FFCTUserLeaderboardEntry::Rank' has a wrong offset!");
static_assert(offsetof(FFCTUserLeaderboardEntry, Points) == 0x000014, "Member 'FFCTUserLeaderboardEntry::Points' has a wrong offset!");

// ScriptStruct SCT.FCTUserLeaderboardRankedList
// 0x0018 (0x0018 - 0x0000)
struct FFCTUserLeaderboardRankedList final
{
public:
	TArray<struct FFCTUserLeaderboardEntry>       List;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LeaderboardIsActive;                               // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFCTUserLeaderboardRankedList) == 0x000008, "Wrong alignment on FFCTUserLeaderboardRankedList");
static_assert(sizeof(FFCTUserLeaderboardRankedList) == 0x000018, "Wrong size on FFCTUserLeaderboardRankedList");
static_assert(offsetof(FFCTUserLeaderboardRankedList, List) == 0x000000, "Member 'FFCTUserLeaderboardRankedList::List' has a wrong offset!");
static_assert(offsetof(FFCTUserLeaderboardRankedList, Count) == 0x000010, "Member 'FFCTUserLeaderboardRankedList::Count' has a wrong offset!");
static_assert(offsetof(FFCTUserLeaderboardRankedList, LeaderboardIsActive) == 0x000014, "Member 'FFCTUserLeaderboardRankedList::LeaderboardIsActive' has a wrong offset!");

// ScriptStruct SCT.FCTUserLeaderboardsCachePayload
// 0x0058 (0x0058 - 0x0000)
struct FFCTUserLeaderboardsCachePayload final
{
public:
	class FString                                 StatDisplayName;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFCTUserLeaderboardRankedList          TopRankings;                                       // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFCTUserLeaderboardRankedList          CurrentUserRankings;                               // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFCTUserLeaderboardRankedList          FriendsRankings;                                   // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTUserLeaderboardsCachePayload) == 0x000008, "Wrong alignment on FFCTUserLeaderboardsCachePayload");
static_assert(sizeof(FFCTUserLeaderboardsCachePayload) == 0x000058, "Wrong size on FFCTUserLeaderboardsCachePayload");
static_assert(offsetof(FFCTUserLeaderboardsCachePayload, StatDisplayName) == 0x000000, "Member 'FFCTUserLeaderboardsCachePayload::StatDisplayName' has a wrong offset!");
static_assert(offsetof(FFCTUserLeaderboardsCachePayload, TopRankings) == 0x000010, "Member 'FFCTUserLeaderboardsCachePayload::TopRankings' has a wrong offset!");
static_assert(offsetof(FFCTUserLeaderboardsCachePayload, CurrentUserRankings) == 0x000028, "Member 'FFCTUserLeaderboardsCachePayload::CurrentUserRankings' has a wrong offset!");
static_assert(offsetof(FFCTUserLeaderboardsCachePayload, FriendsRankings) == 0x000040, "Member 'FFCTUserLeaderboardsCachePayload::FriendsRankings' has a wrong offset!");

// ScriptStruct SCT.FCTUserLeaderboardsCachedByStats
// 0x0050 (0x0050 - 0x0000)
struct FFCTUserLeaderboardsCachedByStats final
{
public:
	TMap<class FString, struct FFCTUserLeaderboardsCachePayload> RankingsByStatCode;                                // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTUserLeaderboardsCachedByStats) == 0x000008, "Wrong alignment on FFCTUserLeaderboardsCachedByStats");
static_assert(sizeof(FFCTUserLeaderboardsCachedByStats) == 0x000050, "Wrong size on FFCTUserLeaderboardsCachedByStats");
static_assert(offsetof(FFCTUserLeaderboardsCachedByStats, RankingsByStatCode) == 0x000000, "Member 'FFCTUserLeaderboardsCachedByStats::RankingsByStatCode' has a wrong offset!");

// ScriptStruct SCT.InputSavedAxis
// 0x0028 (0x0028 - 0x0000)
struct FInputSavedAxis final
{
public:
	struct FInputAxisKeyMapping                   KeyboardKey;                                       // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputSavedAxis) == 0x000008, "Wrong alignment on FInputSavedAxis");
static_assert(sizeof(FInputSavedAxis) == 0x000028, "Wrong size on FInputSavedAxis");
static_assert(offsetof(FInputSavedAxis, KeyboardKey) == 0x000000, "Member 'FInputSavedAxis::KeyboardKey' has a wrong offset!");

// ScriptStruct SCT.BlueprintsXboxUserPrivilegeSet
// 0x0050 (0x0050 - 0x0000)
struct FBlueprintsXboxUserPrivilegeSet final
{
public:
	TMap<class FString, bool>                     XboxLiveUserIDPrivilegeSet;                        // 0x0000(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FBlueprintsXboxUserPrivilegeSet) == 0x000008, "Wrong alignment on FBlueprintsXboxUserPrivilegeSet");
static_assert(sizeof(FBlueprintsXboxUserPrivilegeSet) == 0x000050, "Wrong size on FBlueprintsXboxUserPrivilegeSet");
static_assert(offsetof(FBlueprintsXboxUserPrivilegeSet, XboxLiveUserIDPrivilegeSet) == 0x000000, "Member 'FBlueprintsXboxUserPrivilegeSet::XboxLiveUserIDPrivilegeSet' has a wrong offset!");

// ScriptStruct SCT.BulkUserInfoPayload
// 0x0010 (0x0010 - 0x0000)
struct FBulkUserInfoPayload final
{
public:
	TArray<struct FSimpleUserData>                Users;                                             // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulkUserInfoPayload) == 0x000008, "Wrong alignment on FBulkUserInfoPayload");
static_assert(sizeof(FBulkUserInfoPayload) == 0x000010, "Wrong size on FBulkUserInfoPayload");
static_assert(offsetof(FBulkUserInfoPayload, Users) == 0x000000, "Member 'FBulkUserInfoPayload::Users' has a wrong offset!");

// ScriptStruct SCT.PlayerCustomizationPreset
// 0x0058 (0x0060 - 0x0008)
struct FPlayerCustomizationPreset final : public FPlayerCustomizationFeature
{
public:
	class UTexture2D*                             IconThumbnail;                                     // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, float>                    MorphTargets;                                      // 0x0010(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCustomizationPreset) == 0x000008, "Wrong alignment on FPlayerCustomizationPreset");
static_assert(sizeof(FPlayerCustomizationPreset) == 0x000060, "Wrong size on FPlayerCustomizationPreset");
static_assert(offsetof(FPlayerCustomizationPreset, IconThumbnail) == 0x000008, "Member 'FPlayerCustomizationPreset::IconThumbnail' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationPreset, MorphTargets) == 0x000010, "Member 'FPlayerCustomizationPreset::MorphTargets' has a wrong offset!");

// ScriptStruct SCT.CloudCustomizationPacket
// 0x0028 (0x0028 - 0x0000)
struct FCloudCustomizationPacket final
{
public:
	class UStreamableRenderAsset*                 Mesh;                                              // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Mask;                                              // 0x0008(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      PrimaryMaterial;                                   // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      SecondaryMaterial;                                 // 0x0018(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MaskLegs;                                          // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCloudCustomizationPacket) == 0x000008, "Wrong alignment on FCloudCustomizationPacket");
static_assert(sizeof(FCloudCustomizationPacket) == 0x000028, "Wrong size on FCloudCustomizationPacket");
static_assert(offsetof(FCloudCustomizationPacket, Mesh) == 0x000000, "Member 'FCloudCustomizationPacket::Mesh' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationPacket, Mask) == 0x000008, "Member 'FCloudCustomizationPacket::Mask' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationPacket, PrimaryMaterial) == 0x000010, "Member 'FCloudCustomizationPacket::PrimaryMaterial' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationPacket, SecondaryMaterial) == 0x000018, "Member 'FCloudCustomizationPacket::SecondaryMaterial' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationPacket, MaskLegs) == 0x000020, "Member 'FCloudCustomizationPacket::MaskLegs' has a wrong offset!");

// ScriptStruct SCT.AccelByteUserPresenceData
// 0x0028 (0x0028 - 0x0000)
struct FAccelByteUserPresenceData final
{
public:
	EAvailability                                 Availability;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlatformId;                                        // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformUserId;                                    // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAccelByteUserPresenceData) == 0x000008, "Wrong alignment on FAccelByteUserPresenceData");
static_assert(sizeof(FAccelByteUserPresenceData) == 0x000028, "Wrong size on FAccelByteUserPresenceData");
static_assert(offsetof(FAccelByteUserPresenceData, Availability) == 0x000000, "Member 'FAccelByteUserPresenceData::Availability' has a wrong offset!");
static_assert(offsetof(FAccelByteUserPresenceData, PlatformId) == 0x000008, "Member 'FAccelByteUserPresenceData::PlatformId' has a wrong offset!");
static_assert(offsetof(FAccelByteUserPresenceData, PlatformUserId) == 0x000018, "Member 'FAccelByteUserPresenceData::PlatformUserId' has a wrong offset!");

// ScriptStruct SCT.FCTCloudCustomizationGender
// 0x00B0 (0x00B0 - 0x0000)
struct FFCTCloudCustomizationGender final
{
public:
	class FString                                 Skin_tone_selected;                                // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Eye_color_selected;                                // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Appearance_preset_selected;                        // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Head;                                              // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Body;                                              // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Legs;                                              // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Feet;                                              // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Hair_color;                                        // 0x0070(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Facial_hair;                                       // 0x0080(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Accessory;                                         // 0x0090(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Eyewear;                                           // 0x00A0(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTCloudCustomizationGender) == 0x000008, "Wrong alignment on FFCTCloudCustomizationGender");
static_assert(sizeof(FFCTCloudCustomizationGender) == 0x0000B0, "Wrong size on FFCTCloudCustomizationGender");
static_assert(offsetof(FFCTCloudCustomizationGender, Skin_tone_selected) == 0x000000, "Member 'FFCTCloudCustomizationGender::Skin_tone_selected' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationGender, Eye_color_selected) == 0x000010, "Member 'FFCTCloudCustomizationGender::Eye_color_selected' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationGender, Appearance_preset_selected) == 0x000020, "Member 'FFCTCloudCustomizationGender::Appearance_preset_selected' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationGender, Head) == 0x000030, "Member 'FFCTCloudCustomizationGender::Head' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationGender, Body) == 0x000040, "Member 'FFCTCloudCustomizationGender::Body' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationGender, Legs) == 0x000050, "Member 'FFCTCloudCustomizationGender::Legs' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationGender, Feet) == 0x000060, "Member 'FFCTCloudCustomizationGender::Feet' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationGender, Hair_color) == 0x000070, "Member 'FFCTCloudCustomizationGender::Hair_color' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationGender, Facial_hair) == 0x000080, "Member 'FFCTCloudCustomizationGender::Facial_hair' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationGender, Accessory) == 0x000090, "Member 'FFCTCloudCustomizationGender::Accessory' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationGender, Eyewear) == 0x0000A0, "Member 'FFCTCloudCustomizationGender::Eyewear' has a wrong offset!");

// ScriptStruct SCT.CloudCustomizationPayload
// 0x0044 (0x0044 - 0x0000)
struct FCloudCustomizationPayload final
{
public:
	struct FCloudCustomizationSetting             HeadSettings;                                      // 0x0000(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCloudCustomizationSetting             BodySettings;                                      // 0x000C(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCloudCustomizationSetting             LegsSettings;                                      // 0x0018(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCloudCustomizationSetting             FeetSettings;                                      // 0x0024(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         SkinToneSelection;                                 // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AppearancePresetSelection;                         // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EyeColorSelection;                                 // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 HairColor;                                         // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsMale;                                            // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCloudCustomizationPayload) == 0x000004, "Wrong alignment on FCloudCustomizationPayload");
static_assert(sizeof(FCloudCustomizationPayload) == 0x000044, "Wrong size on FCloudCustomizationPayload");
static_assert(offsetof(FCloudCustomizationPayload, HeadSettings) == 0x000000, "Member 'FCloudCustomizationPayload::HeadSettings' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationPayload, BodySettings) == 0x00000C, "Member 'FCloudCustomizationPayload::BodySettings' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationPayload, LegsSettings) == 0x000018, "Member 'FCloudCustomizationPayload::LegsSettings' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationPayload, FeetSettings) == 0x000024, "Member 'FCloudCustomizationPayload::FeetSettings' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationPayload, SkinToneSelection) == 0x000030, "Member 'FCloudCustomizationPayload::SkinToneSelection' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationPayload, AppearancePresetSelection) == 0x000034, "Member 'FCloudCustomizationPayload::AppearancePresetSelection' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationPayload, EyeColorSelection) == 0x000038, "Member 'FCloudCustomizationPayload::EyeColorSelection' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationPayload, HairColor) == 0x00003C, "Member 'FCloudCustomizationPayload::HairColor' has a wrong offset!");
static_assert(offsetof(FCloudCustomizationPayload, IsMale) == 0x000040, "Member 'FCloudCustomizationPayload::IsMale' has a wrong offset!");

// ScriptStruct SCT.FCTRecentlyPlayedWithUser
// 0x0018 (0x0018 - 0x0000)
struct FFCTRecentlyPlayedWithUser final
{
public:
	class FString                                 User_id;                                           // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Played_on;                                         // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTRecentlyPlayedWithUser) == 0x000008, "Wrong alignment on FFCTRecentlyPlayedWithUser");
static_assert(sizeof(FFCTRecentlyPlayedWithUser) == 0x000018, "Wrong size on FFCTRecentlyPlayedWithUser");
static_assert(offsetof(FFCTRecentlyPlayedWithUser, User_id) == 0x000000, "Member 'FFCTRecentlyPlayedWithUser::User_id' has a wrong offset!");
static_assert(offsetof(FFCTRecentlyPlayedWithUser, Played_on) == 0x000010, "Member 'FFCTRecentlyPlayedWithUser::Played_on' has a wrong offset!");

// ScriptStruct SCT.FCTRecentlyPlayedWithPayload
// 0x0010 (0x0010 - 0x0000)
struct FFCTRecentlyPlayedWithPayload final
{
public:
	TArray<struct FFCTRecentlyPlayedWithUser>     Users;                                             // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTRecentlyPlayedWithPayload) == 0x000008, "Wrong alignment on FFCTRecentlyPlayedWithPayload");
static_assert(sizeof(FFCTRecentlyPlayedWithPayload) == 0x000010, "Wrong size on FFCTRecentlyPlayedWithPayload");
static_assert(offsetof(FFCTRecentlyPlayedWithPayload, Users) == 0x000000, "Member 'FFCTRecentlyPlayedWithPayload::Users' has a wrong offset!");

// ScriptStruct SCT.FCTCloudEmotesPayload
// 0x0010 (0x0010 - 0x0000)
struct FFCTCloudEmotesPayload final
{
public:
	TArray<class FString>                         Emotes;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTCloudEmotesPayload) == 0x000008, "Wrong alignment on FFCTCloudEmotesPayload");
static_assert(sizeof(FFCTCloudEmotesPayload) == 0x000010, "Wrong size on FFCTCloudEmotesPayload");
static_assert(offsetof(FFCTCloudEmotesPayload, Emotes) == 0x000000, "Member 'FFCTCloudEmotesPayload::Emotes' has a wrong offset!");

// ScriptStruct SCT.PlayerCustomizationItemTableRow
// 0x0098 (0x00A8 - 0x0010)
struct FPlayerCustomizationItemTableRow : public FCustomizationQualityItemTableRow
{
public:
	class USkeletalMesh*                          AppearanceMesh;                                    // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstance*>              Materials;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         UnlockLevel;                                       // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TokenCost;                                         // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             IconThumbnail;                                     // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             CharacterMask;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AchievementCode;                                   // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EntitlementCode;                                   // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Sku;                                               // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DLCPackId;                                         // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Description;                                       // 0x0078(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          DoMaskLegs;                                        // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DoMaskFeet;                                        // 0x0091(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          VisibleWithoutOwning;                              // 0x0092(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93[0x5];                                       // 0x0093(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAkAudioEvent*>                  AKSounds;                                          // 0x0098(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCustomizationItemTableRow) == 0x000008, "Wrong alignment on FPlayerCustomizationItemTableRow");
static_assert(sizeof(FPlayerCustomizationItemTableRow) == 0x0000A8, "Wrong size on FPlayerCustomizationItemTableRow");
static_assert(offsetof(FPlayerCustomizationItemTableRow, AppearanceMesh) == 0x000010, "Member 'FPlayerCustomizationItemTableRow::AppearanceMesh' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, Materials) == 0x000018, "Member 'FPlayerCustomizationItemTableRow::Materials' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, UnlockLevel) == 0x000028, "Member 'FPlayerCustomizationItemTableRow::UnlockLevel' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, TokenCost) == 0x00002C, "Member 'FPlayerCustomizationItemTableRow::TokenCost' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, IconThumbnail) == 0x000030, "Member 'FPlayerCustomizationItemTableRow::IconThumbnail' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, CharacterMask) == 0x000038, "Member 'FPlayerCustomizationItemTableRow::CharacterMask' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, AchievementCode) == 0x000040, "Member 'FPlayerCustomizationItemTableRow::AchievementCode' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, EntitlementCode) == 0x000050, "Member 'FPlayerCustomizationItemTableRow::EntitlementCode' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, Sku) == 0x000060, "Member 'FPlayerCustomizationItemTableRow::Sku' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, DLCPackId) == 0x000070, "Member 'FPlayerCustomizationItemTableRow::DLCPackId' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, Description) == 0x000078, "Member 'FPlayerCustomizationItemTableRow::Description' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, DoMaskLegs) == 0x000090, "Member 'FPlayerCustomizationItemTableRow::DoMaskLegs' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, DoMaskFeet) == 0x000091, "Member 'FPlayerCustomizationItemTableRow::DoMaskFeet' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, VisibleWithoutOwning) == 0x000092, "Member 'FPlayerCustomizationItemTableRow::VisibleWithoutOwning' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationItemTableRow, AKSounds) == 0x000098, "Member 'FPlayerCustomizationItemTableRow::AKSounds' has a wrong offset!");

// ScriptStruct SCT.PlayerCustomizationAccessoryItemTableRow
// 0x0010 (0x00B8 - 0x00A8)
struct FPlayerCustomizationAccessoryItemTableRow final : public FPlayerCustomizationItemTableRow
{
public:
	TArray<class FString>                         SocketNames;                                       // 0x00A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCustomizationAccessoryItemTableRow) == 0x000008, "Wrong alignment on FPlayerCustomizationAccessoryItemTableRow");
static_assert(sizeof(FPlayerCustomizationAccessoryItemTableRow) == 0x0000B8, "Wrong size on FPlayerCustomizationAccessoryItemTableRow");
static_assert(offsetof(FPlayerCustomizationAccessoryItemTableRow, SocketNames) == 0x0000A8, "Member 'FPlayerCustomizationAccessoryItemTableRow::SocketNames' has a wrong offset!");

// ScriptStruct SCT.VersusEvilDocument
// 0x0030 (0x0030 - 0x0000)
struct FVersusEvilDocument final
{
public:
	class FString                                 PolicyName;                                        // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PolicyDocumentation;                               // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PolicyId;                                          // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVersusEvilDocument) == 0x000008, "Wrong alignment on FVersusEvilDocument");
static_assert(sizeof(FVersusEvilDocument) == 0x000030, "Wrong size on FVersusEvilDocument");
static_assert(offsetof(FVersusEvilDocument, PolicyName) == 0x000000, "Member 'FVersusEvilDocument::PolicyName' has a wrong offset!");
static_assert(offsetof(FVersusEvilDocument, PolicyDocumentation) == 0x000010, "Member 'FVersusEvilDocument::PolicyDocumentation' has a wrong offset!");
static_assert(offsetof(FVersusEvilDocument, PolicyId) == 0x000020, "Member 'FVersusEvilDocument::PolicyId' has a wrong offset!");

// ScriptStruct SCT.VersusEvilDocumentsPayload
// 0x0010 (0x0010 - 0x0000)
struct FVersusEvilDocumentsPayload final
{
public:
	TArray<struct FVersusEvilDocument>            Documents;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FVersusEvilDocumentsPayload) == 0x000008, "Wrong alignment on FVersusEvilDocumentsPayload");
static_assert(sizeof(FVersusEvilDocumentsPayload) == 0x000010, "Wrong size on FVersusEvilDocumentsPayload");
static_assert(offsetof(FVersusEvilDocumentsPayload, Documents) == 0x000000, "Member 'FVersusEvilDocumentsPayload::Documents' has a wrong offset!");

// ScriptStruct SCT.PlayerCustomizationColorMaterial
// 0x0018 (0x0020 - 0x0008)
struct FPlayerCustomizationColorMaterial final : public FPlayerCustomizationFeature
{
public:
	struct FLinearColor                           ThumbnailColor;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      Material;                                          // 0x0018(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCustomizationColorMaterial) == 0x000008, "Wrong alignment on FPlayerCustomizationColorMaterial");
static_assert(sizeof(FPlayerCustomizationColorMaterial) == 0x000020, "Wrong size on FPlayerCustomizationColorMaterial");
static_assert(offsetof(FPlayerCustomizationColorMaterial, ThumbnailColor) == 0x000008, "Member 'FPlayerCustomizationColorMaterial::ThumbnailColor' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationColorMaterial, Material) == 0x000018, "Member 'FPlayerCustomizationColorMaterial::Material' has a wrong offset!");

// ScriptStruct SCT.FCTWalletInfo
// 0x0020 (0x0020 - 0x0000)
struct FFCTWalletInfo final
{
public:
	int32                                         Balance;                                           // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAccelByteItemStatus                          Status;                                            // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              UpdatedAt;                                         // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyCode;                                      // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTWalletInfo) == 0x000008, "Wrong alignment on FFCTWalletInfo");
static_assert(sizeof(FFCTWalletInfo) == 0x000020, "Wrong size on FFCTWalletInfo");
static_assert(offsetof(FFCTWalletInfo, Balance) == 0x000000, "Member 'FFCTWalletInfo::Balance' has a wrong offset!");
static_assert(offsetof(FFCTWalletInfo, Status) == 0x000004, "Member 'FFCTWalletInfo::Status' has a wrong offset!");
static_assert(offsetof(FFCTWalletInfo, UpdatedAt) == 0x000008, "Member 'FFCTWalletInfo::UpdatedAt' has a wrong offset!");
static_assert(offsetof(FFCTWalletInfo, CurrencyCode) == 0x000010, "Member 'FFCTWalletInfo::CurrencyCode' has a wrong offset!");

// ScriptStruct SCT.JSonConversionUtility
// 0x0000 (0x0000 - 0x0000)
#pragma pack(push, 0x1)
struct alignas(0x01) FJSonConversionUtility
{
};
#pragma pack(pop)
static_assert(alignof(FJSonConversionUtility) == 0x000001, "Wrong alignment on FJSonConversionUtility");
static_assert(sizeof(FJSonConversionUtility) == 0x000001, "Wrong size on FJSonConversionUtility");

// ScriptStruct SCT.BulkDLCPacksData
// 0x0010 (0x0010 - 0x0000)
struct FBulkDLCPacksData final : public FJSonConversionUtility
{
public:
	TArray<struct FDLCPackData>                   Packs;                                             // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBulkDLCPacksData) == 0x000008, "Wrong alignment on FBulkDLCPacksData");
static_assert(sizeof(FBulkDLCPacksData) == 0x000010, "Wrong size on FBulkDLCPacksData");
static_assert(offsetof(FBulkDLCPacksData, Packs) == 0x000000, "Member 'FBulkDLCPacksData::Packs' has a wrong offset!");

// ScriptStruct SCT.SkillCheckTelemetryPayload
// 0x0028 (0x0028 - 0x0000)
struct FSkillCheckTelemetryPayload final
{
public:
	class FString                                 PlayerAFaction;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerBFaction;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SkillCheckPassed;                                  // 0x0020(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillCheckTelemetryPayload) == 0x000008, "Wrong alignment on FSkillCheckTelemetryPayload");
static_assert(sizeof(FSkillCheckTelemetryPayload) == 0x000028, "Wrong size on FSkillCheckTelemetryPayload");
static_assert(offsetof(FSkillCheckTelemetryPayload, PlayerAFaction) == 0x000000, "Member 'FSkillCheckTelemetryPayload::PlayerAFaction' has a wrong offset!");
static_assert(offsetof(FSkillCheckTelemetryPayload, PlayerBFaction) == 0x000010, "Member 'FSkillCheckTelemetryPayload::PlayerBFaction' has a wrong offset!");
static_assert(offsetof(FSkillCheckTelemetryPayload, SkillCheckPassed) == 0x000020, "Member 'FSkillCheckTelemetryPayload::SkillCheckPassed' has a wrong offset!");

// ScriptStruct SCT.ClientPlayerInfo
// 0x0078 (0x0078 - 0x0000)
struct FClientPlayerInfo final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SteamID;                                           // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PSNID;                                             // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunningOnPS5;                                     // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 XboxLiveID;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           IdentificationColor;                               // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccelByteId;                                       // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasIdentificationColor;                            // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasBeenReported;                                   // 0x0071(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FClientPlayerInfo) == 0x000008, "Wrong alignment on FClientPlayerInfo");
static_assert(sizeof(FClientPlayerInfo) == 0x000078, "Wrong size on FClientPlayerInfo");
static_assert(offsetof(FClientPlayerInfo, PlayerId) == 0x000000, "Member 'FClientPlayerInfo::PlayerId' has a wrong offset!");
static_assert(offsetof(FClientPlayerInfo, SteamID) == 0x000008, "Member 'FClientPlayerInfo::SteamID' has a wrong offset!");
static_assert(offsetof(FClientPlayerInfo, PSNID) == 0x000018, "Member 'FClientPlayerInfo::PSNID' has a wrong offset!");
static_assert(offsetof(FClientPlayerInfo, bRunningOnPS5) == 0x000028, "Member 'FClientPlayerInfo::bRunningOnPS5' has a wrong offset!");
static_assert(offsetof(FClientPlayerInfo, XboxLiveID) == 0x000030, "Member 'FClientPlayerInfo::XboxLiveID' has a wrong offset!");
static_assert(offsetof(FClientPlayerInfo, IdentificationColor) == 0x000040, "Member 'FClientPlayerInfo::IdentificationColor' has a wrong offset!");
static_assert(offsetof(FClientPlayerInfo, DisplayName) == 0x000050, "Member 'FClientPlayerInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FClientPlayerInfo, AccelByteId) == 0x000060, "Member 'FClientPlayerInfo::AccelByteId' has a wrong offset!");
static_assert(offsetof(FClientPlayerInfo, HasIdentificationColor) == 0x000070, "Member 'FClientPlayerInfo::HasIdentificationColor' has a wrong offset!");
static_assert(offsetof(FClientPlayerInfo, HasBeenReported) == 0x000071, "Member 'FClientPlayerInfo::HasBeenReported' has a wrong offset!");

// ScriptStruct SCT.FCTPlatformPlayerInfo
// 0x0020 (0x0020 - 0x0000)
struct FFCTPlatformPlayerInfo final
{
public:
	class FString                                 Current_platform;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Platform_id;                                       // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTPlatformPlayerInfo) == 0x000008, "Wrong alignment on FFCTPlatformPlayerInfo");
static_assert(sizeof(FFCTPlatformPlayerInfo) == 0x000020, "Wrong size on FFCTPlatformPlayerInfo");
static_assert(offsetof(FFCTPlatformPlayerInfo, Current_platform) == 0x000000, "Member 'FFCTPlatformPlayerInfo::Current_platform' has a wrong offset!");
static_assert(offsetof(FFCTPlatformPlayerInfo, Platform_id) == 0x000010, "Member 'FFCTPlatformPlayerInfo::Platform_id' has a wrong offset!");

// ScriptStruct SCT.FCTCloudCustomizationVruumba
// 0x0030 (0x0030 - 0x0000)
struct FFCTCloudCustomizationVruumba final
{
public:
	class FString                                 Body;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Antenna;                                           // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Particles;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTCloudCustomizationVruumba) == 0x000008, "Wrong alignment on FFCTCloudCustomizationVruumba");
static_assert(sizeof(FFCTCloudCustomizationVruumba) == 0x000030, "Wrong size on FFCTCloudCustomizationVruumba");
static_assert(offsetof(FFCTCloudCustomizationVruumba, Body) == 0x000000, "Member 'FFCTCloudCustomizationVruumba::Body' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationVruumba, Antenna) == 0x000010, "Member 'FFCTCloudCustomizationVruumba::Antenna' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationVruumba, Particles) == 0x000020, "Member 'FFCTCloudCustomizationVruumba::Particles' has a wrong offset!");

// ScriptStruct SCT.FCTCloudCustomizationPayload
// 0x01A8 (0x01A8 - 0x0000)
struct FFCTCloudCustomizationPayload final
{
public:
	struct FFCTCloudCustomizationGender           Male;                                              // 0x0000(0x00B0)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFCTCloudCustomizationGender           Female;                                            // 0x00B0(0x00B0)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFCTCloudCustomizationVruumba          Vruumba;                                           // 0x0160(0x0030)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          Male_selected;                                     // 0x0190(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 Trophy_info;                                       // 0x0198(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTCloudCustomizationPayload) == 0x000008, "Wrong alignment on FFCTCloudCustomizationPayload");
static_assert(sizeof(FFCTCloudCustomizationPayload) == 0x0001A8, "Wrong size on FFCTCloudCustomizationPayload");
static_assert(offsetof(FFCTCloudCustomizationPayload, Male) == 0x000000, "Member 'FFCTCloudCustomizationPayload::Male' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationPayload, Female) == 0x0000B0, "Member 'FFCTCloudCustomizationPayload::Female' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationPayload, Vruumba) == 0x000160, "Member 'FFCTCloudCustomizationPayload::Vruumba' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationPayload, Male_selected) == 0x000190, "Member 'FFCTCloudCustomizationPayload::Male_selected' has a wrong offset!");
static_assert(offsetof(FFCTCloudCustomizationPayload, Trophy_info) == 0x000198, "Member 'FFCTCloudCustomizationPayload::Trophy_info' has a wrong offset!");

// ScriptStruct SCT.FCTPublicPlayerData
// 0x0028 (0x0028 - 0x0000)
struct FFCTPublicPlayerData final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Experience;                                        // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Karma_score;                                       // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Preferred_avatarname;                              // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Version;                                           // 0x0020(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTPublicPlayerData) == 0x000008, "Wrong alignment on FFCTPublicPlayerData");
static_assert(sizeof(FFCTPublicPlayerData) == 0x000028, "Wrong size on FFCTPublicPlayerData");
static_assert(offsetof(FFCTPublicPlayerData, Level) == 0x000000, "Member 'FFCTPublicPlayerData::Level' has a wrong offset!");
static_assert(offsetof(FFCTPublicPlayerData, Experience) == 0x000004, "Member 'FFCTPublicPlayerData::Experience' has a wrong offset!");
static_assert(offsetof(FFCTPublicPlayerData, Karma_score) == 0x000008, "Member 'FFCTPublicPlayerData::Karma_score' has a wrong offset!");
static_assert(offsetof(FFCTPublicPlayerData, Preferred_avatarname) == 0x000010, "Member 'FFCTPublicPlayerData::Preferred_avatarname' has a wrong offset!");
static_assert(offsetof(FFCTPublicPlayerData, Version) == 0x000020, "Member 'FFCTPublicPlayerData::Version' has a wrong offset!");

// ScriptStruct SCT.FCTUserAccountMergerPayload
// 0x02A0 (0x02A0 - 0x0000)
struct FFCTUserAccountMergerPayload final
{
public:
	struct FFCTCloudCustomizationPayload          CustomizationRecord;                               // 0x0000(0x01A8)(NativeAccessSpecifierPublic)
	struct FFCTPublicPlayerData                   PublicProfileRecord;                               // 0x01A8(0x0028)(NativeAccessSpecifierPublic)
	struct FAccelByteModelsPaginatedUserAchievement Achievements;                                      // 0x01D0(0x0060)(NativeAccessSpecifierPublic)
	struct FAccelByteModelsUserStatItemPagingSlicedResult Stats;                                             // 0x0230(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FAccelByteModelsEntitlementInfo> Entitlements;                                      // 0x0280(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         FriendIds;                                         // 0x0290(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTUserAccountMergerPayload) == 0x000008, "Wrong alignment on FFCTUserAccountMergerPayload");
static_assert(sizeof(FFCTUserAccountMergerPayload) == 0x0002A0, "Wrong size on FFCTUserAccountMergerPayload");
static_assert(offsetof(FFCTUserAccountMergerPayload, CustomizationRecord) == 0x000000, "Member 'FFCTUserAccountMergerPayload::CustomizationRecord' has a wrong offset!");
static_assert(offsetof(FFCTUserAccountMergerPayload, PublicProfileRecord) == 0x0001A8, "Member 'FFCTUserAccountMergerPayload::PublicProfileRecord' has a wrong offset!");
static_assert(offsetof(FFCTUserAccountMergerPayload, Achievements) == 0x0001D0, "Member 'FFCTUserAccountMergerPayload::Achievements' has a wrong offset!");
static_assert(offsetof(FFCTUserAccountMergerPayload, Stats) == 0x000230, "Member 'FFCTUserAccountMergerPayload::Stats' has a wrong offset!");
static_assert(offsetof(FFCTUserAccountMergerPayload, Entitlements) == 0x000280, "Member 'FFCTUserAccountMergerPayload::Entitlements' has a wrong offset!");
static_assert(offsetof(FFCTUserAccountMergerPayload, FriendIds) == 0x000290, "Member 'FFCTUserAccountMergerPayload::FriendIds' has a wrong offset!");

// ScriptStruct SCT.PlayerCustomizationColor
// 0x0020 (0x0028 - 0x0008)
struct FPlayerCustomizationColor final : public FPlayerCustomizationFeature
{
public:
	struct FLinearColor                           ThumbnailColor;                                    // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           AssignColor;                                       // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerCustomizationColor) == 0x000008, "Wrong alignment on FPlayerCustomizationColor");
static_assert(sizeof(FPlayerCustomizationColor) == 0x000028, "Wrong size on FPlayerCustomizationColor");
static_assert(offsetof(FPlayerCustomizationColor, ThumbnailColor) == 0x000008, "Member 'FPlayerCustomizationColor::ThumbnailColor' has a wrong offset!");
static_assert(offsetof(FPlayerCustomizationColor, AssignColor) == 0x000018, "Member 'FPlayerCustomizationColor::AssignColor' has a wrong offset!");

// ScriptStruct SCT.FCTVirtualPurchasesPayload
// 0x0018 (0x0018 - 0x0000)
struct FFCTVirtualPurchasesPayload final
{
public:
	int32                                         First_class_tokens;                                // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         Owned_items;                                       // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTVirtualPurchasesPayload) == 0x000008, "Wrong alignment on FFCTVirtualPurchasesPayload");
static_assert(sizeof(FFCTVirtualPurchasesPayload) == 0x000018, "Wrong size on FFCTVirtualPurchasesPayload");
static_assert(offsetof(FFCTVirtualPurchasesPayload, First_class_tokens) == 0x000000, "Member 'FFCTVirtualPurchasesPayload::First_class_tokens' has a wrong offset!");
static_assert(offsetof(FFCTVirtualPurchasesPayload, Owned_items) == 0x000008, "Member 'FFCTVirtualPurchasesPayload::Owned_items' has a wrong offset!");

// ScriptStruct SCT.CachedItemSlotData
// 0x0010 (0x0010 - 0x0000)
struct FCachedItemSlotData final
{
public:
	EInventorySlotID                              SlotId;                                            // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPower>                     PowerType;                                         // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCachedItemSlotData) == 0x000008, "Wrong alignment on FCachedItemSlotData");
static_assert(sizeof(FCachedItemSlotData) == 0x000010, "Wrong size on FCachedItemSlotData");
static_assert(offsetof(FCachedItemSlotData, SlotId) == 0x000000, "Member 'FCachedItemSlotData::SlotId' has a wrong offset!");
static_assert(offsetof(FCachedItemSlotData, PowerType) == 0x000008, "Member 'FCachedItemSlotData::PowerType' has a wrong offset!");

// ScriptStruct SCT.DLCOutfitRef
// 0x0020 (0x0020 - 0x0000)
struct FDLCOutfitRef final
{
public:
	class FString                                 MaleDTName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FemaleDTName;                                      // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLCOutfitRef) == 0x000008, "Wrong alignment on FDLCOutfitRef");
static_assert(sizeof(FDLCOutfitRef) == 0x000020, "Wrong size on FDLCOutfitRef");
static_assert(offsetof(FDLCOutfitRef, MaleDTName) == 0x000000, "Member 'FDLCOutfitRef::MaleDTName' has a wrong offset!");
static_assert(offsetof(FDLCOutfitRef, FemaleDTName) == 0x000010, "Member 'FDLCOutfitRef::FemaleDTName' has a wrong offset!");

// ScriptStruct SCT.DLCPackItemRefTableRow
// 0x0018 (0x0020 - 0x0008)
struct FDLCPackItemRefTableRow final : public FTableRowBase
{
public:
	class UTexture2D*                             Thumbnail;                                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FDLCOutfitRef>                  ItemSet;                                           // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDLCPackItemRefTableRow) == 0x000008, "Wrong alignment on FDLCPackItemRefTableRow");
static_assert(sizeof(FDLCPackItemRefTableRow) == 0x000020, "Wrong size on FDLCPackItemRefTableRow");
static_assert(offsetof(FDLCPackItemRefTableRow, Thumbnail) == 0x000008, "Member 'FDLCPackItemRefTableRow::Thumbnail' has a wrong offset!");
static_assert(offsetof(FDLCPackItemRefTableRow, ItemSet) == 0x000010, "Member 'FDLCPackItemRefTableRow::ItemSet' has a wrong offset!");

// ScriptStruct SCT.DeathEffectDetails
// 0x0028 (0x0028 - 0x0000)
struct FDeathEffectDetails final
{
public:
	float                                         Duration;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Icon;                                              // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeathEffectDetails) == 0x000008, "Wrong alignment on FDeathEffectDetails");
static_assert(sizeof(FDeathEffectDetails) == 0x000028, "Wrong size on FDeathEffectDetails");
static_assert(offsetof(FDeathEffectDetails, Duration) == 0x000000, "Member 'FDeathEffectDetails::Duration' has a wrong offset!");
static_assert(offsetof(FDeathEffectDetails, Icon) == 0x000008, "Member 'FDeathEffectDetails::Icon' has a wrong offset!");
static_assert(offsetof(FDeathEffectDetails, DisplayName) == 0x000010, "Member 'FDeathEffectDetails::DisplayName' has a wrong offset!");

// ScriptStruct SCT.FCTFriendBatchNode
// 0x0020 (0x0020 - 0x0000)
struct FFCTFriendBatchNode final
{
public:
	TArray<class FString>                         UserIds;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFCTFriendBatchNode) == 0x000008, "Wrong alignment on FFCTFriendBatchNode");
static_assert(sizeof(FFCTFriendBatchNode) == 0x000020, "Wrong size on FFCTFriendBatchNode");
static_assert(offsetof(FFCTFriendBatchNode, UserIds) == 0x000000, "Member 'FFCTFriendBatchNode::UserIds' has a wrong offset!");

// ScriptStruct SCT.FCTGameTelementryUserStartMatchModel
// 0x0020 (0x0020 - 0x0000)
struct FFCTGameTelementryUserStartMatchModel final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoginType;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTGameTelementryUserStartMatchModel) == 0x000008, "Wrong alignment on FFCTGameTelementryUserStartMatchModel");
static_assert(sizeof(FFCTGameTelementryUserStartMatchModel) == 0x000020, "Wrong size on FFCTGameTelementryUserStartMatchModel");
static_assert(offsetof(FFCTGameTelementryUserStartMatchModel, UserId) == 0x000000, "Member 'FFCTGameTelementryUserStartMatchModel::UserId' has a wrong offset!");
static_assert(offsetof(FFCTGameTelementryUserStartMatchModel, LoginType) == 0x000010, "Member 'FFCTGameTelementryUserStartMatchModel::LoginType' has a wrong offset!");

// ScriptStruct SCT.UserIdLLNode
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FUserIdLLNode final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FUserIdLLNode) == 0x000008, "Wrong alignment on FUserIdLLNode");
static_assert(sizeof(FUserIdLLNode) == 0x000020, "Wrong size on FUserIdLLNode");

// ScriptStruct SCT.PassengerLogPickedUpTelemetry
// 0x0030 (0x0030 - 0x0000)
struct FPassengerLogPickedUpTelemetry final
{
public:
	class FString                                 Map;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LogType;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Faction;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPassengerLogPickedUpTelemetry) == 0x000008, "Wrong alignment on FPassengerLogPickedUpTelemetry");
static_assert(sizeof(FPassengerLogPickedUpTelemetry) == 0x000030, "Wrong size on FPassengerLogPickedUpTelemetry");
static_assert(offsetof(FPassengerLogPickedUpTelemetry, Map) == 0x000000, "Member 'FPassengerLogPickedUpTelemetry::Map' has a wrong offset!");
static_assert(offsetof(FPassengerLogPickedUpTelemetry, LogType) == 0x000010, "Member 'FPassengerLogPickedUpTelemetry::LogType' has a wrong offset!");
static_assert(offsetof(FPassengerLogPickedUpTelemetry, Faction) == 0x000020, "Member 'FPassengerLogPickedUpTelemetry::Faction' has a wrong offset!");

// ScriptStruct SCT.PlayerDiedTelemetry
// 0x0040 (0x0040 - 0x0000)
struct FPlayerDiedTelemetry final
{
public:
	class FString                                 Map;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Fate;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0020(0x000C)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Faction;                                           // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerDiedTelemetry) == 0x000008, "Wrong alignment on FPlayerDiedTelemetry");
static_assert(sizeof(FPlayerDiedTelemetry) == 0x000040, "Wrong size on FPlayerDiedTelemetry");
static_assert(offsetof(FPlayerDiedTelemetry, Map) == 0x000000, "Member 'FPlayerDiedTelemetry::Map' has a wrong offset!");
static_assert(offsetof(FPlayerDiedTelemetry, Fate) == 0x000010, "Member 'FPlayerDiedTelemetry::Fate' has a wrong offset!");
static_assert(offsetof(FPlayerDiedTelemetry, Location) == 0x000020, "Member 'FPlayerDiedTelemetry::Location' has a wrong offset!");
static_assert(offsetof(FPlayerDiedTelemetry, Faction) == 0x000030, "Member 'FPlayerDiedTelemetry::Faction' has a wrong offset!");

// ScriptStruct SCT.ItemTelemetryPayload
// 0x0050 (0x0050 - 0x0000)
struct FItemTelemetryPayload final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemName;                                          // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemAction;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Map;                                               // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Faction;                                           // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemTelemetryPayload) == 0x000008, "Wrong alignment on FItemTelemetryPayload");
static_assert(sizeof(FItemTelemetryPayload) == 0x000050, "Wrong size on FItemTelemetryPayload");
static_assert(offsetof(FItemTelemetryPayload, UserId) == 0x000000, "Member 'FItemTelemetryPayload::UserId' has a wrong offset!");
static_assert(offsetof(FItemTelemetryPayload, ItemName) == 0x000010, "Member 'FItemTelemetryPayload::ItemName' has a wrong offset!");
static_assert(offsetof(FItemTelemetryPayload, ItemAction) == 0x000020, "Member 'FItemTelemetryPayload::ItemAction' has a wrong offset!");
static_assert(offsetof(FItemTelemetryPayload, Map) == 0x000030, "Member 'FItemTelemetryPayload::Map' has a wrong offset!");
static_assert(offsetof(FItemTelemetryPayload, Faction) == 0x000040, "Member 'FItemTelemetryPayload::Faction' has a wrong offset!");

// ScriptStruct SCT.EndOfMatchTelemetryPayload
// 0x0028 (0x0028 - 0x0000)
struct FEndOfMatchTelemetryPayload final
{
public:
	class FString                                 EndCondition;                                      // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WinningFaction;                                    // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalMatchTime;                                    // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEndOfMatchTelemetryPayload) == 0x000008, "Wrong alignment on FEndOfMatchTelemetryPayload");
static_assert(sizeof(FEndOfMatchTelemetryPayload) == 0x000028, "Wrong size on FEndOfMatchTelemetryPayload");
static_assert(offsetof(FEndOfMatchTelemetryPayload, EndCondition) == 0x000000, "Member 'FEndOfMatchTelemetryPayload::EndCondition' has a wrong offset!");
static_assert(offsetof(FEndOfMatchTelemetryPayload, WinningFaction) == 0x000010, "Member 'FEndOfMatchTelemetryPayload::WinningFaction' has a wrong offset!");
static_assert(offsetof(FEndOfMatchTelemetryPayload, TotalMatchTime) == 0x000020, "Member 'FEndOfMatchTelemetryPayload::TotalMatchTime' has a wrong offset!");

// ScriptStruct SCT.FriendlyKillTelemetryPayload
// 0x0020 (0x0020 - 0x0000)
struct FFriendlyKillTelemetryPayload final
{
public:
	class FString                                 Map;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Faction;                                           // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFriendlyKillTelemetryPayload) == 0x000008, "Wrong alignment on FFriendlyKillTelemetryPayload");
static_assert(sizeof(FFriendlyKillTelemetryPayload) == 0x000020, "Wrong size on FFriendlyKillTelemetryPayload");
static_assert(offsetof(FFriendlyKillTelemetryPayload, Map) == 0x000000, "Member 'FFriendlyKillTelemetryPayload::Map' has a wrong offset!");
static_assert(offsetof(FFriendlyKillTelemetryPayload, Faction) == 0x000010, "Member 'FFriendlyKillTelemetryPayload::Faction' has a wrong offset!");

// ScriptStruct SCT.PlayerSummaryTelemetryPayload
// 0x0038 (0x0038 - 0x0000)
struct FPlayerSummaryTelemetryPayload final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Fate;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Faction;                                           // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XpEarned;                                          // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerSummaryTelemetryPayload) == 0x000008, "Wrong alignment on FPlayerSummaryTelemetryPayload");
static_assert(sizeof(FPlayerSummaryTelemetryPayload) == 0x000038, "Wrong size on FPlayerSummaryTelemetryPayload");
static_assert(offsetof(FPlayerSummaryTelemetryPayload, UserId) == 0x000000, "Member 'FPlayerSummaryTelemetryPayload::UserId' has a wrong offset!");
static_assert(offsetof(FPlayerSummaryTelemetryPayload, Fate) == 0x000010, "Member 'FPlayerSummaryTelemetryPayload::Fate' has a wrong offset!");
static_assert(offsetof(FPlayerSummaryTelemetryPayload, Faction) == 0x000020, "Member 'FPlayerSummaryTelemetryPayload::Faction' has a wrong offset!");
static_assert(offsetof(FPlayerSummaryTelemetryPayload, XpEarned) == 0x000030, "Member 'FPlayerSummaryTelemetryPayload::XpEarned' has a wrong offset!");

// ScriptStruct SCT.UserReportPayload
// 0x0060 (0x0060 - 0x0000)
struct FUserReportPayload final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reportedby_userid;                                 // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionID;                                         // 0x0050(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUserReportPayload) == 0x000008, "Wrong alignment on FUserReportPayload");
static_assert(sizeof(FUserReportPayload) == 0x000060, "Wrong size on FUserReportPayload");
static_assert(offsetof(FUserReportPayload, UserId) == 0x000000, "Member 'FUserReportPayload::UserId' has a wrong offset!");
static_assert(offsetof(FUserReportPayload, DisplayName) == 0x000010, "Member 'FUserReportPayload::DisplayName' has a wrong offset!");
static_assert(offsetof(FUserReportPayload, Reportedby_userid) == 0x000020, "Member 'FUserReportPayload::Reportedby_userid' has a wrong offset!");
static_assert(offsetof(FUserReportPayload, Reason) == 0x000030, "Member 'FUserReportPayload::Reason' has a wrong offset!");
static_assert(offsetof(FUserReportPayload, Description) == 0x000040, "Member 'FUserReportPayload::Description' has a wrong offset!");
static_assert(offsetof(FUserReportPayload, SessionID) == 0x000050, "Member 'FUserReportPayload::SessionID' has a wrong offset!");

// ScriptStruct SCT.FCTAchievementsAndStatsPayload
// 0x00B0 (0x00B0 - 0x0000)
struct FFCTAchievementsAndStatsPayload final
{
public:
	struct FAccelByteModelsPaginatedUserAchievement Achievements;                                      // 0x0000(0x0060)(NativeAccessSpecifierPublic)
	struct FAccelByteModelsUserStatItemPagingSlicedResult Stats;                                             // 0x0060(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTAchievementsAndStatsPayload) == 0x000008, "Wrong alignment on FFCTAchievementsAndStatsPayload");
static_assert(sizeof(FFCTAchievementsAndStatsPayload) == 0x0000B0, "Wrong size on FFCTAchievementsAndStatsPayload");
static_assert(offsetof(FFCTAchievementsAndStatsPayload, Achievements) == 0x000000, "Member 'FFCTAchievementsAndStatsPayload::Achievements' has a wrong offset!");
static_assert(offsetof(FFCTAchievementsAndStatsPayload, Stats) == 0x000060, "Member 'FFCTAchievementsAndStatsPayload::Stats' has a wrong offset!");

// ScriptStruct SCT.UserReport
// 0x0060 (0x0060 - 0x0000)
struct FUserReport final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayName;                                       // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reportedby_userid;                                 // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Reason;                                            // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionID;                                         // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUserReport) == 0x000008, "Wrong alignment on FUserReport");
static_assert(sizeof(FUserReport) == 0x000060, "Wrong size on FUserReport");
static_assert(offsetof(FUserReport, UserId) == 0x000000, "Member 'FUserReport::UserId' has a wrong offset!");
static_assert(offsetof(FUserReport, DisplayName) == 0x000010, "Member 'FUserReport::DisplayName' has a wrong offset!");
static_assert(offsetof(FUserReport, Reportedby_userid) == 0x000020, "Member 'FUserReport::Reportedby_userid' has a wrong offset!");
static_assert(offsetof(FUserReport, Reason) == 0x000030, "Member 'FUserReport::Reason' has a wrong offset!");
static_assert(offsetof(FUserReport, Description) == 0x000040, "Member 'FUserReport::Description' has a wrong offset!");
static_assert(offsetof(FUserReport, SessionID) == 0x000050, "Member 'FUserReport::SessionID' has a wrong offset!");

// ScriptStruct SCT.UserReportProfile
// 0x0070 (0x0070 - 0x0000)
struct FUserReportProfile final
{
public:
	class FString                                 Profile_id;                                        // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FUserReport                            Entry;                                             // 0x0010(0x0060)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUserReportProfile) == 0x000008, "Wrong alignment on FUserReportProfile");
static_assert(sizeof(FUserReportProfile) == 0x000070, "Wrong size on FUserReportProfile");
static_assert(offsetof(FUserReportProfile, Profile_id) == 0x000000, "Member 'FUserReportProfile::Profile_id' has a wrong offset!");
static_assert(offsetof(FUserReportProfile, Entry) == 0x000010, "Member 'FUserReportProfile::Entry' has a wrong offset!");

// ScriptStruct SCT.FCTPrivatePlayerData
// 0x0010 (0x0010 - 0x0000)
struct FFCTPrivatePlayerData final
{
public:
	int32                                         Experience;                                        // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Infinity_coins;                                    // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        Version;                                           // 0x0008(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTPrivatePlayerData) == 0x000008, "Wrong alignment on FFCTPrivatePlayerData");
static_assert(sizeof(FFCTPrivatePlayerData) == 0x000010, "Wrong size on FFCTPrivatePlayerData");
static_assert(offsetof(FFCTPrivatePlayerData, Experience) == 0x000000, "Member 'FFCTPrivatePlayerData::Experience' has a wrong offset!");
static_assert(offsetof(FFCTPrivatePlayerData, Infinity_coins) == 0x000004, "Member 'FFCTPrivatePlayerData::Infinity_coins' has a wrong offset!");
static_assert(offsetof(FFCTPrivatePlayerData, Version) == 0x000008, "Member 'FFCTPrivatePlayerData::Version' has a wrong offset!");

// ScriptStruct SCT.MapAggregateTelemetryData
// 0x0028 (0x0028 - 0x0000)
struct FMapAggregateTelemetryData final
{
public:
	class FString                                 Map;                                               // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TotalTime;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayersKilled;                                     // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MatchEnded;                                        // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapAggregateTelemetryData) == 0x000008, "Wrong alignment on FMapAggregateTelemetryData");
static_assert(sizeof(FMapAggregateTelemetryData) == 0x000028, "Wrong size on FMapAggregateTelemetryData");
static_assert(offsetof(FMapAggregateTelemetryData, Map) == 0x000000, "Member 'FMapAggregateTelemetryData::Map' has a wrong offset!");
static_assert(offsetof(FMapAggregateTelemetryData, TotalTime) == 0x000010, "Member 'FMapAggregateTelemetryData::TotalTime' has a wrong offset!");
static_assert(offsetof(FMapAggregateTelemetryData, PlayersKilled) == 0x000020, "Member 'FMapAggregateTelemetryData::PlayersKilled' has a wrong offset!");
static_assert(offsetof(FMapAggregateTelemetryData, MatchEnded) == 0x000024, "Member 'FMapAggregateTelemetryData::MatchEnded' has a wrong offset!");

// ScriptStruct SCT.MapTelemetryCapture
// 0x0010 (0x0010 - 0x0000)
struct FMapTelemetryCapture final
{
public:
	struct FDateTime                              DateTime;                                          // 0x0000(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayersRemaining;                                  // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMapTelemetryCapture) == 0x000008, "Wrong alignment on FMapTelemetryCapture");
static_assert(sizeof(FMapTelemetryCapture) == 0x000010, "Wrong size on FMapTelemetryCapture");
static_assert(offsetof(FMapTelemetryCapture, DateTime) == 0x000000, "Member 'FMapTelemetryCapture::DateTime' has a wrong offset!");
static_assert(offsetof(FMapTelemetryCapture, PlayersRemaining) == 0x000008, "Member 'FMapTelemetryCapture::PlayersRemaining' has a wrong offset!");

// ScriptStruct SCT.RecentlyPlayedWithPayload
// 0x0020 (0x0020 - 0x0000)
struct FRecentlyPlayedWithPayload final
{
public:
	TArray<class FString>                         Lastmatch;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Earlier;                                           // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRecentlyPlayedWithPayload) == 0x000008, "Wrong alignment on FRecentlyPlayedWithPayload");
static_assert(sizeof(FRecentlyPlayedWithPayload) == 0x000020, "Wrong size on FRecentlyPlayedWithPayload");
static_assert(offsetof(FRecentlyPlayedWithPayload, Lastmatch) == 0x000000, "Member 'FRecentlyPlayedWithPayload::Lastmatch' has a wrong offset!");
static_assert(offsetof(FRecentlyPlayedWithPayload, Earlier) == 0x000010, "Member 'FRecentlyPlayedWithPayload::Earlier' has a wrong offset!");

// ScriptStruct SCT.FCTLiveMessage
// 0x00D8 (0x00D8 - 0x0000)
struct FFCTLiveMessage final
{
public:
	class FString                                 Message;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FExternalLocalizationData              Lang;                                              // 0x0018(0x00C0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTLiveMessage) == 0x000008, "Wrong alignment on FFCTLiveMessage");
static_assert(sizeof(FFCTLiveMessage) == 0x0000D8, "Wrong size on FFCTLiveMessage");
static_assert(offsetof(FFCTLiveMessage, Message) == 0x000000, "Member 'FFCTLiveMessage::Message' has a wrong offset!");
static_assert(offsetof(FFCTLiveMessage, Enabled) == 0x000010, "Member 'FFCTLiveMessage::Enabled' has a wrong offset!");
static_assert(offsetof(FFCTLiveMessage, Lang) == 0x000018, "Member 'FFCTLiveMessage::Lang' has a wrong offset!");

// ScriptStruct SCT.FCTLeaderboardRecordData
// 0x00E0 (0x00E0 - 0x0000)
struct FFCTLeaderboardRecordData final
{
public:
	class FString                                 TranslatedDisplayName;                             // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Code;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FExternalLocalizationData              Lang;                                              // 0x0020(0x00C0)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTLeaderboardRecordData) == 0x000008, "Wrong alignment on FFCTLeaderboardRecordData");
static_assert(sizeof(FFCTLeaderboardRecordData) == 0x0000E0, "Wrong size on FFCTLeaderboardRecordData");
static_assert(offsetof(FFCTLeaderboardRecordData, TranslatedDisplayName) == 0x000000, "Member 'FFCTLeaderboardRecordData::TranslatedDisplayName' has a wrong offset!");
static_assert(offsetof(FFCTLeaderboardRecordData, Code) == 0x000010, "Member 'FFCTLeaderboardRecordData::Code' has a wrong offset!");
static_assert(offsetof(FFCTLeaderboardRecordData, Lang) == 0x000020, "Member 'FFCTLeaderboardRecordData::Lang' has a wrong offset!");

// ScriptStruct SCT.FCTBulkLeaderboardRecordData
// 0x0010 (0x0010 - 0x0000)
struct FFCTBulkLeaderboardRecordData final
{
public:
	TArray<struct FFCTLeaderboardRecordData>      Data;                                              // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTBulkLeaderboardRecordData) == 0x000008, "Wrong alignment on FFCTBulkLeaderboardRecordData");
static_assert(sizeof(FFCTBulkLeaderboardRecordData) == 0x000010, "Wrong size on FFCTBulkLeaderboardRecordData");
static_assert(offsetof(FFCTBulkLeaderboardRecordData, Data) == 0x000000, "Member 'FFCTBulkLeaderboardRecordData::Data' has a wrong offset!");

// ScriptStruct SCT.FCTJSonPayload
// 0x0001 (0x0001 - 0x0000)
struct FFCTJSonPayload final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FFCTJSonPayload) == 0x000001, "Wrong alignment on FFCTJSonPayload");
static_assert(sizeof(FFCTJSonPayload) == 0x000001, "Wrong size on FFCTJSonPayload");

// ScriptStruct SCT.SessionEndTelemetryCapture
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FSessionEndTelemetryCapture final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSessionEndTelemetryCapture) == 0x000008, "Wrong alignment on FSessionEndTelemetryCapture");
static_assert(sizeof(FSessionEndTelemetryCapture) == 0x000008, "Wrong size on FSessionEndTelemetryCapture");

// ScriptStruct SCT.SessionStartTelemetryCapture
// 0x0008 (0x0008 - 0x0000)
struct alignas(0x08) FSessionStartTelemetryCapture final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSessionStartTelemetryCapture) == 0x000008, "Wrong alignment on FSessionStartTelemetryCapture");
static_assert(sizeof(FSessionStartTelemetryCapture) == 0x000008, "Wrong size on FSessionStartTelemetryCapture");

// ScriptStruct SCT.FCTGamesightRequest
// 0x0070 (0x0070 - 0x0000)
struct FFCTGamesightRequest final
{
public:
	class FString                                 User_id;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Type;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, class FString>            Identifiers;                                       // 0x0020(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FFCTGamesightRequest) == 0x000008, "Wrong alignment on FFCTGamesightRequest");
static_assert(sizeof(FFCTGamesightRequest) == 0x000070, "Wrong size on FFCTGamesightRequest");
static_assert(offsetof(FFCTGamesightRequest, User_id) == 0x000000, "Member 'FFCTGamesightRequest::User_id' has a wrong offset!");
static_assert(offsetof(FFCTGamesightRequest, Type) == 0x000010, "Member 'FFCTGamesightRequest::Type' has a wrong offset!");
static_assert(offsetof(FFCTGamesightRequest, Identifiers) == 0x000020, "Member 'FFCTGamesightRequest::Identifiers' has a wrong offset!");

// ScriptStruct SCT.InputInformation
// 0x0070 (0x0070 - 0x0000)
struct FInputInformation final
{
public:
	class FName                                   ActionName;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FInputActionKeyMapping                 DefaultKeyboardValue;                              // 0x0020(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FInputActionKeyMapping                 DefaultGamepadValue;                               // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputInformation) == 0x000008, "Wrong alignment on FInputInformation");
static_assert(sizeof(FInputInformation) == 0x000070, "Wrong size on FInputInformation");
static_assert(offsetof(FInputInformation, ActionName) == 0x000000, "Member 'FInputInformation::ActionName' has a wrong offset!");
static_assert(offsetof(FInputInformation, DisplayName) == 0x000008, "Member 'FInputInformation::DisplayName' has a wrong offset!");
static_assert(offsetof(FInputInformation, DefaultKeyboardValue) == 0x000020, "Member 'FInputInformation::DefaultKeyboardValue' has a wrong offset!");
static_assert(offsetof(FInputInformation, DefaultGamepadValue) == 0x000048, "Member 'FInputInformation::DefaultGamepadValue' has a wrong offset!");

// ScriptStruct SCT.InputInformationAxis
// 0x0050 (0x0050 - 0x0000)
struct FInputInformationAxis final
{
public:
	class FName                                   AxisName;                                          // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0008(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FInputAxisKeyMapping                   DefaultValues;                                     // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputInformationAxis) == 0x000008, "Wrong alignment on FInputInformationAxis");
static_assert(sizeof(FInputInformationAxis) == 0x000050, "Wrong size on FInputInformationAxis");
static_assert(offsetof(FInputInformationAxis, AxisName) == 0x000000, "Member 'FInputInformationAxis::AxisName' has a wrong offset!");
static_assert(offsetof(FInputInformationAxis, DisplayName) == 0x000008, "Member 'FInputInformationAxis::DisplayName' has a wrong offset!");
static_assert(offsetof(FInputInformationAxis, Scale) == 0x000020, "Member 'FInputInformationAxis::Scale' has a wrong offset!");
static_assert(offsetof(FInputInformationAxis, DefaultValues) == 0x000028, "Member 'FInputInformationAxis::DefaultValues' has a wrong offset!");

// ScriptStruct SCT.InputInformationFloatSlider
// 0x0018 (0x0018 - 0x0000)
struct FInputInformationFloatSlider final
{
public:
	class FName                                   DisplayName;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultValue;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StepValue;                                         // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputInformationFloatSlider) == 0x000004, "Wrong alignment on FInputInformationFloatSlider");
static_assert(sizeof(FInputInformationFloatSlider) == 0x000018, "Wrong size on FInputInformationFloatSlider");
static_assert(offsetof(FInputInformationFloatSlider, DisplayName) == 0x000000, "Member 'FInputInformationFloatSlider::DisplayName' has a wrong offset!");
static_assert(offsetof(FInputInformationFloatSlider, DefaultValue) == 0x000008, "Member 'FInputInformationFloatSlider::DefaultValue' has a wrong offset!");
static_assert(offsetof(FInputInformationFloatSlider, MinValue) == 0x00000C, "Member 'FInputInformationFloatSlider::MinValue' has a wrong offset!");
static_assert(offsetof(FInputInformationFloatSlider, MaxValue) == 0x000010, "Member 'FInputInformationFloatSlider::MaxValue' has a wrong offset!");
static_assert(offsetof(FInputInformationFloatSlider, StepValue) == 0x000014, "Member 'FInputInformationFloatSlider::StepValue' has a wrong offset!");

// ScriptStruct SCT.InputInformationToggle
// 0x0038 (0x0038 - 0x0000)
struct FInputInformationToggle final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   TargetAxis;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvertedValue;                                     // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvertedValueGamepad;                              // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ScaleSerializationName;                            // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DefaultValue;                                      // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInputInformationToggle) == 0x000008, "Wrong alignment on FInputInformationToggle");
static_assert(sizeof(FInputInformationToggle) == 0x000038, "Wrong size on FInputInformationToggle");
static_assert(offsetof(FInputInformationToggle, DisplayName) == 0x000000, "Member 'FInputInformationToggle::DisplayName' has a wrong offset!");
static_assert(offsetof(FInputInformationToggle, TargetAxis) == 0x000018, "Member 'FInputInformationToggle::TargetAxis' has a wrong offset!");
static_assert(offsetof(FInputInformationToggle, InvertedValue) == 0x000020, "Member 'FInputInformationToggle::InvertedValue' has a wrong offset!");
static_assert(offsetof(FInputInformationToggle, InvertedValueGamepad) == 0x000024, "Member 'FInputInformationToggle::InvertedValueGamepad' has a wrong offset!");
static_assert(offsetof(FInputInformationToggle, ScaleSerializationName) == 0x000028, "Member 'FInputInformationToggle::ScaleSerializationName' has a wrong offset!");
static_assert(offsetof(FInputInformationToggle, DefaultValue) == 0x000030, "Member 'FInputInformationToggle::DefaultValue' has a wrong offset!");

// ScriptStruct SCT.InputSavedAction
// 0x0050 (0x0050 - 0x0000)
struct FInputSavedAction final
{
public:
	struct FInputActionKeyMapping                 KeyboardKey;                                       // 0x0000(0x0028)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	struct FInputActionKeyMapping                 GamepadKey;                                        // 0x0028(0x0028)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
};
static_assert(alignof(FInputSavedAction) == 0x000008, "Wrong alignment on FInputSavedAction");
static_assert(sizeof(FInputSavedAction) == 0x000050, "Wrong size on FInputSavedAction");
static_assert(offsetof(FInputSavedAction, KeyboardKey) == 0x000000, "Member 'FInputSavedAction::KeyboardKey' has a wrong offset!");
static_assert(offsetof(FInputSavedAction, GamepadKey) == 0x000028, "Member 'FInputSavedAction::GamepadKey' has a wrong offset!");

// ScriptStruct SCT.PowerDetails
// 0x0048 (0x0048 - 0x0000)
struct FPowerDetails
{
public:
	class FText                                   Name;                                              // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0020(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         CurrentStackCount;                                 // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumStackCount;                                 // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPower*                                 Power;                                             // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPowerDetails) == 0x000008, "Wrong alignment on FPowerDetails");
static_assert(sizeof(FPowerDetails) == 0x000048, "Wrong size on FPowerDetails");
static_assert(offsetof(FPowerDetails, Name) == 0x000000, "Member 'FPowerDetails::Name' has a wrong offset!");
static_assert(offsetof(FPowerDetails, Icon) == 0x000018, "Member 'FPowerDetails::Icon' has a wrong offset!");
static_assert(offsetof(FPowerDetails, Description) == 0x000020, "Member 'FPowerDetails::Description' has a wrong offset!");
static_assert(offsetof(FPowerDetails, CurrentStackCount) == 0x000038, "Member 'FPowerDetails::CurrentStackCount' has a wrong offset!");
static_assert(offsetof(FPowerDetails, MaximumStackCount) == 0x00003C, "Member 'FPowerDetails::MaximumStackCount' has a wrong offset!");
static_assert(offsetof(FPowerDetails, Power) == 0x000040, "Member 'FPowerDetails::Power' has a wrong offset!");

// ScriptStruct SCT.ItemDetails
// 0x0008 (0x0050 - 0x0048)
struct FItemDetails final : public FPowerDetails
{
public:
	bool                                          IsPassive;                                         // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnique;                                          // 0x0049(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInventorySlotID                              SlotId;                                            // 0x004A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemDetails) == 0x000008, "Wrong alignment on FItemDetails");
static_assert(sizeof(FItemDetails) == 0x000050, "Wrong size on FItemDetails");
static_assert(offsetof(FItemDetails, IsPassive) == 0x000048, "Member 'FItemDetails::IsPassive' has a wrong offset!");
static_assert(offsetof(FItemDetails, IsUnique) == 0x000049, "Member 'FItemDetails::IsUnique' has a wrong offset!");
static_assert(offsetof(FItemDetails, SlotId) == 0x00004A, "Member 'FItemDetails::SlotId' has a wrong offset!");

// ScriptStruct SCT.MatchmakerLanguageDatum
// 0x0038 (0x0038 - 0x0000)
struct FMatchmakerLanguageDatum final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   PartyNotifDisplayName;                             // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchmakerLanguageDatum) == 0x000008, "Wrong alignment on FMatchmakerLanguageDatum");
static_assert(sizeof(FMatchmakerLanguageDatum) == 0x000038, "Wrong size on FMatchmakerLanguageDatum");
static_assert(offsetof(FMatchmakerLanguageDatum, DisplayName) == 0x000000, "Member 'FMatchmakerLanguageDatum::DisplayName' has a wrong offset!");
static_assert(offsetof(FMatchmakerLanguageDatum, PartyNotifDisplayName) == 0x000018, "Member 'FMatchmakerLanguageDatum::PartyNotifDisplayName' has a wrong offset!");
static_assert(offsetof(FMatchmakerLanguageDatum, Order) == 0x000030, "Member 'FMatchmakerLanguageDatum::Order' has a wrong offset!");

// ScriptStruct SCT.PassengerLogInformation
// 0x0028 (0x0028 - 0x0000)
struct FPassengerLogInformation final
{
public:
	class FText                                   Description;                                       // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 Targets;                                           // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPassengerLogInformation) == 0x000008, "Wrong alignment on FPassengerLogInformation");
static_assert(sizeof(FPassengerLogInformation) == 0x000028, "Wrong size on FPassengerLogInformation");
static_assert(offsetof(FPassengerLogInformation, Description) == 0x000000, "Member 'FPassengerLogInformation::Description' has a wrong offset!");
static_assert(offsetof(FPassengerLogInformation, Targets) == 0x000018, "Member 'FPassengerLogInformation::Targets' has a wrong offset!");

// ScriptStruct SCT.SecretPlayerInformation
// 0x0080 (0x0080 - 0x0000)
struct FSecretPlayerInformation final
{
public:
	EPlayerFaction                                Faction;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFate                                         Fate;                                              // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScore                                 Score;                                             // 0x0004(0x0020)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, int32>                      ScoreEntries;                                      // 0x0028(0x0050)(BlueprintVisible, BlueprintReadOnly, RepSkip, NativeAccessSpecifierPublic)
	class UAgendaObject*                          Agenda;                                            // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSecretPlayerInformation) == 0x000008, "Wrong alignment on FSecretPlayerInformation");
static_assert(sizeof(FSecretPlayerInformation) == 0x000080, "Wrong size on FSecretPlayerInformation");
static_assert(offsetof(FSecretPlayerInformation, Faction) == 0x000000, "Member 'FSecretPlayerInformation::Faction' has a wrong offset!");
static_assert(offsetof(FSecretPlayerInformation, Fate) == 0x000001, "Member 'FSecretPlayerInformation::Fate' has a wrong offset!");
static_assert(offsetof(FSecretPlayerInformation, Score) == 0x000004, "Member 'FSecretPlayerInformation::Score' has a wrong offset!");
static_assert(offsetof(FSecretPlayerInformation, ScoreEntries) == 0x000028, "Member 'FSecretPlayerInformation::ScoreEntries' has a wrong offset!");
static_assert(offsetof(FSecretPlayerInformation, Agenda) == 0x000078, "Member 'FSecretPlayerInformation::Agenda' has a wrong offset!");

// ScriptStruct SCT.PersonoidInformationPlayerData
// 0x0088 (0x0088 - 0x0000)
struct FPersonoidInformationPlayerData final
{
public:
	int32                                         PlayerId;                                          // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSecretPlayerInformation               SecretInformation;                                 // 0x0008(0x0080)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPersonoidInformationPlayerData) == 0x000008, "Wrong alignment on FPersonoidInformationPlayerData");
static_assert(sizeof(FPersonoidInformationPlayerData) == 0x000088, "Wrong size on FPersonoidInformationPlayerData");
static_assert(offsetof(FPersonoidInformationPlayerData, PlayerId) == 0x000000, "Member 'FPersonoidInformationPlayerData::PlayerId' has a wrong offset!");
static_assert(offsetof(FPersonoidInformationPlayerData, SecretInformation) == 0x000008, "Member 'FPersonoidInformationPlayerData::SecretInformation' has a wrong offset!");

// ScriptStruct SCT.SeamlessTravelPowerDetails
// 0x0008 (0x0008 - 0x0000)
struct FSeamlessTravelPowerDetails final
{
public:
	int32                                         StackSize;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputID;                                           // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeamlessTravelPowerDetails) == 0x000004, "Wrong alignment on FSeamlessTravelPowerDetails");
static_assert(sizeof(FSeamlessTravelPowerDetails) == 0x000008, "Wrong size on FSeamlessTravelPowerDetails");
static_assert(offsetof(FSeamlessTravelPowerDetails, StackSize) == 0x000000, "Member 'FSeamlessTravelPowerDetails::StackSize' has a wrong offset!");
static_assert(offsetof(FSeamlessTravelPowerDetails, InputID) == 0x000004, "Member 'FSeamlessTravelPowerDetails::InputID' has a wrong offset!");

// ScriptStruct SCT.PlayerData
// 0x01E0 (0x01E0 - 0x0000)
struct FPlayerData final
{
public:
	struct FLinearColor                           IdentificationColor;                               // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerId;                                          // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0018(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SteamID;                                           // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PSNID;                                             // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccelByteId;                                       // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunningOnPS5;                                     // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 XboxLiveID;                                        // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class UTransitionDataEntry*, class UObject*> LocalUserDefinedData;                              // 0x0070(0x0050)(NativeAccessSpecifierPublic)
	TMap<TSubclassOf<class UPower>, struct FSeamlessTravelPowerDetails> Powers;                                            // 0x00C0(0x0050)(NativeAccessSpecifierPublic)
	TArray<struct FCachedItemSlotData>            CachedItemSlots;                                   // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UPower>                     UniquePower;                                       // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 CharacterVariant;                                  // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 HumanoidVariant;                                   // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 UpVotedIDs;                                        // 0x0138(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 DownVotedIDs;                                      // 0x0148(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         TimesTravelled;                                    // 0x0158(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15C[0x4];                                      // 0x015C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSecretPlayerInformation               SecretInformation;                                 // 0x0160(0x0080)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerData) == 0x000008, "Wrong alignment on FPlayerData");
static_assert(sizeof(FPlayerData) == 0x0001E0, "Wrong size on FPlayerData");
static_assert(offsetof(FPlayerData, IdentificationColor) == 0x000000, "Member 'FPlayerData::IdentificationColor' has a wrong offset!");
static_assert(offsetof(FPlayerData, PlayerId) == 0x000010, "Member 'FPlayerData::PlayerId' has a wrong offset!");
static_assert(offsetof(FPlayerData, Name) == 0x000018, "Member 'FPlayerData::Name' has a wrong offset!");
static_assert(offsetof(FPlayerData, SteamID) == 0x000028, "Member 'FPlayerData::SteamID' has a wrong offset!");
static_assert(offsetof(FPlayerData, PSNID) == 0x000038, "Member 'FPlayerData::PSNID' has a wrong offset!");
static_assert(offsetof(FPlayerData, AccelByteId) == 0x000048, "Member 'FPlayerData::AccelByteId' has a wrong offset!");
static_assert(offsetof(FPlayerData, bRunningOnPS5) == 0x000058, "Member 'FPlayerData::bRunningOnPS5' has a wrong offset!");
static_assert(offsetof(FPlayerData, XboxLiveID) == 0x000060, "Member 'FPlayerData::XboxLiveID' has a wrong offset!");
static_assert(offsetof(FPlayerData, LocalUserDefinedData) == 0x000070, "Member 'FPlayerData::LocalUserDefinedData' has a wrong offset!");
static_assert(offsetof(FPlayerData, Powers) == 0x0000C0, "Member 'FPlayerData::Powers' has a wrong offset!");
static_assert(offsetof(FPlayerData, CachedItemSlots) == 0x000110, "Member 'FPlayerData::CachedItemSlots' has a wrong offset!");
static_assert(offsetof(FPlayerData, UniquePower) == 0x000120, "Member 'FPlayerData::UniquePower' has a wrong offset!");
static_assert(offsetof(FPlayerData, CharacterVariant) == 0x000128, "Member 'FPlayerData::CharacterVariant' has a wrong offset!");
static_assert(offsetof(FPlayerData, HumanoidVariant) == 0x000130, "Member 'FPlayerData::HumanoidVariant' has a wrong offset!");
static_assert(offsetof(FPlayerData, UpVotedIDs) == 0x000138, "Member 'FPlayerData::UpVotedIDs' has a wrong offset!");
static_assert(offsetof(FPlayerData, DownVotedIDs) == 0x000148, "Member 'FPlayerData::DownVotedIDs' has a wrong offset!");
static_assert(offsetof(FPlayerData, TimesTravelled) == 0x000158, "Member 'FPlayerData::TimesTravelled' has a wrong offset!");
static_assert(offsetof(FPlayerData, SecretInformation) == 0x000160, "Member 'FPlayerData::SecretInformation' has a wrong offset!");

// ScriptStruct SCT.PowerInitializationSpec
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x04) FPowerInitializationSpec final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPowerInitializationSpec) == 0x000004, "Wrong alignment on FPowerInitializationSpec");
static_assert(sizeof(FPowerInitializationSpec) == 0x000010, "Wrong size on FPowerInitializationSpec");

// ScriptStruct SCT.PowerRuntimeData
// 0x0008 (0x0008 - 0x0000)
struct FPowerRuntimeData final
{
public:
	float                                         LastActivatedTime;                                 // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ValidData;                                         // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPowerRuntimeData) == 0x000004, "Wrong alignment on FPowerRuntimeData");
static_assert(sizeof(FPowerRuntimeData) == 0x000008, "Wrong size on FPowerRuntimeData");
static_assert(offsetof(FPowerRuntimeData, LastActivatedTime) == 0x000000, "Member 'FPowerRuntimeData::LastActivatedTime' has a wrong offset!");
static_assert(offsetof(FPowerRuntimeData, ValidData) == 0x000004, "Member 'FPowerRuntimeData::ValidData' has a wrong offset!");

// ScriptStruct SCT.PS5GameStatsCommandData
// 0x0008 (0x0008 - 0x0000)
struct FPS5GameStatsCommandData final
{
public:
	class FName                                   StatName;                                          // 0x0000(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPS5GameStatsCommandData) == 0x000004, "Wrong alignment on FPS5GameStatsCommandData");
static_assert(sizeof(FPS5GameStatsCommandData) == 0x000008, "Wrong size on FPS5GameStatsCommandData");
static_assert(offsetof(FPS5GameStatsCommandData, StatName) == 0x000000, "Member 'FPS5GameStatsCommandData::StatName' has a wrong offset!");

// ScriptStruct SCT.PS5MatchControllerClientState
// 0x0008 (0x0008 - 0x0000)
struct FPS5MatchControllerClientState final
{
public:
	EPS5MatchClientState                          ClientState;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRateLimited;                                    // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastRateLimitTimeS;                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPS5MatchControllerClientState) == 0x000004, "Wrong alignment on FPS5MatchControllerClientState");
static_assert(sizeof(FPS5MatchControllerClientState) == 0x000008, "Wrong size on FPS5MatchControllerClientState");
static_assert(offsetof(FPS5MatchControllerClientState, ClientState) == 0x000000, "Member 'FPS5MatchControllerClientState::ClientState' has a wrong offset!");
static_assert(offsetof(FPS5MatchControllerClientState, bIsRateLimited) == 0x000001, "Member 'FPS5MatchControllerClientState::bIsRateLimited' has a wrong offset!");
static_assert(offsetof(FPS5MatchControllerClientState, LastRateLimitTimeS) == 0x000004, "Member 'FPS5MatchControllerClientState::LastRateLimitTimeS' has a wrong offset!");

// ScriptStruct SCT.PS5MatchControllerClientStateData
// 0x0020 (0x0020 - 0x0000)
struct FPS5MatchControllerClientStateData final
{
public:
	TArray<int32>                                 ClientIDs;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPS5MatchControllerClientState> ClientStates;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPS5MatchControllerClientStateData) == 0x000008, "Wrong alignment on FPS5MatchControllerClientStateData");
static_assert(sizeof(FPS5MatchControllerClientStateData) == 0x000020, "Wrong size on FPS5MatchControllerClientStateData");
static_assert(offsetof(FPS5MatchControllerClientStateData, ClientIDs) == 0x000000, "Member 'FPS5MatchControllerClientStateData::ClientIDs' has a wrong offset!");
static_assert(offsetof(FPS5MatchControllerClientStateData, ClientStates) == 0x000010, "Member 'FPS5MatchControllerClientStateData::ClientStates' has a wrong offset!");

// ScriptStruct SCT.SkillDetails
// 0x0008 (0x0050 - 0x0048)
struct FSkillDetails final : public FPowerDetails
{
public:
	bool                                          IsShown;                                           // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSkillDetails) == 0x000008, "Wrong alignment on FSkillDetails");
static_assert(sizeof(FSkillDetails) == 0x000050, "Wrong size on FSkillDetails");
static_assert(offsetof(FSkillDetails, IsShown) == 0x000048, "Member 'FSkillDetails::IsShown' has a wrong offset!");

// ScriptStruct SCT.CloudCustomizationContainer
// 0x0001 (0x0001 - 0x0000)
struct FCloudCustomizationContainer final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCloudCustomizationContainer) == 0x000001, "Wrong alignment on FCloudCustomizationContainer");
static_assert(sizeof(FCloudCustomizationContainer) == 0x000001, "Wrong size on FCloudCustomizationContainer");

// ScriptStruct SCT.WidgetOrganizerEntryValue
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FWidgetOrganizerEntryValue final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWidgetOrganizerEntryValue) == 0x000008, "Wrong alignment on FWidgetOrganizerEntryValue");
static_assert(sizeof(FWidgetOrganizerEntryValue) == 0x000010, "Wrong size on FWidgetOrganizerEntryValue");

// ScriptStruct SCT.XboxGameSessionControllerClientState
// 0x0008 (0x0008 - 0x0000)
struct FXboxGameSessionControllerClientState final
{
public:
	EXboxGameSessionClientState                   ClientState;                                       // 0x0000(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRateLimited;                                    // 0x0001(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LastRateLimitTimeS;                                // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXboxGameSessionControllerClientState) == 0x000004, "Wrong alignment on FXboxGameSessionControllerClientState");
static_assert(sizeof(FXboxGameSessionControllerClientState) == 0x000008, "Wrong size on FXboxGameSessionControllerClientState");
static_assert(offsetof(FXboxGameSessionControllerClientState, ClientState) == 0x000000, "Member 'FXboxGameSessionControllerClientState::ClientState' has a wrong offset!");
static_assert(offsetof(FXboxGameSessionControllerClientState, bIsRateLimited) == 0x000001, "Member 'FXboxGameSessionControllerClientState::bIsRateLimited' has a wrong offset!");
static_assert(offsetof(FXboxGameSessionControllerClientState, LastRateLimitTimeS) == 0x000004, "Member 'FXboxGameSessionControllerClientState::LastRateLimitTimeS' has a wrong offset!");

// ScriptStruct SCT.XboxGameSessionControllerClientStateData
// 0x0020 (0x0020 - 0x0000)
struct FXboxGameSessionControllerClientStateData final
{
public:
	TArray<int32>                                 ClientIDs;                                         // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FXboxGameSessionControllerClientState> ClientStates;                                      // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FXboxGameSessionControllerClientStateData) == 0x000008, "Wrong alignment on FXboxGameSessionControllerClientStateData");
static_assert(sizeof(FXboxGameSessionControllerClientStateData) == 0x000020, "Wrong size on FXboxGameSessionControllerClientStateData");
static_assert(offsetof(FXboxGameSessionControllerClientStateData, ClientIDs) == 0x000000, "Member 'FXboxGameSessionControllerClientStateData::ClientIDs' has a wrong offset!");
static_assert(offsetof(FXboxGameSessionControllerClientStateData, ClientStates) == 0x000010, "Member 'FXboxGameSessionControllerClientStateData::ClientStates' has a wrong offset!");

// ScriptStruct SCT.XboxGameSessionCommandData
// 0x0030 (0x0030 - 0x0000)
struct FXboxGameSessionCommandData final
{
public:
	class FString                                 GameSessionID;                                     // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchEndData                          MatchEndData;                                      // 0x0010(0x0018)(NativeAccessSpecifierPublic)
	bool                                          bHasRateLimitError;                                // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FXboxGameSessionCommandData) == 0x000008, "Wrong alignment on FXboxGameSessionCommandData");
static_assert(sizeof(FXboxGameSessionCommandData) == 0x000030, "Wrong size on FXboxGameSessionCommandData");
static_assert(offsetof(FXboxGameSessionCommandData, GameSessionID) == 0x000000, "Member 'FXboxGameSessionCommandData::GameSessionID' has a wrong offset!");
static_assert(offsetof(FXboxGameSessionCommandData, MatchEndData) == 0x000010, "Member 'FXboxGameSessionCommandData::MatchEndData' has a wrong offset!");
static_assert(offsetof(FXboxGameSessionCommandData, bHasRateLimitError) == 0x000028, "Member 'FXboxGameSessionCommandData::bHasRateLimitError' has a wrong offset!");

// ScriptStruct SCT.XboxUserPrivilegeData
// 0x0028 (0x0028 - 0x0000)
struct alignas(0x08) FXboxUserPrivilegeData final
{
public:
	uint8                                         Pad_0[0x28];                                       // 0x0000(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FXboxUserPrivilegeData) == 0x000008, "Wrong alignment on FXboxUserPrivilegeData");
static_assert(sizeof(FXboxUserPrivilegeData) == 0x000028, "Wrong size on FXboxUserPrivilegeData");

// ScriptStruct SCT.XboxUserPrivilegeTargetUserData
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FXboxUserPrivilegeTargetUserData final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FXboxUserPrivilegeTargetUserData) == 0x000008, "Wrong alignment on FXboxUserPrivilegeTargetUserData");
static_assert(sizeof(FXboxUserPrivilegeTargetUserData) == 0x000018, "Wrong size on FXboxUserPrivilegeTargetUserData");

}

