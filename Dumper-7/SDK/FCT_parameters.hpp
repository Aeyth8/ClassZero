#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FCT

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "FCT_structs.hpp"
#include "Slate_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK::Params
{

// Function FCT.ClientEntryPC.RegionSelectionAllowed
// 0x0001 (0x0001 - 0x0000)
struct ClientEntryPC_RegionSelectionAllowed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientEntryPC_RegionSelectionAllowed) == 0x000001, "Wrong alignment on ClientEntryPC_RegionSelectionAllowed");
static_assert(sizeof(ClientEntryPC_RegionSelectionAllowed) == 0x000001, "Wrong size on ClientEntryPC_RegionSelectionAllowed");
static_assert(offsetof(ClientEntryPC_RegionSelectionAllowed, ReturnValue) == 0x000000, "Member 'ClientEntryPC_RegionSelectionAllowed::ReturnValue' has a wrong offset!");

// Function FCT.ClientEntryPC.SetDesiredRegion
// 0x0002 (0x0002 - 0x0000)
struct ClientEntryPC_SetDesiredRegion final
{
public:
	bool                                          InChinaRegion;                                     // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientEntryPC_SetDesiredRegion) == 0x000001, "Wrong alignment on ClientEntryPC_SetDesiredRegion");
static_assert(sizeof(ClientEntryPC_SetDesiredRegion) == 0x000002, "Wrong size on ClientEntryPC_SetDesiredRegion");
static_assert(offsetof(ClientEntryPC_SetDesiredRegion, InChinaRegion) == 0x000000, "Member 'ClientEntryPC_SetDesiredRegion::InChinaRegion' has a wrong offset!");
static_assert(offsetof(ClientEntryPC_SetDesiredRegion, ReturnValue) == 0x000001, "Member 'ClientEntryPC_SetDesiredRegion::ReturnValue' has a wrong offset!");

// Function FCT.ClientEntryPC.SetUseAWSLocal
// 0x0001 (0x0001 - 0x0000)
struct ClientEntryPC_SetUseAWSLocal final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ClientEntryPC_SetUseAWSLocal) == 0x000001, "Wrong alignment on ClientEntryPC_SetUseAWSLocal");
static_assert(sizeof(ClientEntryPC_SetUseAWSLocal) == 0x000001, "Wrong size on ClientEntryPC_SetUseAWSLocal");
static_assert(offsetof(ClientEntryPC_SetUseAWSLocal, Enable) == 0x000000, "Member 'ClientEntryPC_SetUseAWSLocal::Enable' has a wrong offset!");

// Function FCT.FCTGameplayStatics.PlayMenuApplyChangeSound
// 0x0008 (0x0008 - 0x0000)
struct FCTGameplayStatics_PlayMenuApplyChangeSound final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCTGameplayStatics_PlayMenuApplyChangeSound) == 0x000008, "Wrong alignment on FCTGameplayStatics_PlayMenuApplyChangeSound");
static_assert(sizeof(FCTGameplayStatics_PlayMenuApplyChangeSound) == 0x000008, "Wrong size on FCTGameplayStatics_PlayMenuApplyChangeSound");
static_assert(offsetof(FCTGameplayStatics_PlayMenuApplyChangeSound, WorldContextObject) == 0x000000, "Member 'FCTGameplayStatics_PlayMenuApplyChangeSound::WorldContextObject' has a wrong offset!");

// Function FCT.FCTGameplayStatics.PlayMenuClickSound
// 0x0008 (0x0008 - 0x0000)
struct FCTGameplayStatics_PlayMenuClickSound final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCTGameplayStatics_PlayMenuClickSound) == 0x000008, "Wrong alignment on FCTGameplayStatics_PlayMenuClickSound");
static_assert(sizeof(FCTGameplayStatics_PlayMenuClickSound) == 0x000008, "Wrong size on FCTGameplayStatics_PlayMenuClickSound");
static_assert(offsetof(FCTGameplayStatics_PlayMenuClickSound, WorldContextObject) == 0x000000, "Member 'FCTGameplayStatics_PlayMenuClickSound::WorldContextObject' has a wrong offset!");

// Function FCT.FCTGameplayStatics.PlayMenuHoveredSound
// 0x0008 (0x0008 - 0x0000)
struct FCTGameplayStatics_PlayMenuHoveredSound final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCTGameplayStatics_PlayMenuHoveredSound) == 0x000008, "Wrong alignment on FCTGameplayStatics_PlayMenuHoveredSound");
static_assert(sizeof(FCTGameplayStatics_PlayMenuHoveredSound) == 0x000008, "Wrong size on FCTGameplayStatics_PlayMenuHoveredSound");
static_assert(offsetof(FCTGameplayStatics_PlayMenuHoveredSound, WorldContextObject) == 0x000000, "Member 'FCTGameplayStatics_PlayMenuHoveredSound::WorldContextObject' has a wrong offset!");

// Function FCT.FCTGameplayStatics.PlayMenuPressedSound
// 0x0008 (0x0008 - 0x0000)
struct FCTGameplayStatics_PlayMenuPressedSound final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCTGameplayStatics_PlayMenuPressedSound) == 0x000008, "Wrong alignment on FCTGameplayStatics_PlayMenuPressedSound");
static_assert(sizeof(FCTGameplayStatics_PlayMenuPressedSound) == 0x000008, "Wrong size on FCTGameplayStatics_PlayMenuPressedSound");
static_assert(offsetof(FCTGameplayStatics_PlayMenuPressedSound, WorldContextObject) == 0x000000, "Member 'FCTGameplayStatics_PlayMenuPressedSound::WorldContextObject' has a wrong offset!");

// Function FCT.FCTGameplayStatics.PlayMenuReleasedSound
// 0x0008 (0x0008 - 0x0000)
struct FCTGameplayStatics_PlayMenuReleasedSound final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCTGameplayStatics_PlayMenuReleasedSound) == 0x000008, "Wrong alignment on FCTGameplayStatics_PlayMenuReleasedSound");
static_assert(sizeof(FCTGameplayStatics_PlayMenuReleasedSound) == 0x000008, "Wrong size on FCTGameplayStatics_PlayMenuReleasedSound");
static_assert(offsetof(FCTGameplayStatics_PlayMenuReleasedSound, WorldContextObject) == 0x000000, "Member 'FCTGameplayStatics_PlayMenuReleasedSound::WorldContextObject' has a wrong offset!");

// Function FCT.FCTGameplayStatics.PlayMenuTypeLetterDudSound
// 0x0008 (0x0008 - 0x0000)
struct FCTGameplayStatics_PlayMenuTypeLetterDudSound final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCTGameplayStatics_PlayMenuTypeLetterDudSound) == 0x000008, "Wrong alignment on FCTGameplayStatics_PlayMenuTypeLetterDudSound");
static_assert(sizeof(FCTGameplayStatics_PlayMenuTypeLetterDudSound) == 0x000008, "Wrong size on FCTGameplayStatics_PlayMenuTypeLetterDudSound");
static_assert(offsetof(FCTGameplayStatics_PlayMenuTypeLetterDudSound, WorldContextObject) == 0x000000, "Member 'FCTGameplayStatics_PlayMenuTypeLetterDudSound::WorldContextObject' has a wrong offset!");

// Function FCT.FCTGameplayStatics.PlayMenuTypeLetterSound
// 0x0008 (0x0008 - 0x0000)
struct FCTGameplayStatics_PlayMenuTypeLetterSound final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCTGameplayStatics_PlayMenuTypeLetterSound) == 0x000008, "Wrong alignment on FCTGameplayStatics_PlayMenuTypeLetterSound");
static_assert(sizeof(FCTGameplayStatics_PlayMenuTypeLetterSound) == 0x000008, "Wrong size on FCTGameplayStatics_PlayMenuTypeLetterSound");
static_assert(offsetof(FCTGameplayStatics_PlayMenuTypeLetterSound, WorldContextObject) == 0x000000, "Member 'FCTGameplayStatics_PlayMenuTypeLetterSound::WorldContextObject' has a wrong offset!");

// Function FCT.FCTGameplayStatics.PlayMenuUnhoveredSound
// 0x0008 (0x0008 - 0x0000)
struct FCTGameplayStatics_PlayMenuUnhoveredSound final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCTGameplayStatics_PlayMenuUnhoveredSound) == 0x000008, "Wrong alignment on FCTGameplayStatics_PlayMenuUnhoveredSound");
static_assert(sizeof(FCTGameplayStatics_PlayMenuUnhoveredSound) == 0x000008, "Wrong size on FCTGameplayStatics_PlayMenuUnhoveredSound");
static_assert(offsetof(FCTGameplayStatics_PlayMenuUnhoveredSound, WorldContextObject) == 0x000000, "Member 'FCTGameplayStatics_PlayMenuUnhoveredSound::WorldContextObject' has a wrong offset!");

// Function FCT.FCTInputKeySelector.ActionMappingsByName
// 0x0018 (0x0018 - 0x0000)
struct FCTInputKeySelector_ActionMappingsByName final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInputActionKeyMapping>         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCTInputKeySelector_ActionMappingsByName) == 0x000008, "Wrong alignment on FCTInputKeySelector_ActionMappingsByName");
static_assert(sizeof(FCTInputKeySelector_ActionMappingsByName) == 0x000018, "Wrong size on FCTInputKeySelector_ActionMappingsByName");
static_assert(offsetof(FCTInputKeySelector_ActionMappingsByName, Name_0) == 0x000000, "Member 'FCTInputKeySelector_ActionMappingsByName::Name_0' has a wrong offset!");
static_assert(offsetof(FCTInputKeySelector_ActionMappingsByName, ReturnValue) == 0x000008, "Member 'FCTInputKeySelector_ActionMappingsByName::ReturnValue' has a wrong offset!");

// Function FCT.FCTInputKeySelector.AxisMappingsByName
// 0x0018 (0x0018 - 0x0000)
struct FCTInputKeySelector_AxisMappingsByName final
{
public:
	class FName                                   Name_0;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInputAxisKeyMapping>           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCTInputKeySelector_AxisMappingsByName) == 0x000008, "Wrong alignment on FCTInputKeySelector_AxisMappingsByName");
static_assert(sizeof(FCTInputKeySelector_AxisMappingsByName) == 0x000018, "Wrong size on FCTInputKeySelector_AxisMappingsByName");
static_assert(offsetof(FCTInputKeySelector_AxisMappingsByName, Name_0) == 0x000000, "Member 'FCTInputKeySelector_AxisMappingsByName::Name_0' has a wrong offset!");
static_assert(offsetof(FCTInputKeySelector_AxisMappingsByName, ReturnValue) == 0x000008, "Member 'FCTInputKeySelector_AxisMappingsByName::ReturnValue' has a wrong offset!");

// Function FCT.FCTInputKeySelector.LoadPlayerInputConfig
// 0x0001 (0x0001 - 0x0000)
struct FCTInputKeySelector_LoadPlayerInputConfig final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCTInputKeySelector_LoadPlayerInputConfig) == 0x000001, "Wrong alignment on FCTInputKeySelector_LoadPlayerInputConfig");
static_assert(sizeof(FCTInputKeySelector_LoadPlayerInputConfig) == 0x000001, "Wrong size on FCTInputKeySelector_LoadPlayerInputConfig");
static_assert(offsetof(FCTInputKeySelector_LoadPlayerInputConfig, ReturnValue) == 0x000000, "Member 'FCTInputKeySelector_LoadPlayerInputConfig::ReturnValue' has a wrong offset!");

// Function FCT.FCTInputKeySelector.MyKeySelected
// 0x0020 (0x0020 - 0x0000)
struct FCTInputKeySelector_MyKeySelected final
{
public:
	struct FInputChord                            Key;                                               // 0x0000(0x0020)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCTInputKeySelector_MyKeySelected) == 0x000008, "Wrong alignment on FCTInputKeySelector_MyKeySelected");
static_assert(sizeof(FCTInputKeySelector_MyKeySelected) == 0x000020, "Wrong size on FCTInputKeySelector_MyKeySelected");
static_assert(offsetof(FCTInputKeySelector_MyKeySelected, Key) == 0x000000, "Member 'FCTInputKeySelector_MyKeySelected::Key' has a wrong offset!");

// Function FCT.FCTInputKeySelector.SetActionInput
// 0x0050 (0x0050 - 0x0000)
struct FCTInputKeySelector_SetActionInput final
{
public:
	struct FInputActionKeyMapping                 OldMapping;                                        // 0x0000(0x0028)(Parm, NativeAccessSpecifierPublic)
	struct FInputChord                            Key;                                               // 0x0028(0x0020)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCTInputKeySelector_SetActionInput) == 0x000008, "Wrong alignment on FCTInputKeySelector_SetActionInput");
static_assert(sizeof(FCTInputKeySelector_SetActionInput) == 0x000050, "Wrong size on FCTInputKeySelector_SetActionInput");
static_assert(offsetof(FCTInputKeySelector_SetActionInput, OldMapping) == 0x000000, "Member 'FCTInputKeySelector_SetActionInput::OldMapping' has a wrong offset!");
static_assert(offsetof(FCTInputKeySelector_SetActionInput, Key) == 0x000028, "Member 'FCTInputKeySelector_SetActionInput::Key' has a wrong offset!");
static_assert(offsetof(FCTInputKeySelector_SetActionInput, ReturnValue) == 0x000048, "Member 'FCTInputKeySelector_SetActionInput::ReturnValue' has a wrong offset!");

// Function FCT.FCTInputKeySelector.SetAxisInput
// 0x0050 (0x0050 - 0x0000)
struct FCTInputKeySelector_SetAxisInput final
{
public:
	struct FInputAxisKeyMapping                   OldMapping;                                        // 0x0000(0x0028)(Parm, NativeAccessSpecifierPublic)
	struct FInputChord                            Key;                                               // 0x0028(0x0020)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0048(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCTInputKeySelector_SetAxisInput) == 0x000008, "Wrong alignment on FCTInputKeySelector_SetAxisInput");
static_assert(sizeof(FCTInputKeySelector_SetAxisInput) == 0x000050, "Wrong size on FCTInputKeySelector_SetAxisInput");
static_assert(offsetof(FCTInputKeySelector_SetAxisInput, OldMapping) == 0x000000, "Member 'FCTInputKeySelector_SetAxisInput::OldMapping' has a wrong offset!");
static_assert(offsetof(FCTInputKeySelector_SetAxisInput, Key) == 0x000028, "Member 'FCTInputKeySelector_SetAxisInput::Key' has a wrong offset!");
static_assert(offsetof(FCTInputKeySelector_SetAxisInput, ReturnValue) == 0x000048, "Member 'FCTInputKeySelector_SetAxisInput::ReturnValue' has a wrong offset!");

// Function FCT.FCT_GIS.GetInstallID
// 0x0010 (0x0010 - 0x0000)
struct FCT_GIS_GetInstallID final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCT_GIS_GetInstallID) == 0x000008, "Wrong alignment on FCT_GIS_GetInstallID");
static_assert(sizeof(FCT_GIS_GetInstallID) == 0x000010, "Wrong size on FCT_GIS_GetInstallID");
static_assert(offsetof(FCT_GIS_GetInstallID, ReturnValue) == 0x000000, "Member 'FCT_GIS_GetInstallID::ReturnValue' has a wrong offset!");

// Function FCT.GamepadScrollUtility.OnGamepadScroll
// 0x0004 (0x0004 - 0x0000)
struct GamepadScrollUtility_OnGamepadScroll final
{
public:
	float                                         ScrollValue;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GamepadScrollUtility_OnGamepadScroll) == 0x000004, "Wrong alignment on GamepadScrollUtility_OnGamepadScroll");
static_assert(sizeof(GamepadScrollUtility_OnGamepadScroll) == 0x000004, "Wrong size on GamepadScrollUtility_OnGamepadScroll");
static_assert(offsetof(GamepadScrollUtility_OnGamepadScroll, ScrollValue) == 0x000000, "Member 'GamepadScrollUtility_OnGamepadScroll::ScrollValue' has a wrong offset!");

// Function FCT.StaticInteractableMesh.ClickedServer
// 0x0008 (0x0008 - 0x0000)
struct StaticInteractableMesh_ClickedServer final
{
public:
	class APawn*                                  PressingPawn;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_ClickedServer) == 0x000008, "Wrong alignment on StaticInteractableMesh_ClickedServer");
static_assert(sizeof(StaticInteractableMesh_ClickedServer) == 0x000008, "Wrong size on StaticInteractableMesh_ClickedServer");
static_assert(offsetof(StaticInteractableMesh_ClickedServer, PressingPawn) == 0x000000, "Member 'StaticInteractableMesh_ClickedServer::PressingPawn' has a wrong offset!");

// Function FCT.StaticInteractableMesh.K2_ClickedOther
// 0x0008 (0x0008 - 0x0000)
struct StaticInteractableMesh_K2_ClickedOther final
{
public:
	class APawn*                                  PerformingPawn;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_K2_ClickedOther) == 0x000008, "Wrong alignment on StaticInteractableMesh_K2_ClickedOther");
static_assert(sizeof(StaticInteractableMesh_K2_ClickedOther) == 0x000008, "Wrong size on StaticInteractableMesh_K2_ClickedOther");
static_assert(offsetof(StaticInteractableMesh_K2_ClickedOther, PerformingPawn) == 0x000000, "Member 'StaticInteractableMesh_K2_ClickedOther::PerformingPawn' has a wrong offset!");

// Function FCT.StaticInteractableMesh.K2_ClickedServer
// 0x0008 (0x0008 - 0x0000)
struct StaticInteractableMesh_K2_ClickedServer final
{
public:
	class APawn*                                  PerformingPawn;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_K2_ClickedServer) == 0x000008, "Wrong alignment on StaticInteractableMesh_K2_ClickedServer");
static_assert(sizeof(StaticInteractableMesh_K2_ClickedServer) == 0x000008, "Wrong size on StaticInteractableMesh_K2_ClickedServer");
static_assert(offsetof(StaticInteractableMesh_K2_ClickedServer, PerformingPawn) == 0x000000, "Member 'StaticInteractableMesh_K2_ClickedServer::PerformingPawn' has a wrong offset!");

// Function FCT.StaticInteractableMesh.K2_HoldCompleteLocal
// 0x0008 (0x0008 - 0x0000)
struct StaticInteractableMesh_K2_HoldCompleteLocal final
{
public:
	class APawn*                                  PerformingPawn;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_K2_HoldCompleteLocal) == 0x000008, "Wrong alignment on StaticInteractableMesh_K2_HoldCompleteLocal");
static_assert(sizeof(StaticInteractableMesh_K2_HoldCompleteLocal) == 0x000008, "Wrong size on StaticInteractableMesh_K2_HoldCompleteLocal");
static_assert(offsetof(StaticInteractableMesh_K2_HoldCompleteLocal, PerformingPawn) == 0x000000, "Member 'StaticInteractableMesh_K2_HoldCompleteLocal::PerformingPawn' has a wrong offset!");

// Function FCT.StaticInteractableMesh.K2_HoldCompleteOther
// 0x0008 (0x0008 - 0x0000)
struct StaticInteractableMesh_K2_HoldCompleteOther final
{
public:
	class APawn*                                  PerformingPawn;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_K2_HoldCompleteOther) == 0x000008, "Wrong alignment on StaticInteractableMesh_K2_HoldCompleteOther");
static_assert(sizeof(StaticInteractableMesh_K2_HoldCompleteOther) == 0x000008, "Wrong size on StaticInteractableMesh_K2_HoldCompleteOther");
static_assert(offsetof(StaticInteractableMesh_K2_HoldCompleteOther, PerformingPawn) == 0x000000, "Member 'StaticInteractableMesh_K2_HoldCompleteOther::PerformingPawn' has a wrong offset!");

// Function FCT.StaticInteractableMesh.K2_HoldCompleteServer
// 0x0008 (0x0008 - 0x0000)
struct StaticInteractableMesh_K2_HoldCompleteServer final
{
public:
	class APawn*                                  PerformingPawn;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_K2_HoldCompleteServer) == 0x000008, "Wrong alignment on StaticInteractableMesh_K2_HoldCompleteServer");
static_assert(sizeof(StaticInteractableMesh_K2_HoldCompleteServer) == 0x000008, "Wrong size on StaticInteractableMesh_K2_HoldCompleteServer");
static_assert(offsetof(StaticInteractableMesh_K2_HoldCompleteServer, PerformingPawn) == 0x000000, "Member 'StaticInteractableMesh_K2_HoldCompleteServer::PerformingPawn' has a wrong offset!");

// Function FCT.StaticInteractableMesh.K2_PressedServer
// 0x0008 (0x0008 - 0x0000)
struct StaticInteractableMesh_K2_PressedServer final
{
public:
	class APawn*                                  PerformingPawn;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_K2_PressedServer) == 0x000008, "Wrong alignment on StaticInteractableMesh_K2_PressedServer");
static_assert(sizeof(StaticInteractableMesh_K2_PressedServer) == 0x000008, "Wrong size on StaticInteractableMesh_K2_PressedServer");
static_assert(offsetof(StaticInteractableMesh_K2_PressedServer, PerformingPawn) == 0x000000, "Member 'StaticInteractableMesh_K2_PressedServer::PerformingPawn' has a wrong offset!");

// Function FCT.StaticInteractableMesh.K2_ReleasedLocal
// 0x0004 (0x0004 - 0x0000)
struct StaticInteractableMesh_K2_ReleasedLocal final
{
public:
	float                                         TargetCenterNormalized;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_K2_ReleasedLocal) == 0x000004, "Wrong alignment on StaticInteractableMesh_K2_ReleasedLocal");
static_assert(sizeof(StaticInteractableMesh_K2_ReleasedLocal) == 0x000004, "Wrong size on StaticInteractableMesh_K2_ReleasedLocal");
static_assert(offsetof(StaticInteractableMesh_K2_ReleasedLocal, TargetCenterNormalized) == 0x000000, "Member 'StaticInteractableMesh_K2_ReleasedLocal::TargetCenterNormalized' has a wrong offset!");

// Function FCT.StaticInteractableMesh.K2_ReleasedOther
// 0x0004 (0x0004 - 0x0000)
struct StaticInteractableMesh_K2_ReleasedOther final
{
public:
	float                                         TargetCenterNormalized;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_K2_ReleasedOther) == 0x000004, "Wrong alignment on StaticInteractableMesh_K2_ReleasedOther");
static_assert(sizeof(StaticInteractableMesh_K2_ReleasedOther) == 0x000004, "Wrong size on StaticInteractableMesh_K2_ReleasedOther");
static_assert(offsetof(StaticInteractableMesh_K2_ReleasedOther, TargetCenterNormalized) == 0x000000, "Member 'StaticInteractableMesh_K2_ReleasedOther::TargetCenterNormalized' has a wrong offset!");

// Function FCT.StaticInteractableMesh.K2_ReleasedServer
// 0x0008 (0x0008 - 0x0000)
struct StaticInteractableMesh_K2_ReleasedServer final
{
public:
	class APawn*                                  PerformingPawn;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_K2_ReleasedServer) == 0x000008, "Wrong alignment on StaticInteractableMesh_K2_ReleasedServer");
static_assert(sizeof(StaticInteractableMesh_K2_ReleasedServer) == 0x000008, "Wrong size on StaticInteractableMesh_K2_ReleasedServer");
static_assert(offsetof(StaticInteractableMesh_K2_ReleasedServer, PerformingPawn) == 0x000000, "Member 'StaticInteractableMesh_K2_ReleasedServer::PerformingPawn' has a wrong offset!");

// Function FCT.StaticInteractableMesh.MulticastClick
// 0x0008 (0x0008 - 0x0000)
struct StaticInteractableMesh_MulticastClick final
{
public:
	class APawn*                                  PressingPawn;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_MulticastClick) == 0x000008, "Wrong alignment on StaticInteractableMesh_MulticastClick");
static_assert(sizeof(StaticInteractableMesh_MulticastClick) == 0x000008, "Wrong size on StaticInteractableMesh_MulticastClick");
static_assert(offsetof(StaticInteractableMesh_MulticastClick, PressingPawn) == 0x000000, "Member 'StaticInteractableMesh_MulticastClick::PressingPawn' has a wrong offset!");

// Function FCT.StaticInteractableMesh.MulticastCompleted
// 0x0008 (0x0008 - 0x0000)
struct StaticInteractableMesh_MulticastCompleted final
{
public:
	class APawn*                                  ReleasingPawn;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_MulticastCompleted) == 0x000008, "Wrong alignment on StaticInteractableMesh_MulticastCompleted");
static_assert(sizeof(StaticInteractableMesh_MulticastCompleted) == 0x000008, "Wrong size on StaticInteractableMesh_MulticastCompleted");
static_assert(offsetof(StaticInteractableMesh_MulticastCompleted, ReleasingPawn) == 0x000000, "Member 'StaticInteractableMesh_MulticastCompleted::ReleasingPawn' has a wrong offset!");

// Function FCT.StaticInteractableMesh.MulticastReleased
// 0x0010 (0x0010 - 0x0000)
struct StaticInteractableMesh_MulticastReleased final
{
public:
	class APawn*                                  ReleasingPawn;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TargetCenterNormalized;                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StaticInteractableMesh_MulticastReleased) == 0x000008, "Wrong alignment on StaticInteractableMesh_MulticastReleased");
static_assert(sizeof(StaticInteractableMesh_MulticastReleased) == 0x000010, "Wrong size on StaticInteractableMesh_MulticastReleased");
static_assert(offsetof(StaticInteractableMesh_MulticastReleased, ReleasingPawn) == 0x000000, "Member 'StaticInteractableMesh_MulticastReleased::ReleasingPawn' has a wrong offset!");
static_assert(offsetof(StaticInteractableMesh_MulticastReleased, TargetCenterNormalized) == 0x000008, "Member 'StaticInteractableMesh_MulticastReleased::TargetCenterNormalized' has a wrong offset!");

// Function FCT.StaticInteractableMesh.PressLocal
// 0x0004 (0x0004 - 0x0000)
struct StaticInteractableMesh_PressLocal final
{
public:
	float                                         LocalPressStamp;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_PressLocal) == 0x000004, "Wrong alignment on StaticInteractableMesh_PressLocal");
static_assert(sizeof(StaticInteractableMesh_PressLocal) == 0x000004, "Wrong size on StaticInteractableMesh_PressLocal");
static_assert(offsetof(StaticInteractableMesh_PressLocal, LocalPressStamp) == 0x000000, "Member 'StaticInteractableMesh_PressLocal::LocalPressStamp' has a wrong offset!");

// Function FCT.StaticInteractableMesh.PressServer
// 0x0010 (0x0010 - 0x0000)
struct StaticInteractableMesh_PressServer final
{
public:
	class APawn*                                  PressingPawn;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocalPressTimeStamp;                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Ping;                                              // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StaticInteractableMesh_PressServer) == 0x000008, "Wrong alignment on StaticInteractableMesh_PressServer");
static_assert(sizeof(StaticInteractableMesh_PressServer) == 0x000010, "Wrong size on StaticInteractableMesh_PressServer");
static_assert(offsetof(StaticInteractableMesh_PressServer, PressingPawn) == 0x000000, "Member 'StaticInteractableMesh_PressServer::PressingPawn' has a wrong offset!");
static_assert(offsetof(StaticInteractableMesh_PressServer, LocalPressTimeStamp) == 0x000008, "Member 'StaticInteractableMesh_PressServer::LocalPressTimeStamp' has a wrong offset!");
static_assert(offsetof(StaticInteractableMesh_PressServer, Ping) == 0x00000C, "Member 'StaticInteractableMesh_PressServer::Ping' has a wrong offset!");

// Function FCT.StaticInteractableMesh.ReleaseLocal
// 0x0004 (0x0004 - 0x0000)
struct StaticInteractableMesh_ReleaseLocal final
{
public:
	float                                         LocalReleaseStamp;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_ReleaseLocal) == 0x000004, "Wrong alignment on StaticInteractableMesh_ReleaseLocal");
static_assert(sizeof(StaticInteractableMesh_ReleaseLocal) == 0x000004, "Wrong size on StaticInteractableMesh_ReleaseLocal");
static_assert(offsetof(StaticInteractableMesh_ReleaseLocal, LocalReleaseStamp) == 0x000000, "Member 'StaticInteractableMesh_ReleaseLocal::LocalReleaseStamp' has a wrong offset!");

// Function FCT.StaticInteractableMesh.ReleaseServer
// 0x0004 (0x0004 - 0x0000)
struct StaticInteractableMesh_ReleaseServer final
{
public:
	float                                         LocalReleaseTimeStamp;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_ReleaseServer) == 0x000004, "Wrong alignment on StaticInteractableMesh_ReleaseServer");
static_assert(sizeof(StaticInteractableMesh_ReleaseServer) == 0x000004, "Wrong size on StaticInteractableMesh_ReleaseServer");
static_assert(offsetof(StaticInteractableMesh_ReleaseServer, LocalReleaseTimeStamp) == 0x000000, "Member 'StaticInteractableMesh_ReleaseServer::LocalReleaseTimeStamp' has a wrong offset!");

// Function FCT.StaticInteractableMesh.SetIsAvailable
// 0x0001 (0x0001 - 0x0000)
struct StaticInteractableMesh_SetIsAvailable final
{
public:
	bool                                          NewIsAvailable;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticInteractableMesh_SetIsAvailable) == 0x000001, "Wrong alignment on StaticInteractableMesh_SetIsAvailable");
static_assert(sizeof(StaticInteractableMesh_SetIsAvailable) == 0x000001, "Wrong size on StaticInteractableMesh_SetIsAvailable");
static_assert(offsetof(StaticInteractableMesh_SetIsAvailable, NewIsAvailable) == 0x000000, "Member 'StaticInteractableMesh_SetIsAvailable::NewIsAvailable' has a wrong offset!");

// Function FCT.LanguageData.GetKeyAt
// 0x0018 (0x0018 - 0x0000)
struct LanguageData_GetKeyAt final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LanguageData_GetKeyAt) == 0x000008, "Wrong alignment on LanguageData_GetKeyAt");
static_assert(sizeof(LanguageData_GetKeyAt) == 0x000018, "Wrong size on LanguageData_GetKeyAt");
static_assert(offsetof(LanguageData_GetKeyAt, Index_0) == 0x000000, "Member 'LanguageData_GetKeyAt::Index_0' has a wrong offset!");
static_assert(offsetof(LanguageData_GetKeyAt, ReturnValue) == 0x000008, "Member 'LanguageData_GetKeyAt::ReturnValue' has a wrong offset!");

// Function FCT.LanguageData.GetKeyIndex
// 0x0018 (0x0018 - 0x0000)
struct LanguageData_GetKeyIndex final
{
public:
	class FString                                 Key;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LanguageData_GetKeyIndex) == 0x000008, "Wrong alignment on LanguageData_GetKeyIndex");
static_assert(sizeof(LanguageData_GetKeyIndex) == 0x000018, "Wrong size on LanguageData_GetKeyIndex");
static_assert(offsetof(LanguageData_GetKeyIndex, Key) == 0x000000, "Member 'LanguageData_GetKeyIndex::Key' has a wrong offset!");
static_assert(offsetof(LanguageData_GetKeyIndex, ReturnValue) == 0x000010, "Member 'LanguageData_GetKeyIndex::ReturnValue' has a wrong offset!");

// Function FCT.LanguageData.PopuplateComboBoxString
// 0x0008 (0x0008 - 0x0000)
struct LanguageData_PopuplateComboBoxString final
{
public:
	class UComboBoxString*                        InComboBoxString;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LanguageData_PopuplateComboBoxString) == 0x000008, "Wrong alignment on LanguageData_PopuplateComboBoxString");
static_assert(sizeof(LanguageData_PopuplateComboBoxString) == 0x000008, "Wrong size on LanguageData_PopuplateComboBoxString");
static_assert(offsetof(LanguageData_PopuplateComboBoxString, InComboBoxString) == 0x000000, "Member 'LanguageData_PopuplateComboBoxString::InComboBoxString' has a wrong offset!");

// Function FCT.MenuControllerGIS.AddChildMenu
// 0x0020 (0x0020 - 0x0000)
struct MenuControllerGIS_AddChildMenu final
{
public:
	class UUserWidget*                            Menu;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ParentMenu;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NonInteractable;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SetFocus;                                          // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelSlot*                             ReturnValue;                                       // 0x0018(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MenuControllerGIS_AddChildMenu) == 0x000008, "Wrong alignment on MenuControllerGIS_AddChildMenu");
static_assert(sizeof(MenuControllerGIS_AddChildMenu) == 0x000020, "Wrong size on MenuControllerGIS_AddChildMenu");
static_assert(offsetof(MenuControllerGIS_AddChildMenu, Menu) == 0x000000, "Member 'MenuControllerGIS_AddChildMenu::Menu' has a wrong offset!");
static_assert(offsetof(MenuControllerGIS_AddChildMenu, ParentMenu) == 0x000008, "Member 'MenuControllerGIS_AddChildMenu::ParentMenu' has a wrong offset!");
static_assert(offsetof(MenuControllerGIS_AddChildMenu, NonInteractable) == 0x000010, "Member 'MenuControllerGIS_AddChildMenu::NonInteractable' has a wrong offset!");
static_assert(offsetof(MenuControllerGIS_AddChildMenu, SetFocus) == 0x000011, "Member 'MenuControllerGIS_AddChildMenu::SetFocus' has a wrong offset!");
static_assert(offsetof(MenuControllerGIS_AddChildMenu, ReturnValue) == 0x000018, "Member 'MenuControllerGIS_AddChildMenu::ReturnValue' has a wrong offset!");

// Function FCT.MenuControllerGIS.AddMenu
// 0x0010 (0x0010 - 0x0000)
struct MenuControllerGIS_AddMenu final
{
public:
	class UUserWidget*                            Menu;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrder;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NonInteractable;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SetFocus;                                          // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MenuControllerGIS_AddMenu) == 0x000008, "Wrong alignment on MenuControllerGIS_AddMenu");
static_assert(sizeof(MenuControllerGIS_AddMenu) == 0x000010, "Wrong size on MenuControllerGIS_AddMenu");
static_assert(offsetof(MenuControllerGIS_AddMenu, Menu) == 0x000000, "Member 'MenuControllerGIS_AddMenu::Menu' has a wrong offset!");
static_assert(offsetof(MenuControllerGIS_AddMenu, ZOrder) == 0x000008, "Member 'MenuControllerGIS_AddMenu::ZOrder' has a wrong offset!");
static_assert(offsetof(MenuControllerGIS_AddMenu, NonInteractable) == 0x00000C, "Member 'MenuControllerGIS_AddMenu::NonInteractable' has a wrong offset!");
static_assert(offsetof(MenuControllerGIS_AddMenu, SetFocus) == 0x00000D, "Member 'MenuControllerGIS_AddMenu::SetFocus' has a wrong offset!");

// Function FCT.MenuControllerGIS.IsWidgetInActiveMenu
// 0x0010 (0x0010 - 0x0000)
struct MenuControllerGIS_IsWidgetInActiveMenu final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MenuControllerGIS_IsWidgetInActiveMenu) == 0x000008, "Wrong alignment on MenuControllerGIS_IsWidgetInActiveMenu");
static_assert(sizeof(MenuControllerGIS_IsWidgetInActiveMenu) == 0x000010, "Wrong size on MenuControllerGIS_IsWidgetInActiveMenu");
static_assert(offsetof(MenuControllerGIS_IsWidgetInActiveMenu, Widget) == 0x000000, "Member 'MenuControllerGIS_IsWidgetInActiveMenu::Widget' has a wrong offset!");
static_assert(offsetof(MenuControllerGIS_IsWidgetInActiveMenu, ReturnValue) == 0x000008, "Member 'MenuControllerGIS_IsWidgetInActiveMenu::ReturnValue' has a wrong offset!");

// Function FCT.MenuControllerGIS.IsWidgetInAnyMenu
// 0x0010 (0x0010 - 0x0000)
struct MenuControllerGIS_IsWidgetInAnyMenu final
{
public:
	class UWidget*                                Widget;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MenuControllerGIS_IsWidgetInAnyMenu) == 0x000008, "Wrong alignment on MenuControllerGIS_IsWidgetInAnyMenu");
static_assert(sizeof(MenuControllerGIS_IsWidgetInAnyMenu) == 0x000010, "Wrong size on MenuControllerGIS_IsWidgetInAnyMenu");
static_assert(offsetof(MenuControllerGIS_IsWidgetInAnyMenu, Widget) == 0x000000, "Member 'MenuControllerGIS_IsWidgetInAnyMenu::Widget' has a wrong offset!");
static_assert(offsetof(MenuControllerGIS_IsWidgetInAnyMenu, ReturnValue) == 0x000008, "Member 'MenuControllerGIS_IsWidgetInAnyMenu::ReturnValue' has a wrong offset!");

// Function FCT.MenuControllerGIS.OnLevelRemovedFromWorld
// 0x0010 (0x0010 - 0x0000)
struct MenuControllerGIS_OnLevelRemovedFromWorld final
{
public:
	class ULevel*                                 InLevel;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWorld*                                 InWorld;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MenuControllerGIS_OnLevelRemovedFromWorld) == 0x000008, "Wrong alignment on MenuControllerGIS_OnLevelRemovedFromWorld");
static_assert(sizeof(MenuControllerGIS_OnLevelRemovedFromWorld) == 0x000010, "Wrong size on MenuControllerGIS_OnLevelRemovedFromWorld");
static_assert(offsetof(MenuControllerGIS_OnLevelRemovedFromWorld, InLevel) == 0x000000, "Member 'MenuControllerGIS_OnLevelRemovedFromWorld::InLevel' has a wrong offset!");
static_assert(offsetof(MenuControllerGIS_OnLevelRemovedFromWorld, InWorld) == 0x000008, "Member 'MenuControllerGIS_OnLevelRemovedFromWorld::InWorld' has a wrong offset!");

// Function FCT.MenuControllerGIS.RemoveMenu
// 0x0008 (0x0008 - 0x0000)
struct MenuControllerGIS_RemoveMenu final
{
public:
	class UUserWidget*                            Menu;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MenuControllerGIS_RemoveMenu) == 0x000008, "Wrong alignment on MenuControllerGIS_RemoveMenu");
static_assert(sizeof(MenuControllerGIS_RemoveMenu) == 0x000008, "Wrong size on MenuControllerGIS_RemoveMenu");
static_assert(offsetof(MenuControllerGIS_RemoveMenu, Menu) == 0x000000, "Member 'MenuControllerGIS_RemoveMenu::Menu' has a wrong offset!");

// Function FCT.MenuControllerGIS.SetOverlayDialog
// 0x0010 (0x0010 - 0x0000)
struct MenuControllerGIS_SetOverlayDialog final
{
public:
	class UUserWidget*                            Menu;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ZOrder;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NonInteractable;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MenuControllerGIS_SetOverlayDialog) == 0x000008, "Wrong alignment on MenuControllerGIS_SetOverlayDialog");
static_assert(sizeof(MenuControllerGIS_SetOverlayDialog) == 0x000010, "Wrong size on MenuControllerGIS_SetOverlayDialog");
static_assert(offsetof(MenuControllerGIS_SetOverlayDialog, Menu) == 0x000000, "Member 'MenuControllerGIS_SetOverlayDialog::Menu' has a wrong offset!");
static_assert(offsetof(MenuControllerGIS_SetOverlayDialog, ZOrder) == 0x000008, "Member 'MenuControllerGIS_SetOverlayDialog::ZOrder' has a wrong offset!");
static_assert(offsetof(MenuControllerGIS_SetOverlayDialog, NonInteractable) == 0x00000C, "Member 'MenuControllerGIS_SetOverlayDialog::NonInteractable' has a wrong offset!");

// Function FCT.MenuControllerGIS.UpdateUserWidgetFocus
// 0x0002 (0x0002 - 0x0000)
struct MenuControllerGIS_UpdateUserWidgetFocus final
{
public:
	bool                                          SetNewFocus;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MenuControllerGIS_UpdateUserWidgetFocus) == 0x000001, "Wrong alignment on MenuControllerGIS_UpdateUserWidgetFocus");
static_assert(sizeof(MenuControllerGIS_UpdateUserWidgetFocus) == 0x000002, "Wrong size on MenuControllerGIS_UpdateUserWidgetFocus");
static_assert(offsetof(MenuControllerGIS_UpdateUserWidgetFocus, SetNewFocus) == 0x000000, "Member 'MenuControllerGIS_UpdateUserWidgetFocus::SetNewFocus' has a wrong offset!");
static_assert(offsetof(MenuControllerGIS_UpdateUserWidgetFocus, ReturnValue) == 0x000001, "Member 'MenuControllerGIS_UpdateUserWidgetFocus::ReturnValue' has a wrong offset!");

// Function FCT.MenuControllerGIS.GetWorldContextObjectFromMenus
// 0x0008 (0x0008 - 0x0000)
struct MenuControllerGIS_GetWorldContextObjectFromMenus final
{
public:
	class UObject*                                ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MenuControllerGIS_GetWorldContextObjectFromMenus) == 0x000008, "Wrong alignment on MenuControllerGIS_GetWorldContextObjectFromMenus");
static_assert(sizeof(MenuControllerGIS_GetWorldContextObjectFromMenus) == 0x000008, "Wrong size on MenuControllerGIS_GetWorldContextObjectFromMenus");
static_assert(offsetof(MenuControllerGIS_GetWorldContextObjectFromMenus, ReturnValue) == 0x000000, "Member 'MenuControllerGIS_GetWorldContextObjectFromMenus::ReturnValue' has a wrong offset!");

// Function FCT.MenuControllerGIS.HasMenus
// 0x0001 (0x0001 - 0x0000)
struct MenuControllerGIS_HasMenus final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MenuControllerGIS_HasMenus) == 0x000001, "Wrong alignment on MenuControllerGIS_HasMenus");
static_assert(sizeof(MenuControllerGIS_HasMenus) == 0x000001, "Wrong size on MenuControllerGIS_HasMenus");
static_assert(offsetof(MenuControllerGIS_HasMenus, ReturnValue) == 0x000000, "Member 'MenuControllerGIS_HasMenus::ReturnValue' has a wrong offset!");

// Function FCT.MenuFocusWidget.GetLastFocusedWidget
// 0x0008 (0x0008 - 0x0000)
struct MenuFocusWidget_GetLastFocusedWidget final
{
public:
	class UWidget*                                ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MenuFocusWidget_GetLastFocusedWidget) == 0x000008, "Wrong alignment on MenuFocusWidget_GetLastFocusedWidget");
static_assert(sizeof(MenuFocusWidget_GetLastFocusedWidget) == 0x000008, "Wrong size on MenuFocusWidget_GetLastFocusedWidget");
static_assert(offsetof(MenuFocusWidget_GetLastFocusedWidget, ReturnValue) == 0x000000, "Member 'MenuFocusWidget_GetLastFocusedWidget::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.FindScreenEdgeLocationForWorldLocation
// 0x0028 (0x0028 - 0x0000)
struct MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x000C)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CenterWeight;                                      // 0x0014(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OnTheEdge;                                         // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ScreenPosition;                                    // 0x001C(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation) == 0x000008, "Wrong alignment on MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation");
static_assert(sizeof(MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation) == 0x000028, "Wrong size on MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation");
static_assert(offsetof(MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation, WorldContextObject) == 0x000000, "Member 'MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation, WorldLocation) == 0x000008, "Member 'MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation, CenterWeight) == 0x000014, "Member 'MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation::CenterWeight' has a wrong offset!");
static_assert(offsetof(MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation, OnTheEdge) == 0x000018, "Member 'MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation::OnTheEdge' has a wrong offset!");
static_assert(offsetof(MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation, ScreenPosition) == 0x00001C, "Member 'MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation::ScreenPosition' has a wrong offset!");
static_assert(offsetof(MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation, Angle) == 0x000024, "Member 'MyBlueprintFunctionLibrary_FindScreenEdgeLocationForWorldLocation::Angle' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.GetRandomWeighted
// 0x0058 (0x0058 - 0x0000)
struct MyBlueprintFunctionLibrary_GetRandomWeighted final
{
public:
	TMap<TSubclassOf<class AActor>, int32>        ActorToWeightMap;                                  // 0x0000(0x0050)(ConstParm, Parm, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_GetRandomWeighted) == 0x000008, "Wrong alignment on MyBlueprintFunctionLibrary_GetRandomWeighted");
static_assert(sizeof(MyBlueprintFunctionLibrary_GetRandomWeighted) == 0x000058, "Wrong size on MyBlueprintFunctionLibrary_GetRandomWeighted");
static_assert(offsetof(MyBlueprintFunctionLibrary_GetRandomWeighted, ActorToWeightMap) == 0x000000, "Member 'MyBlueprintFunctionLibrary_GetRandomWeighted::ActorToWeightMap' has a wrong offset!");
static_assert(offsetof(MyBlueprintFunctionLibrary_GetRandomWeighted, ReturnValue) == 0x000050, "Member 'MyBlueprintFunctionLibrary_GetRandomWeighted::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.GetRandomWeightedEnum
// 0x0058 (0x0058 - 0x0000)
struct MyBlueprintFunctionLibrary_GetRandomWeightedEnum final
{
public:
	TMap<uint8, int32>                            EnumToWeightMap;                                   // 0x0000(0x0050)(ConstParm, Parm, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MyBlueprintFunctionLibrary_GetRandomWeightedEnum) == 0x000008, "Wrong alignment on MyBlueprintFunctionLibrary_GetRandomWeightedEnum");
static_assert(sizeof(MyBlueprintFunctionLibrary_GetRandomWeightedEnum) == 0x000058, "Wrong size on MyBlueprintFunctionLibrary_GetRandomWeightedEnum");
static_assert(offsetof(MyBlueprintFunctionLibrary_GetRandomWeightedEnum, EnumToWeightMap) == 0x000000, "Member 'MyBlueprintFunctionLibrary_GetRandomWeightedEnum::EnumToWeightMap' has a wrong offset!");
static_assert(offsetof(MyBlueprintFunctionLibrary_GetRandomWeightedEnum, ReturnValue) == 0x000050, "Member 'MyBlueprintFunctionLibrary_GetRandomWeightedEnum::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.GetSonyEnterButtonSwapped
// 0x0001 (0x0001 - 0x0000)
struct MyBlueprintFunctionLibrary_GetSonyEnterButtonSwapped final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_GetSonyEnterButtonSwapped) == 0x000001, "Wrong alignment on MyBlueprintFunctionLibrary_GetSonyEnterButtonSwapped");
static_assert(sizeof(MyBlueprintFunctionLibrary_GetSonyEnterButtonSwapped) == 0x000001, "Wrong size on MyBlueprintFunctionLibrary_GetSonyEnterButtonSwapped");
static_assert(offsetof(MyBlueprintFunctionLibrary_GetSonyEnterButtonSwapped, ReturnValue) == 0x000000, "Member 'MyBlueprintFunctionLibrary_GetSonyEnterButtonSwapped::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.GetSonyRegion
// 0x0001 (0x0001 - 0x0000)
struct MyBlueprintFunctionLibrary_GetSonyRegion final
{
public:
	ESonyRegion                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_GetSonyRegion) == 0x000001, "Wrong alignment on MyBlueprintFunctionLibrary_GetSonyRegion");
static_assert(sizeof(MyBlueprintFunctionLibrary_GetSonyRegion) == 0x000001, "Wrong size on MyBlueprintFunctionLibrary_GetSonyRegion");
static_assert(offsetof(MyBlueprintFunctionLibrary_GetSonyRegion, ReturnValue) == 0x000000, "Member 'MyBlueprintFunctionLibrary_GetSonyRegion::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.GetSortedActorsDescending
// 0x0060 (0x0060 - 0x0000)
struct MyBlueprintFunctionLibrary_GetSortedActorsDescending final
{
public:
	TMap<class AActor*, int32>                    MyMap;                                             // 0x0000(0x0050)(Parm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ReturnValue;                                       // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_GetSortedActorsDescending) == 0x000008, "Wrong alignment on MyBlueprintFunctionLibrary_GetSortedActorsDescending");
static_assert(sizeof(MyBlueprintFunctionLibrary_GetSortedActorsDescending) == 0x000060, "Wrong size on MyBlueprintFunctionLibrary_GetSortedActorsDescending");
static_assert(offsetof(MyBlueprintFunctionLibrary_GetSortedActorsDescending, MyMap) == 0x000000, "Member 'MyBlueprintFunctionLibrary_GetSortedActorsDescending::MyMap' has a wrong offset!");
static_assert(offsetof(MyBlueprintFunctionLibrary_GetSortedActorsDescending, ReturnValue) == 0x000050, "Member 'MyBlueprintFunctionLibrary_GetSortedActorsDescending::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.GetWidgetLocation
// 0x0018 (0x0018 - 0x0000)
struct MyBlueprintFunctionLibrary_GetWidgetLocation final
{
public:
	class UWidget*                                InParentWidget;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                InWidget;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_GetWidgetLocation) == 0x000008, "Wrong alignment on MyBlueprintFunctionLibrary_GetWidgetLocation");
static_assert(sizeof(MyBlueprintFunctionLibrary_GetWidgetLocation) == 0x000018, "Wrong size on MyBlueprintFunctionLibrary_GetWidgetLocation");
static_assert(offsetof(MyBlueprintFunctionLibrary_GetWidgetLocation, InParentWidget) == 0x000000, "Member 'MyBlueprintFunctionLibrary_GetWidgetLocation::InParentWidget' has a wrong offset!");
static_assert(offsetof(MyBlueprintFunctionLibrary_GetWidgetLocation, InWidget) == 0x000008, "Member 'MyBlueprintFunctionLibrary_GetWidgetLocation::InWidget' has a wrong offset!");
static_assert(offsetof(MyBlueprintFunctionLibrary_GetWidgetLocation, ReturnValue) == 0x000010, "Member 'MyBlueprintFunctionLibrary_GetWidgetLocation::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.IsConsolePlatform
// 0x0001 (0x0001 - 0x0000)
struct MyBlueprintFunctionLibrary_IsConsolePlatform final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_IsConsolePlatform) == 0x000001, "Wrong alignment on MyBlueprintFunctionLibrary_IsConsolePlatform");
static_assert(sizeof(MyBlueprintFunctionLibrary_IsConsolePlatform) == 0x000001, "Wrong size on MyBlueprintFunctionLibrary_IsConsolePlatform");
static_assert(offsetof(MyBlueprintFunctionLibrary_IsConsolePlatform, ReturnValue) == 0x000000, "Member 'MyBlueprintFunctionLibrary_IsConsolePlatform::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.IsDevConsolePlatform
// 0x0001 (0x0001 - 0x0000)
struct MyBlueprintFunctionLibrary_IsDevConsolePlatform final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_IsDevConsolePlatform) == 0x000001, "Wrong alignment on MyBlueprintFunctionLibrary_IsDevConsolePlatform");
static_assert(sizeof(MyBlueprintFunctionLibrary_IsDevConsolePlatform) == 0x000001, "Wrong size on MyBlueprintFunctionLibrary_IsDevConsolePlatform");
static_assert(offsetof(MyBlueprintFunctionLibrary_IsDevConsolePlatform, ReturnValue) == 0x000000, "Member 'MyBlueprintFunctionLibrary_IsDevConsolePlatform::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.IsPlatformRequestingIntroSkip
// 0x0001 (0x0001 - 0x0000)
struct MyBlueprintFunctionLibrary_IsPlatformRequestingIntroSkip final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_IsPlatformRequestingIntroSkip) == 0x000001, "Wrong alignment on MyBlueprintFunctionLibrary_IsPlatformRequestingIntroSkip");
static_assert(sizeof(MyBlueprintFunctionLibrary_IsPlatformRequestingIntroSkip) == 0x000001, "Wrong size on MyBlueprintFunctionLibrary_IsPlatformRequestingIntroSkip");
static_assert(offsetof(MyBlueprintFunctionLibrary_IsPlatformRequestingIntroSkip, ReturnValue) == 0x000000, "Member 'MyBlueprintFunctionLibrary_IsPlatformRequestingIntroSkip::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.IsPS4Platform
// 0x0001 (0x0001 - 0x0000)
struct MyBlueprintFunctionLibrary_IsPS4Platform final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_IsPS4Platform) == 0x000001, "Wrong alignment on MyBlueprintFunctionLibrary_IsPS4Platform");
static_assert(sizeof(MyBlueprintFunctionLibrary_IsPS4Platform) == 0x000001, "Wrong size on MyBlueprintFunctionLibrary_IsPS4Platform");
static_assert(offsetof(MyBlueprintFunctionLibrary_IsPS4Platform, ReturnValue) == 0x000000, "Member 'MyBlueprintFunctionLibrary_IsPS4Platform::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.IsPS5Platform
// 0x0001 (0x0001 - 0x0000)
struct MyBlueprintFunctionLibrary_IsPS5Platform final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_IsPS5Platform) == 0x000001, "Wrong alignment on MyBlueprintFunctionLibrary_IsPS5Platform");
static_assert(sizeof(MyBlueprintFunctionLibrary_IsPS5Platform) == 0x000001, "Wrong size on MyBlueprintFunctionLibrary_IsPS5Platform");
static_assert(offsetof(MyBlueprintFunctionLibrary_IsPS5Platform, ReturnValue) == 0x000000, "Member 'MyBlueprintFunctionLibrary_IsPS5Platform::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.IsWinGDKPlatform
// 0x0001 (0x0001 - 0x0000)
struct MyBlueprintFunctionLibrary_IsWinGDKPlatform final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_IsWinGDKPlatform) == 0x000001, "Wrong alignment on MyBlueprintFunctionLibrary_IsWinGDKPlatform");
static_assert(sizeof(MyBlueprintFunctionLibrary_IsWinGDKPlatform) == 0x000001, "Wrong size on MyBlueprintFunctionLibrary_IsWinGDKPlatform");
static_assert(offsetof(MyBlueprintFunctionLibrary_IsWinGDKPlatform, ReturnValue) == 0x000000, "Member 'MyBlueprintFunctionLibrary_IsWinGDKPlatform::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.IsXboxOneGDKPlatform
// 0x0001 (0x0001 - 0x0000)
struct MyBlueprintFunctionLibrary_IsXboxOneGDKPlatform final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_IsXboxOneGDKPlatform) == 0x000001, "Wrong alignment on MyBlueprintFunctionLibrary_IsXboxOneGDKPlatform");
static_assert(sizeof(MyBlueprintFunctionLibrary_IsXboxOneGDKPlatform) == 0x000001, "Wrong size on MyBlueprintFunctionLibrary_IsXboxOneGDKPlatform");
static_assert(offsetof(MyBlueprintFunctionLibrary_IsXboxOneGDKPlatform, ReturnValue) == 0x000000, "Member 'MyBlueprintFunctionLibrary_IsXboxOneGDKPlatform::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.IsXboxPlatform
// 0x0001 (0x0001 - 0x0000)
struct MyBlueprintFunctionLibrary_IsXboxPlatform final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_IsXboxPlatform) == 0x000001, "Wrong alignment on MyBlueprintFunctionLibrary_IsXboxPlatform");
static_assert(sizeof(MyBlueprintFunctionLibrary_IsXboxPlatform) == 0x000001, "Wrong size on MyBlueprintFunctionLibrary_IsXboxPlatform");
static_assert(offsetof(MyBlueprintFunctionLibrary_IsXboxPlatform, ReturnValue) == 0x000000, "Member 'MyBlueprintFunctionLibrary_IsXboxPlatform::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.IsXSXPlatform
// 0x0001 (0x0001 - 0x0000)
struct MyBlueprintFunctionLibrary_IsXSXPlatform final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MyBlueprintFunctionLibrary_IsXSXPlatform) == 0x000001, "Wrong alignment on MyBlueprintFunctionLibrary_IsXSXPlatform");
static_assert(sizeof(MyBlueprintFunctionLibrary_IsXSXPlatform) == 0x000001, "Wrong size on MyBlueprintFunctionLibrary_IsXSXPlatform");
static_assert(offsetof(MyBlueprintFunctionLibrary_IsXSXPlatform, ReturnValue) == 0x000000, "Member 'MyBlueprintFunctionLibrary_IsXSXPlatform::ReturnValue' has a wrong offset!");

// Function FCT.MyBlueprintFunctionLibrary.SetMenuWorldRenderingDisabled
// 0x0010 (0x0010 - 0x0000)
struct MyBlueprintFunctionLibrary_SetMenuWorldRenderingDisabled final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisabled;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MyBlueprintFunctionLibrary_SetMenuWorldRenderingDisabled) == 0x000008, "Wrong alignment on MyBlueprintFunctionLibrary_SetMenuWorldRenderingDisabled");
static_assert(sizeof(MyBlueprintFunctionLibrary_SetMenuWorldRenderingDisabled) == 0x000010, "Wrong size on MyBlueprintFunctionLibrary_SetMenuWorldRenderingDisabled");
static_assert(offsetof(MyBlueprintFunctionLibrary_SetMenuWorldRenderingDisabled, WorldContextObject) == 0x000000, "Member 'MyBlueprintFunctionLibrary_SetMenuWorldRenderingDisabled::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MyBlueprintFunctionLibrary_SetMenuWorldRenderingDisabled, bIsDisabled) == 0x000008, "Member 'MyBlueprintFunctionLibrary_SetMenuWorldRenderingDisabled::bIsDisabled' has a wrong offset!");

// Function FCT.SaveControllerGIS.DoInitialLoad
// 0x0018 (0x0018 - 0x0000)
struct SaveControllerGIS_DoInitialLoad final
{
public:
	TArray<class FString>                         SlotsToLoad;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SaveControllerGIS_DoInitialLoad) == 0x000008, "Wrong alignment on SaveControllerGIS_DoInitialLoad");
static_assert(sizeof(SaveControllerGIS_DoInitialLoad) == 0x000018, "Wrong size on SaveControllerGIS_DoInitialLoad");
static_assert(offsetof(SaveControllerGIS_DoInitialLoad, SlotsToLoad) == 0x000000, "Member 'SaveControllerGIS_DoInitialLoad::SlotsToLoad' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_DoInitialLoad, ReturnValue) == 0x000010, "Member 'SaveControllerGIS_DoInitialLoad::ReturnValue' has a wrong offset!");

// Function FCT.SaveControllerGIS.GetAnySaveInProgress
// 0x0001 (0x0001 - 0x0000)
struct SaveControllerGIS_GetAnySaveInProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveControllerGIS_GetAnySaveInProgress) == 0x000001, "Wrong alignment on SaveControllerGIS_GetAnySaveInProgress");
static_assert(sizeof(SaveControllerGIS_GetAnySaveInProgress) == 0x000001, "Wrong size on SaveControllerGIS_GetAnySaveInProgress");
static_assert(offsetof(SaveControllerGIS_GetAnySaveInProgress, ReturnValue) == 0x000000, "Member 'SaveControllerGIS_GetAnySaveInProgress::ReturnValue' has a wrong offset!");

// Function FCT.SaveControllerGIS.GetInitialLoadComplete
// 0x0001 (0x0001 - 0x0000)
struct SaveControllerGIS_GetInitialLoadComplete final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveControllerGIS_GetInitialLoadComplete) == 0x000001, "Wrong alignment on SaveControllerGIS_GetInitialLoadComplete");
static_assert(sizeof(SaveControllerGIS_GetInitialLoadComplete) == 0x000001, "Wrong size on SaveControllerGIS_GetInitialLoadComplete");
static_assert(offsetof(SaveControllerGIS_GetInitialLoadComplete, ReturnValue) == 0x000000, "Member 'SaveControllerGIS_GetInitialLoadComplete::ReturnValue' has a wrong offset!");

// Function FCT.SaveControllerGIS.GetSaveExists
// 0x0018 (0x0018 - 0x0000)
struct SaveControllerGIS_GetSaveExists final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SaveControllerGIS_GetSaveExists) == 0x000008, "Wrong alignment on SaveControllerGIS_GetSaveExists");
static_assert(sizeof(SaveControllerGIS_GetSaveExists) == 0x000018, "Wrong size on SaveControllerGIS_GetSaveExists");
static_assert(offsetof(SaveControllerGIS_GetSaveExists, SlotName) == 0x000000, "Member 'SaveControllerGIS_GetSaveExists::SlotName' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_GetSaveExists, ReturnValue) == 0x000010, "Member 'SaveControllerGIS_GetSaveExists::ReturnValue' has a wrong offset!");

// Function FCT.SaveControllerGIS.GetSaveInProgress
// 0x0018 (0x0018 - 0x0000)
struct SaveControllerGIS_GetSaveInProgress final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SaveControllerGIS_GetSaveInProgress) == 0x000008, "Wrong alignment on SaveControllerGIS_GetSaveInProgress");
static_assert(sizeof(SaveControllerGIS_GetSaveInProgress) == 0x000018, "Wrong size on SaveControllerGIS_GetSaveInProgress");
static_assert(offsetof(SaveControllerGIS_GetSaveInProgress, SlotName) == 0x000000, "Member 'SaveControllerGIS_GetSaveInProgress::SlotName' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_GetSaveInProgress, ReturnValue) == 0x000010, "Member 'SaveControllerGIS_GetSaveInProgress::ReturnValue' has a wrong offset!");

// Function FCT.SaveControllerGIS.GetSaveLoaded
// 0x0018 (0x0018 - 0x0000)
struct SaveControllerGIS_GetSaveLoaded final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SaveControllerGIS_GetSaveLoaded) == 0x000008, "Wrong alignment on SaveControllerGIS_GetSaveLoaded");
static_assert(sizeof(SaveControllerGIS_GetSaveLoaded) == 0x000018, "Wrong size on SaveControllerGIS_GetSaveLoaded");
static_assert(offsetof(SaveControllerGIS_GetSaveLoaded, SlotName) == 0x000000, "Member 'SaveControllerGIS_GetSaveLoaded::SlotName' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_GetSaveLoaded, ReturnValue) == 0x000010, "Member 'SaveControllerGIS_GetSaveLoaded::ReturnValue' has a wrong offset!");

// Function FCT.SaveControllerGIS.Load
// 0x0018 (0x0018 - 0x0000)
struct SaveControllerGIS_Load final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveGame*                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveControllerGIS_Load) == 0x000008, "Wrong alignment on SaveControllerGIS_Load");
static_assert(sizeof(SaveControllerGIS_Load) == 0x000018, "Wrong size on SaveControllerGIS_Load");
static_assert(offsetof(SaveControllerGIS_Load, SlotName) == 0x000000, "Member 'SaveControllerGIS_Load::SlotName' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_Load, ReturnValue) == 0x000010, "Member 'SaveControllerGIS_Load::ReturnValue' has a wrong offset!");

// Function FCT.SaveControllerGIS.Preload
// 0x0010 (0x0010 - 0x0000)
struct SaveControllerGIS_Preload final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveControllerGIS_Preload) == 0x000008, "Wrong alignment on SaveControllerGIS_Preload");
static_assert(sizeof(SaveControllerGIS_Preload) == 0x000010, "Wrong size on SaveControllerGIS_Preload");
static_assert(offsetof(SaveControllerGIS_Preload, SlotName) == 0x000000, "Member 'SaveControllerGIS_Preload::SlotName' has a wrong offset!");

// Function FCT.SaveControllerGIS.ResetSaveController
// 0x0001 (0x0001 - 0x0000)
struct SaveControllerGIS_ResetSaveController final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SaveControllerGIS_ResetSaveController) == 0x000001, "Wrong alignment on SaveControllerGIS_ResetSaveController");
static_assert(sizeof(SaveControllerGIS_ResetSaveController) == 0x000001, "Wrong size on SaveControllerGIS_ResetSaveController");
static_assert(offsetof(SaveControllerGIS_ResetSaveController, ReturnValue) == 0x000000, "Member 'SaveControllerGIS_ResetSaveController::ReturnValue' has a wrong offset!");

// Function FCT.SaveControllerGIS.Save
// 0x0020 (0x0020 - 0x0000)
struct SaveControllerGIS_Save final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveGame*                              SaveGame;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SaveControllerGIS_Save) == 0x000008, "Wrong alignment on SaveControllerGIS_Save");
static_assert(sizeof(SaveControllerGIS_Save) == 0x000020, "Wrong size on SaveControllerGIS_Save");
static_assert(offsetof(SaveControllerGIS_Save, SlotName) == 0x000000, "Member 'SaveControllerGIS_Save::SlotName' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_Save, SaveGame) == 0x000010, "Member 'SaveControllerGIS_Save::SaveGame' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_Save, ReturnValue) == 0x000018, "Member 'SaveControllerGIS_Save::ReturnValue' has a wrong offset!");

// Function FCT.SaveControllerGIS.SaveWithMetaData
// 0x0078 (0x0078 - 0x0000)
struct SaveControllerGIS_SaveWithMetaData final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveGame*                              SaveGame;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0018(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   DisplaySubtitle;                                   // 0x0030(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   DisplayDescription;                                // 0x0048(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0060(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBytes;                                          // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          KeepMetaData;                                      // 0x0074(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0075(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SaveControllerGIS_SaveWithMetaData) == 0x000008, "Wrong alignment on SaveControllerGIS_SaveWithMetaData");
static_assert(sizeof(SaveControllerGIS_SaveWithMetaData) == 0x000078, "Wrong size on SaveControllerGIS_SaveWithMetaData");
static_assert(offsetof(SaveControllerGIS_SaveWithMetaData, SlotName) == 0x000000, "Member 'SaveControllerGIS_SaveWithMetaData::SlotName' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_SaveWithMetaData, SaveGame) == 0x000010, "Member 'SaveControllerGIS_SaveWithMetaData::SaveGame' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_SaveWithMetaData, DisplayName) == 0x000018, "Member 'SaveControllerGIS_SaveWithMetaData::DisplayName' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_SaveWithMetaData, DisplaySubtitle) == 0x000030, "Member 'SaveControllerGIS_SaveWithMetaData::DisplaySubtitle' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_SaveWithMetaData, DisplayDescription) == 0x000048, "Member 'SaveControllerGIS_SaveWithMetaData::DisplayDescription' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_SaveWithMetaData, IconPath) == 0x000060, "Member 'SaveControllerGIS_SaveWithMetaData::IconPath' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_SaveWithMetaData, MaxBytes) == 0x000070, "Member 'SaveControllerGIS_SaveWithMetaData::MaxBytes' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_SaveWithMetaData, KeepMetaData) == 0x000074, "Member 'SaveControllerGIS_SaveWithMetaData::KeepMetaData' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_SaveWithMetaData, ReturnValue) == 0x000075, "Member 'SaveControllerGIS_SaveWithMetaData::ReturnValue' has a wrong offset!");

// Function FCT.SaveControllerGIS.SetSaveMetadata
// 0x0070 (0x0070 - 0x0000)
struct SaveControllerGIS_SetSaveMetadata final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x0010(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   DisplaySubtitle;                                   // 0x0028(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   DisplayDescription;                                // 0x0040(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FString                                 IconPath;                                          // 0x0058(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxBytes;                                          // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SaveControllerGIS_SetSaveMetadata) == 0x000008, "Wrong alignment on SaveControllerGIS_SetSaveMetadata");
static_assert(sizeof(SaveControllerGIS_SetSaveMetadata) == 0x000070, "Wrong size on SaveControllerGIS_SetSaveMetadata");
static_assert(offsetof(SaveControllerGIS_SetSaveMetadata, SlotName) == 0x000000, "Member 'SaveControllerGIS_SetSaveMetadata::SlotName' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_SetSaveMetadata, DisplayName) == 0x000010, "Member 'SaveControllerGIS_SetSaveMetadata::DisplayName' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_SetSaveMetadata, DisplaySubtitle) == 0x000028, "Member 'SaveControllerGIS_SetSaveMetadata::DisplaySubtitle' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_SetSaveMetadata, DisplayDescription) == 0x000040, "Member 'SaveControllerGIS_SetSaveMetadata::DisplayDescription' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_SetSaveMetadata, IconPath) == 0x000058, "Member 'SaveControllerGIS_SetSaveMetadata::IconPath' has a wrong offset!");
static_assert(offsetof(SaveControllerGIS_SetSaveMetadata, MaxBytes) == 0x000068, "Member 'SaveControllerGIS_SetSaveMetadata::MaxBytes' has a wrong offset!");

}

