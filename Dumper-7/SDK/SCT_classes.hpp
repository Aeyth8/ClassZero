#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: SCT

#include "Basic.hpp"

#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "SCT_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "InputCore_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "SlateCore_structs.hpp"
#include "AccelByteUe4Sdk_structs.hpp"


namespace SDK
{

// Class SCT.AccelByteUtilsFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UAccelByteUtilsFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FCloudCustomizationPacket CreateCustomizationPacket(class ACustomizationOptions* Options, EPlayerCustomizationType Category, const struct FCloudCustomizationPayload& Payload);
	static struct FDateTime FormatAccelByteDateTimeToUnrealDateTime(const class FString& InConvertToDateTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AccelByteUtilsFunctionLibrary">();
	}
	static class UAccelByteUtilsFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAccelByteUtilsFunctionLibrary>();
	}
};
static_assert(alignof(UAccelByteUtilsFunctionLibrary) == 0x000008, "Wrong alignment on UAccelByteUtilsFunctionLibrary");
static_assert(sizeof(UAccelByteUtilsFunctionLibrary) == 0x000028, "Wrong size on UAccelByteUtilsFunctionLibrary");

// Class SCT.AbilitySystemComponentSCT
// 0x00C0 (0x13C8 - 0x1308)
class UAbilitySystemComponentSCT : public UAbilitySystemComponent
{
public:
	FMulticastInlineDelegateProperty_             OnAbilityRevoked;                                  // 0x1308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAbilityRemoved;                                  // 0x1318(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTagsChanged;                                     // 0x1328(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPowerInputPressed;                               // 0x1338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPowerInputReleased;                              // 0x1348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnActiveEffectRemoved;                             // 0x1358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPowerGranted;                                    // 0x1368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class UGameplayAbility*, struct FPowerInitializationSpec> PendingInitializationSpecs;                        // 0x1378(0x0050)(Protected, NativeAccessSpecifierProtected)

public:
	void CancelAllAbilities();
	void RemoveGameplayEffectsUsingType(TSubclassOf<class UGameplayEffect> EffectType);

	class AActor* GetEffectInstigator(const struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilitySystemComponentSCT">();
	}
	static class UAbilitySystemComponentSCT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemComponentSCT>();
	}
};
static_assert(alignof(UAbilitySystemComponentSCT) == 0x000008, "Wrong alignment on UAbilitySystemComponentSCT");
static_assert(sizeof(UAbilitySystemComponentSCT) == 0x0013C8, "Wrong size on UAbilitySystemComponentSCT");
static_assert(offsetof(UAbilitySystemComponentSCT, OnAbilityRevoked) == 0x001308, "Member 'UAbilitySystemComponentSCT::OnAbilityRevoked' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentSCT, OnAbilityRemoved) == 0x001318, "Member 'UAbilitySystemComponentSCT::OnAbilityRemoved' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentSCT, OnTagsChanged) == 0x001328, "Member 'UAbilitySystemComponentSCT::OnTagsChanged' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentSCT, OnPowerInputPressed) == 0x001338, "Member 'UAbilitySystemComponentSCT::OnPowerInputPressed' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentSCT, OnPowerInputReleased) == 0x001348, "Member 'UAbilitySystemComponentSCT::OnPowerInputReleased' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentSCT, OnActiveEffectRemoved) == 0x001358, "Member 'UAbilitySystemComponentSCT::OnActiveEffectRemoved' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentSCT, OnPowerGranted) == 0x001368, "Member 'UAbilitySystemComponentSCT::OnPowerGranted' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentSCT, PendingInitializationSpecs) == 0x001378, "Member 'UAbilitySystemComponentSCT::PendingInitializationSpecs' has a wrong offset!");

// Class SCT.AgendaEvent
// 0x0000 (0x0030 - 0x0030)
class UAgendaEvent : public UDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgendaEvent">();
	}
	static class UAgendaEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgendaEvent>();
	}
};
static_assert(alignof(UAgendaEvent) == 0x000008, "Wrong alignment on UAgendaEvent");
static_assert(sizeof(UAgendaEvent) == 0x000030, "Wrong size on UAgendaEvent");

// Class SCT.AgendaGenericEvent
// 0x0010 (0x0040 - 0x0030)
class UAgendaGenericEvent final : public UAgendaEvent
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Call(class AActor* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgendaGenericEvent">();
	}
	static class UAgendaGenericEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgendaGenericEvent>();
	}
};
static_assert(alignof(UAgendaGenericEvent) == 0x000008, "Wrong alignment on UAgendaGenericEvent");
static_assert(sizeof(UAgendaGenericEvent) == 0x000040, "Wrong size on UAgendaGenericEvent");
static_assert(offsetof(UAgendaGenericEvent, Event) == 0x000030, "Member 'UAgendaGenericEvent::Event' has a wrong offset!");

// Class SCT.AbilitySystemComponentWorld
// 0x0000 (0x13C8 - 0x13C8)
class UAbilitySystemComponentWorld final : public UAbilitySystemComponentSCT
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilitySystemComponentWorld">();
	}
	static class UAbilitySystemComponentWorld* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemComponentWorld>();
	}
};
static_assert(alignof(UAbilitySystemComponentWorld) == 0x000008, "Wrong alignment on UAbilitySystemComponentWorld");
static_assert(sizeof(UAbilitySystemComponentWorld) == 0x0013C8, "Wrong size on UAbilitySystemComponentWorld");

// Class SCT.CustomGameSettingsComponent
// 0x0068 (0x0118 - 0x00B0)
class UCustomGameSettingsComponent final : public UActorComponent
{
public:
	struct FCustomGameSettings                    AppliedUserSettings;                               // 0x00B0(0x0034)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x34];                                      // 0x00E4(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_UserSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomGameSettingsComponent">();
	}
	static class UCustomGameSettingsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomGameSettingsComponent>();
	}
};
static_assert(alignof(UCustomGameSettingsComponent) == 0x000008, "Wrong alignment on UCustomGameSettingsComponent");
static_assert(sizeof(UCustomGameSettingsComponent) == 0x000118, "Wrong size on UCustomGameSettingsComponent");
static_assert(offsetof(UCustomGameSettingsComponent, AppliedUserSettings) == 0x0000B0, "Member 'UCustomGameSettingsComponent::AppliedUserSettings' has a wrong offset!");

// Class SCT.FCTGetBlockedPlayerListCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTGetBlockedPlayerListCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTGetBlockedPlayerListCallbackProxy* GetBlockedPlayerList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGetBlockedPlayerListCallbackProxy">();
	}
	static class UFCTGetBlockedPlayerListCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGetBlockedPlayerListCallbackProxy>();
	}
};
static_assert(alignof(UFCTGetBlockedPlayerListCallbackProxy) == 0x000008, "Wrong alignment on UFCTGetBlockedPlayerListCallbackProxy");
static_assert(sizeof(UFCTGetBlockedPlayerListCallbackProxy) == 0x000050, "Wrong size on UFCTGetBlockedPlayerListCallbackProxy");
static_assert(offsetof(UFCTGetBlockedPlayerListCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTGetBlockedPlayerListCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTGetBlockedPlayerListCallbackProxy, OnError) == 0x000040, "Member 'UFCTGetBlockedPlayerListCallbackProxy::OnError' has a wrong offset!");

// Class SCT.AbilitySystemUtility
// 0x0000 (0x0028 - 0x0028)
class UAbilitySystemUtility final : public UAbilitySystemBlueprintLibrary
{
public:
	static void SendGameplayEvent(class UAbilitySystemComponent* Target, const struct FGameplayTag& EventTag, const struct FGameplayEventData& Payload);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilitySystemUtility">();
	}
	static class UAbilitySystemUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemUtility>();
	}
};
static_assert(alignof(UAbilitySystemUtility) == 0x000008, "Wrong alignment on UAbilitySystemUtility");
static_assert(sizeof(UAbilitySystemUtility) == 0x000028, "Wrong size on UAbilitySystemUtility");

// Class SCT.CharacterSCT
// 0x00D0 (0x0590 - 0x04C0)
class ACharacterSCT : public ACharacter
{
public:
	uint8                                         Pad_4C0[0x10];                                     // 0x04C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponentSCT*             AbilitySystemComponent;                            // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMoveAttributeSet*                      MoveAttributeSet;                                  // 0x04D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseTurnRate;                                      // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseLookUpRate;                                    // 0x04E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Portrait;                                          // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USpringArmComponent*                    CameraBoom;                                        // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraComponent*                       FollowCamera;                                      // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UContextSensor*                         ContextSensor;                                     // 0x0500(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UContextInputManager*                   ContextInputManager;                               // 0x0508(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UContextPowerManager*                   ContextPowerManager;                               // 0x0510(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInventory*                             Inventory;                                         // 0x0518(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCheatComponent*                        CheatComponent;                                    // 0x0520(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SensorDistance;                                    // 0x0528(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SensorOffset;                                      // 0x052C(0x000C)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AccelByteId;                                       // 0x0538(0x0010)(Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bAbilitiesInitialized;                             // 0x0548(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54C[0x4];                                      // 0x054C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UPower>>             StartupPowers;                                     // 0x0550(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  DefaultTags;                                       // 0x0560(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_580[0x10];                                     // 0x0580(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelPowers();
	void ClientInitializeContextSensors();
	void DisableCameraRotationForDuration(float Duration);
	void DisableMovementForFrames(int32 Frames);
	bool IsUsingPower();
	void K2_FellOutOfWorld();
	void K2_OnNameChanged(const class FString& NewName);
	void K2_OnRepPlayerState(const bool IsValid);
	void K2_OnSetCustomization(const class FString& PlayerAccelByteID);
	void OnDamaged(float DamageAmount, const struct FHitResult& HitInfo, const struct FGameplayTagContainer& DamageTags, class ACharacterSCT* InstigatorCharacter, class AActor* DamageCauser);
	void OnHealthChanged(float DeltaValue, const struct FGameplayTagContainer& EventTags);
	void OnManaChanged(float DeltaValue, const struct FGameplayTagContainer& EventTags);
	void OnMoveSpeedChanged(float MovementSpeed);
	void OnNameChanged(const class FString& NewName);
	void OnPreServerTravel();
	void OnRep_AccelByteID();
	void ServerCancelPowers();
	void Silence(float Duration);

	bool CanRotateCamera() const;
	bool CanRotateCharacter() const;
	int32 GetCharacerLevel() const;
	EFate GetFate() const;
	class ASCTPlayerState* GetSCTPlayerState() const;
	bool IsAlive() const;
	bool IsFateKnown() const;
	bool IsImmovable() const;
	bool IsInactive() const;
	bool K2_CanCrouch() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSCT">();
	}
	static class ACharacterSCT* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterSCT>();
	}
};
static_assert(alignof(ACharacterSCT) == 0x000010, "Wrong alignment on ACharacterSCT");
static_assert(sizeof(ACharacterSCT) == 0x000590, "Wrong size on ACharacterSCT");
static_assert(offsetof(ACharacterSCT, AbilitySystemComponent) == 0x0004D0, "Member 'ACharacterSCT::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, MoveAttributeSet) == 0x0004D8, "Member 'ACharacterSCT::MoveAttributeSet' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, BaseTurnRate) == 0x0004E0, "Member 'ACharacterSCT::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, BaseLookUpRate) == 0x0004E4, "Member 'ACharacterSCT::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, Portrait) == 0x0004E8, "Member 'ACharacterSCT::Portrait' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, CameraBoom) == 0x0004F0, "Member 'ACharacterSCT::CameraBoom' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, FollowCamera) == 0x0004F8, "Member 'ACharacterSCT::FollowCamera' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, ContextSensor) == 0x000500, "Member 'ACharacterSCT::ContextSensor' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, ContextInputManager) == 0x000508, "Member 'ACharacterSCT::ContextInputManager' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, ContextPowerManager) == 0x000510, "Member 'ACharacterSCT::ContextPowerManager' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, Inventory) == 0x000518, "Member 'ACharacterSCT::Inventory' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, CheatComponent) == 0x000520, "Member 'ACharacterSCT::CheatComponent' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, SensorDistance) == 0x000528, "Member 'ACharacterSCT::SensorDistance' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, SensorOffset) == 0x00052C, "Member 'ACharacterSCT::SensorOffset' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, AccelByteId) == 0x000538, "Member 'ACharacterSCT::AccelByteId' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, bAbilitiesInitialized) == 0x000548, "Member 'ACharacterSCT::bAbilitiesInitialized' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, StartupPowers) == 0x000550, "Member 'ACharacterSCT::StartupPowers' has a wrong offset!");
static_assert(offsetof(ACharacterSCT, DefaultTags) == 0x000560, "Member 'ACharacterSCT::DefaultTags' has a wrong offset!");

// Class SCT.AfterlifeCharacter
// 0x0010 (0x05A0 - 0x0590)
class AAfterlifeCharacter : public ACharacterSCT
{
public:
	bool                                          bIsFlying;                                         // 0x0590(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_591[0xF];                                      // 0x0591(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HideSpectatorHUD();
	void ShowSpectatorHUD();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AfterlifeCharacter">();
	}
	static class AAfterlifeCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAfterlifeCharacter>();
	}
};
static_assert(alignof(AAfterlifeCharacter) == 0x000010, "Wrong alignment on AAfterlifeCharacter");
static_assert(sizeof(AAfterlifeCharacter) == 0x0005A0, "Wrong size on AAfterlifeCharacter");
static_assert(offsetof(AAfterlifeCharacter, bIsFlying) == 0x000590, "Member 'AAfterlifeCharacter::bIsFlying' has a wrong offset!");

// Class SCT.AccelByteGIS
// 0x0400 (0x0430 - 0x0030)
class alignas(0x10) UAccelByteGIS final : public UGameInstanceSubsystem
{
public:
	struct FCloudCustomizationPayload             CurrentMaleCustomization;                          // 0x0030(0x0044)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCloudCustomizationPayload             CurrentFemaleCustomization;                        // 0x0074(0x0044)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCloudCustomizationPayload             TempMaleCustomization;                             // 0x00B8(0x0044)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FCloudCustomizationPayload             TempFemaleCustomization;                           // 0x00FC(0x0044)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	ECustomizationSavedGender                     CustomizationType;                                 // 0x0140(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         PlayedWithEarlierUserIDs;                          // 0x0148(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 SessionID;                                         // 0x0158(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_168[0x10];                                     // 0x0168(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoginCode;                                         // 0x0178(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialized;                                      // 0x017C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_17D[0x3];                                      // 0x017D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnStartLogin;                                      // 0x0180(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelLogin;                                     // 0x0190(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClientLoggedIn;                                  // 0x01A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnClientLoginFailed;                               // 0x01B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDisconnectedFromLobby;                           // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnConnectionClosed;                                // 0x01D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnConnectionFailed;                                // 0x01E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNetworkFailed;                                   // 0x01F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelMatchmakingOnStart;                        // 0x0200(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUserLinkedToVersusEvil;                          // 0x0210(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	struct FFCTAchievementList                    AchievementList;                                   // 0x0220(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnReconnectedToLobby;                              // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDLCPurchased;                                    // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UTexture2D*                             ProfilePortrait;                                   // 0x0268(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           LoginTimerHandle;                                  // 0x0270(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           SyncPurchasesTimerHandle;                          // 0x0278(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAccelByteUserPresenceData             PresenceData;                                      // 0x0280(0x0028)(NativeAccessSpecifierPublic)
	bool                                          bConsolePlayerCommunicationRestricted;             // 0x02A8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bXboxCrossPlayFriendsCommunicationRestricted;      // 0x02A9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bXboxCrossPlayNonFriendsCommunicationRestricted;   // 0x02AA(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2AB[0x5];                                      // 0x02AB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAcceptConsoleSessionInvite;                      // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnConsoleLaunchIntent;                             // 0x02C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnConsoleLaunchMultiplayerIntent;                  // 0x02D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPartyChatReceived;                               // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUserPresenceUpdateRecieved;                      // 0x02F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FFCTFriendsList                        CachedFriendslist;                                 // 0x0300(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, struct FAccelByteUserPresenceData> AccelByteFriendsListUserPresenceData;              // 0x0328(0x0050)(NativeAccessSpecifierPublic)
	bool                                          bRequestCrossPlayJoinErrorMessage;                 // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0xF];                                      // 0x0379(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              MatchStartTime;                                    // 0x0388(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_390[0x10];                                     // 0x0390(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UFCTAchievementPopUp*                   CurrentPopUp;                                      // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x10];                                     // 0x03A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLoggedIn;                                         // 0x03B8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bXboxCrossPlayRestricted;                          // 0x03B9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bGameCrossPlayEnabled;                             // 0x03BA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3BB[0x5];                                      // 0x03BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           AchievementPopUpTimerHandle;                       // 0x03C0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x10];                                     // 0x03C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, struct FAccelByteUserPresenceData> AccelByteUserPresenceData;                         // 0x03D8(0x0050)(NativeAccessSpecifierPrivate)
	float                                         LastSyncPlatformPurchasesTimeS;                    // 0x0428(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddNewAchievementToQueue(class UFCTAchievement* NewAchievement);
	void AnimateAchievementPopUpFadeIn();
	void AnimateAchievementPopUpFadeOut();
	void CachePlayedWithLastMatchUser(const class FString& UserId);
	void CancelClientLogin();
	void ClearCrossPlayJoinErrorMessage();
	void ClearPendingConsoleLaunchIntent();
	void ClearPendingConsoleLaunchMultiplayerIntent();
	void ClearPendingConsoleSessionInvite();
	void ClearPlayedWithLastMatchUserCache();
	void ClientLoginFailed();
	struct FFCTRecentlyPlayedWithPayload GetCachedLastMatchUsers();
	bool GetGameCrossplayEnabled();
	class FString GetPlatformPlayerNickname();
	bool GetSyncPlatformPurchasesRateLimited();
	bool GetXboxCrossPlayRestricted();
	bool HasPendingConsoleLaunchIntent();
	bool HasPendingConsoleLaunchMultiplayerIntent();
	bool HasPendingConsoleSessionInvite();
	bool IsLoggedIn();
	void LoginClient();
	void LoginClientWithDelay(float Delay);
	void OnAchievementPopUpCreated(class UTexture2DDynamic* IconTexture);
	void ReopenConsoleSession();
	void RequestCrossPlayJoinErrorMessage();
	void ResetLoginForNewUser();
	void SetGameCrossplayEnabled(bool bInEnabled);
	void SetXboxCrossPlayRestricted(bool bInRestricted);
	void StartTelemetryMatchTimer();
	void UnbindEvents();
	void UpdatePlatformAchievementProgress(const class FString& AchievementID, float Progress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AccelByteGIS">();
	}
	static class UAccelByteGIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAccelByteGIS>();
	}
};
static_assert(alignof(UAccelByteGIS) == 0x000010, "Wrong alignment on UAccelByteGIS");
static_assert(sizeof(UAccelByteGIS) == 0x000430, "Wrong size on UAccelByteGIS");
static_assert(offsetof(UAccelByteGIS, CurrentMaleCustomization) == 0x000030, "Member 'UAccelByteGIS::CurrentMaleCustomization' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, CurrentFemaleCustomization) == 0x000074, "Member 'UAccelByteGIS::CurrentFemaleCustomization' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, TempMaleCustomization) == 0x0000B8, "Member 'UAccelByteGIS::TempMaleCustomization' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, TempFemaleCustomization) == 0x0000FC, "Member 'UAccelByteGIS::TempFemaleCustomization' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, CustomizationType) == 0x000140, "Member 'UAccelByteGIS::CustomizationType' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, PlayedWithEarlierUserIDs) == 0x000148, "Member 'UAccelByteGIS::PlayedWithEarlierUserIDs' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, SessionID) == 0x000158, "Member 'UAccelByteGIS::SessionID' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, LoginCode) == 0x000178, "Member 'UAccelByteGIS::LoginCode' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, bInitialized) == 0x00017C, "Member 'UAccelByteGIS::bInitialized' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnStartLogin) == 0x000180, "Member 'UAccelByteGIS::OnStartLogin' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnCancelLogin) == 0x000190, "Member 'UAccelByteGIS::OnCancelLogin' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnClientLoggedIn) == 0x0001A0, "Member 'UAccelByteGIS::OnClientLoggedIn' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnClientLoginFailed) == 0x0001B0, "Member 'UAccelByteGIS::OnClientLoginFailed' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnDisconnectedFromLobby) == 0x0001C0, "Member 'UAccelByteGIS::OnDisconnectedFromLobby' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnConnectionClosed) == 0x0001D0, "Member 'UAccelByteGIS::OnConnectionClosed' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnConnectionFailed) == 0x0001E0, "Member 'UAccelByteGIS::OnConnectionFailed' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnNetworkFailed) == 0x0001F0, "Member 'UAccelByteGIS::OnNetworkFailed' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnCancelMatchmakingOnStart) == 0x000200, "Member 'UAccelByteGIS::OnCancelMatchmakingOnStart' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnUserLinkedToVersusEvil) == 0x000210, "Member 'UAccelByteGIS::OnUserLinkedToVersusEvil' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, AchievementList) == 0x000220, "Member 'UAccelByteGIS::AchievementList' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnReconnectedToLobby) == 0x000248, "Member 'UAccelByteGIS::OnReconnectedToLobby' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnDLCPurchased) == 0x000258, "Member 'UAccelByteGIS::OnDLCPurchased' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, ProfilePortrait) == 0x000268, "Member 'UAccelByteGIS::ProfilePortrait' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, LoginTimerHandle) == 0x000270, "Member 'UAccelByteGIS::LoginTimerHandle' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, SyncPurchasesTimerHandle) == 0x000278, "Member 'UAccelByteGIS::SyncPurchasesTimerHandle' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, PresenceData) == 0x000280, "Member 'UAccelByteGIS::PresenceData' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, bConsolePlayerCommunicationRestricted) == 0x0002A8, "Member 'UAccelByteGIS::bConsolePlayerCommunicationRestricted' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, bXboxCrossPlayFriendsCommunicationRestricted) == 0x0002A9, "Member 'UAccelByteGIS::bXboxCrossPlayFriendsCommunicationRestricted' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, bXboxCrossPlayNonFriendsCommunicationRestricted) == 0x0002AA, "Member 'UAccelByteGIS::bXboxCrossPlayNonFriendsCommunicationRestricted' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnAcceptConsoleSessionInvite) == 0x0002B0, "Member 'UAccelByteGIS::OnAcceptConsoleSessionInvite' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnConsoleLaunchIntent) == 0x0002C0, "Member 'UAccelByteGIS::OnConsoleLaunchIntent' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnConsoleLaunchMultiplayerIntent) == 0x0002D0, "Member 'UAccelByteGIS::OnConsoleLaunchMultiplayerIntent' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnPartyChatReceived) == 0x0002E0, "Member 'UAccelByteGIS::OnPartyChatReceived' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, OnUserPresenceUpdateRecieved) == 0x0002F0, "Member 'UAccelByteGIS::OnUserPresenceUpdateRecieved' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, CachedFriendslist) == 0x000300, "Member 'UAccelByteGIS::CachedFriendslist' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, AccelByteFriendsListUserPresenceData) == 0x000328, "Member 'UAccelByteGIS::AccelByteFriendsListUserPresenceData' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, bRequestCrossPlayJoinErrorMessage) == 0x000378, "Member 'UAccelByteGIS::bRequestCrossPlayJoinErrorMessage' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, MatchStartTime) == 0x000388, "Member 'UAccelByteGIS::MatchStartTime' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, CurrentPopUp) == 0x0003A0, "Member 'UAccelByteGIS::CurrentPopUp' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, bLoggedIn) == 0x0003B8, "Member 'UAccelByteGIS::bLoggedIn' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, bXboxCrossPlayRestricted) == 0x0003B9, "Member 'UAccelByteGIS::bXboxCrossPlayRestricted' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, bGameCrossPlayEnabled) == 0x0003BA, "Member 'UAccelByteGIS::bGameCrossPlayEnabled' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, AchievementPopUpTimerHandle) == 0x0003C0, "Member 'UAccelByteGIS::AchievementPopUpTimerHandle' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, AccelByteUserPresenceData) == 0x0003D8, "Member 'UAccelByteGIS::AccelByteUserPresenceData' has a wrong offset!");
static_assert(offsetof(UAccelByteGIS, LastSyncPlatformPurchasesTimeS) == 0x000428, "Member 'UAccelByteGIS::LastSyncPlatformPurchasesTimeS' has a wrong offset!");

// Class SCT.FCTAchievement
// 0x0090 (0x00B8 - 0x0028)
class UFCTAchievement final : public UObject
{
public:
	class FString                                 Name_0;                                            // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AchievedOn;                                        // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              AchievedOnDateTime;                                // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GoalValue;                                         // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentValue;                                      // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUnlocked;                                       // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHidden;                                         // 0x0069(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2DDynamic*                      IconTexture;                                       // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIconCreated;                                     // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 Code;                                              // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x20];                                      // 0x0098(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAchievement">();
	}
	static class UFCTAchievement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAchievement>();
	}
};
static_assert(alignof(UFCTAchievement) == 0x000008, "Wrong alignment on UFCTAchievement");
static_assert(sizeof(UFCTAchievement) == 0x0000B8, "Wrong size on UFCTAchievement");
static_assert(offsetof(UFCTAchievement, Name_0) == 0x000028, "Member 'UFCTAchievement::Name_0' has a wrong offset!");
static_assert(offsetof(UFCTAchievement, Description) == 0x000038, "Member 'UFCTAchievement::Description' has a wrong offset!");
static_assert(offsetof(UFCTAchievement, AchievedOn) == 0x000048, "Member 'UFCTAchievement::AchievedOn' has a wrong offset!");
static_assert(offsetof(UFCTAchievement, AchievedOnDateTime) == 0x000058, "Member 'UFCTAchievement::AchievedOnDateTime' has a wrong offset!");
static_assert(offsetof(UFCTAchievement, GoalValue) == 0x000060, "Member 'UFCTAchievement::GoalValue' has a wrong offset!");
static_assert(offsetof(UFCTAchievement, CurrentValue) == 0x000064, "Member 'UFCTAchievement::CurrentValue' has a wrong offset!");
static_assert(offsetof(UFCTAchievement, bIsUnlocked) == 0x000068, "Member 'UFCTAchievement::bIsUnlocked' has a wrong offset!");
static_assert(offsetof(UFCTAchievement, bIsHidden) == 0x000069, "Member 'UFCTAchievement::bIsHidden' has a wrong offset!");
static_assert(offsetof(UFCTAchievement, IconTexture) == 0x000070, "Member 'UFCTAchievement::IconTexture' has a wrong offset!");
static_assert(offsetof(UFCTAchievement, OnIconCreated) == 0x000078, "Member 'UFCTAchievement::OnIconCreated' has a wrong offset!");
static_assert(offsetof(UFCTAchievement, Code) == 0x000088, "Member 'UFCTAchievement::Code' has a wrong offset!");

// Class SCT.AchievementComponent
// 0x0020 (0x00D0 - 0x00B0)
class UAchievementComponent final : public UActorComponent
{
public:
	TArray<class UAchievementObject*>             ActiveObjects;                                     // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class ASCTPlayerState*                        PlayerState;                                       // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInitialized;                                      // 0x00C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementComponent">();
	}
	static class UAchievementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementComponent>();
	}
};
static_assert(alignof(UAchievementComponent) == 0x000008, "Wrong alignment on UAchievementComponent");
static_assert(sizeof(UAchievementComponent) == 0x0000D0, "Wrong size on UAchievementComponent");
static_assert(offsetof(UAchievementComponent, ActiveObjects) == 0x0000B0, "Member 'UAchievementComponent::ActiveObjects' has a wrong offset!");
static_assert(offsetof(UAchievementComponent, PlayerState) == 0x0000C0, "Member 'UAchievementComponent::PlayerState' has a wrong offset!");
static_assert(offsetof(UAchievementComponent, bInitialized) == 0x0000C8, "Member 'UAchievementComponent::bInitialized' has a wrong offset!");

// Class SCT.ProgressionObject
// 0x0010 (0x0038 - 0x0028)
class UProgressionObject : public UObject
{
public:
	int32                                         PlayerId;                                          // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ASCTPlayerController*                   Controller;                                        // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void K2_Initialize();

	class ACharacterSCT* GetCharacter() const;
	class ASCTPlayerController* GetController() const;
	class ASCTGameState* GetGameState() const;
	int32 GetMaxNumberOfPlayers() const;
	class ASCTPlayerState* GetPlayerState() const;
	class ASCTPlayerState* GetRandomOtherPlayer() const;
	class ASCTPlayerState* GetRandomPlayer(const TArray<class APlayerState*>& Ignore) const;
	class AActor* GetWorldContextObject() const;
	bool IsControllerSelf(class APlayerController* Other) const;
	bool IsPlayerStateSelf(class APlayerState* Other) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressionObject">();
	}
	static class UProgressionObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressionObject>();
	}
};
static_assert(alignof(UProgressionObject) == 0x000008, "Wrong alignment on UProgressionObject");
static_assert(sizeof(UProgressionObject) == 0x000038, "Wrong size on UProgressionObject");
static_assert(offsetof(UProgressionObject, PlayerId) == 0x000028, "Member 'UProgressionObject::PlayerId' has a wrong offset!");
static_assert(offsetof(UProgressionObject, Controller) == 0x000030, "Member 'UProgressionObject::Controller' has a wrong offset!");

// Class SCT.CustomizationScrollBoxUserWidgetBase
// 0x0098 (0x02F8 - 0x0260)
class UCustomizationScrollBoxUserWidgetBase : public UUserWidget
{
public:
	class UGridPanel*                             ClassicItemGrid;                                   // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridPanel*                             ElegantItemGrid;                                   // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridPanel*                             LuxuriousItemGrid;                                 // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridPanel*                             ExtravagantItemGrid;                               // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UItemCardUserWidget*                    SelectedCategoryButton;                            // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemQuality                                  CurrentQuality;                                    // 0x0288(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UItemCardUserWidget*> ItemCards;                                         // 0x0290(0x0050)(BlueprintVisible, ExportObject, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         WardrobeColumnsPerRow;                             // 0x02E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2E4[0x4];                                      // 0x02E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SelectedRowName;                                   // 0x02E8(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SwapItemCardSelectedStates(const class FString& NewItemRowName);
	void SwapItemCardSelectedStatesByGrid(class UGridPanel* Grid, class FString& CurrentItemRowName, const class FString& NewItemRowName);
	void UpdateCategoryVisibility(class UGridPanel* CategoryGrid);
	void UpdateVisibilityForAllCategories();
	class UWidget* VerticalBoundaryHit(EUINavigation InNavigation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationScrollBoxUserWidgetBase">();
	}
	static class UCustomizationScrollBoxUserWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationScrollBoxUserWidgetBase>();
	}
};
static_assert(alignof(UCustomizationScrollBoxUserWidgetBase) == 0x000008, "Wrong alignment on UCustomizationScrollBoxUserWidgetBase");
static_assert(sizeof(UCustomizationScrollBoxUserWidgetBase) == 0x0002F8, "Wrong size on UCustomizationScrollBoxUserWidgetBase");
static_assert(offsetof(UCustomizationScrollBoxUserWidgetBase, ClassicItemGrid) == 0x000260, "Member 'UCustomizationScrollBoxUserWidgetBase::ClassicItemGrid' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidgetBase, ElegantItemGrid) == 0x000268, "Member 'UCustomizationScrollBoxUserWidgetBase::ElegantItemGrid' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidgetBase, LuxuriousItemGrid) == 0x000270, "Member 'UCustomizationScrollBoxUserWidgetBase::LuxuriousItemGrid' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidgetBase, ExtravagantItemGrid) == 0x000278, "Member 'UCustomizationScrollBoxUserWidgetBase::ExtravagantItemGrid' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidgetBase, SelectedCategoryButton) == 0x000280, "Member 'UCustomizationScrollBoxUserWidgetBase::SelectedCategoryButton' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidgetBase, CurrentQuality) == 0x000288, "Member 'UCustomizationScrollBoxUserWidgetBase::CurrentQuality' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidgetBase, ItemCards) == 0x000290, "Member 'UCustomizationScrollBoxUserWidgetBase::ItemCards' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidgetBase, WardrobeColumnsPerRow) == 0x0002E0, "Member 'UCustomizationScrollBoxUserWidgetBase::WardrobeColumnsPerRow' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidgetBase, SelectedRowName) == 0x0002E8, "Member 'UCustomizationScrollBoxUserWidgetBase::SelectedRowName' has a wrong offset!");

// Class SCT.CustomizationScrollBoxUserWidget
// 0x0080 (0x0378 - 0x02F8)
class UCustomizationScrollBoxUserWidget : public UCustomizationScrollBoxUserWidgetBase
{
public:
	class UControllerSelectionStateWidget*        ManlyButton;                                       // 0x02F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UControllerSelectionStateWidget*        GirlyButton;                                       // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridPanel*                             PresetGrid;                                        // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridPanel*                             SkintoneGrid;                                      // 0x0310(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridPanel*                             EyeColorGrid;                                      // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGridPanel*                             HairColorGrid;                                     // 0x0320(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECustomizationOption                          AppearanceOption;                                  // 0x0328(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCustomizationGender                    Gender;                                            // 0x0329(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A[0x6];                                      // 0x032A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SelectedPresetRow;                                 // 0x0330(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SelectedSkintoneRow;                               // 0x0340(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SelectedEyeColorRow;                               // 0x0350(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SelectedHairColorRow;                              // 0x0360(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AppearanceColumnsPerRow;                           // 0x0370(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UWidget* AppearanceVerticalBoundaryHit(EUINavigation InNavigation);
	class UWidget* HorizontalBoundaryHit(EUINavigation InNavigation);
	void K2_UpdateEyeMaterial(const class FString& Selected);
	void K2_UpdateHairColor(const class FString& Selected);
	void K2_UpdatePreset(const class FString& Selected);
	void K2_UpdateSkinMaterial(const class FString& Selected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationScrollBoxUserWidget">();
	}
	static class UCustomizationScrollBoxUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationScrollBoxUserWidget>();
	}
};
static_assert(alignof(UCustomizationScrollBoxUserWidget) == 0x000008, "Wrong alignment on UCustomizationScrollBoxUserWidget");
static_assert(sizeof(UCustomizationScrollBoxUserWidget) == 0x000378, "Wrong size on UCustomizationScrollBoxUserWidget");
static_assert(offsetof(UCustomizationScrollBoxUserWidget, ManlyButton) == 0x0002F8, "Member 'UCustomizationScrollBoxUserWidget::ManlyButton' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidget, GirlyButton) == 0x000300, "Member 'UCustomizationScrollBoxUserWidget::GirlyButton' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidget, PresetGrid) == 0x000308, "Member 'UCustomizationScrollBoxUserWidget::PresetGrid' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidget, SkintoneGrid) == 0x000310, "Member 'UCustomizationScrollBoxUserWidget::SkintoneGrid' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidget, EyeColorGrid) == 0x000318, "Member 'UCustomizationScrollBoxUserWidget::EyeColorGrid' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidget, HairColorGrid) == 0x000320, "Member 'UCustomizationScrollBoxUserWidget::HairColorGrid' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidget, AppearanceOption) == 0x000328, "Member 'UCustomizationScrollBoxUserWidget::AppearanceOption' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidget, Gender) == 0x000329, "Member 'UCustomizationScrollBoxUserWidget::Gender' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidget, SelectedPresetRow) == 0x000330, "Member 'UCustomizationScrollBoxUserWidget::SelectedPresetRow' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidget, SelectedSkintoneRow) == 0x000340, "Member 'UCustomizationScrollBoxUserWidget::SelectedSkintoneRow' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidget, SelectedEyeColorRow) == 0x000350, "Member 'UCustomizationScrollBoxUserWidget::SelectedEyeColorRow' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidget, SelectedHairColorRow) == 0x000360, "Member 'UCustomizationScrollBoxUserWidget::SelectedHairColorRow' has a wrong offset!");
static_assert(offsetof(UCustomizationScrollBoxUserWidget, AppearanceColumnsPerRow) == 0x000370, "Member 'UCustomizationScrollBoxUserWidget::AppearanceColumnsPerRow' has a wrong offset!");

// Class SCT.PartyLobbyWidget
// 0x0020 (0x0280 - 0x0260)
class UPartyLobbyWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x8];                                      // 0x0260(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         DebugPartyMembersUserIds;                          // 0x0268(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	bool                                          bDebugParty;                                       // 0x0278(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FString> GetDebugPartyMembers();
	bool IsDebugMode();
	void OnInviteToParty(const struct FAccelByteModelsPartyGetInvitedNotice& Notification);
	void OnJoinParty(const struct FAccelByteModelsPartyJoinResponse& Response);
	void OnKickedFromParty(const struct FAccelByteModelsGotKickedFromPartyNotice& Notification);
	void OnLeaveParty(const struct FAccelByteModelsLeavePartyNotice& Notification);
	void OnNewMemberJoinedParty(const struct FAccelByteModelsPartyJoinNotice& Notification);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyLobbyWidget">();
	}
	static class UPartyLobbyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyLobbyWidget>();
	}
};
static_assert(alignof(UPartyLobbyWidget) == 0x000008, "Wrong alignment on UPartyLobbyWidget");
static_assert(sizeof(UPartyLobbyWidget) == 0x000280, "Wrong size on UPartyLobbyWidget");
static_assert(offsetof(UPartyLobbyWidget, DebugPartyMembersUserIds) == 0x000268, "Member 'UPartyLobbyWidget::DebugPartyMembersUserIds' has a wrong offset!");
static_assert(offsetof(UPartyLobbyWidget, bDebugParty) == 0x000278, "Member 'UPartyLobbyWidget::bDebugParty' has a wrong offset!");

// Class SCT.AchievementObject
// 0x0008 (0x0040 - 0x0038)
class UAchievementObject : public UProgressionObject
{
public:
	class FName                                   AchievementName;                                   // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void GrantAchievement() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementObject">();
	}
	static class UAchievementObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementObject>();
	}
};
static_assert(alignof(UAchievementObject) == 0x000008, "Wrong alignment on UAchievementObject");
static_assert(sizeof(UAchievementObject) == 0x000040, "Wrong size on UAchievementObject");
static_assert(offsetof(UAchievementObject, AchievementName) == 0x000038, "Member 'UAchievementObject::AchievementName' has a wrong offset!");

// Class SCT.AgendaCoopKillEvent
// 0x0018 (0x0048 - 0x0030)
class UAgendaCoopKillEvent final : public UAgendaEvent
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bForceNull;                                        // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Call(class APlayerController* Grabber, class APlayerController* Killer, class APlayerController* Victim);
	void CallWithWorldContextObject(class APlayerController* Grabber, class APlayerController* Killer, class APlayerController* Victim, class AActor* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgendaCoopKillEvent">();
	}
	static class UAgendaCoopKillEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgendaCoopKillEvent>();
	}
};
static_assert(alignof(UAgendaCoopKillEvent) == 0x000008, "Wrong alignment on UAgendaCoopKillEvent");
static_assert(sizeof(UAgendaCoopKillEvent) == 0x000048, "Wrong size on UAgendaCoopKillEvent");
static_assert(offsetof(UAgendaCoopKillEvent, Event) == 0x000030, "Member 'UAgendaCoopKillEvent::Event' has a wrong offset!");
static_assert(offsetof(UAgendaCoopKillEvent, bForceNull) == 0x000040, "Member 'UAgendaCoopKillEvent::bForceNull' has a wrong offset!");

// Class SCT.Activateable
// 0x0000 (0x0028 - 0x0028)
class IActivateable final : public IInterface
{
public:
	void Activate();
	void Cancel();
	void Deactivate(bool WasCancelled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Activateable">();
	}
	static class IActivateable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IActivateable>();
	}
};
static_assert(alignof(IActivateable) == 0x000008, "Wrong alignment on IActivateable");
static_assert(sizeof(IActivateable) == 0x000028, "Wrong size on IActivateable");

// Class SCT.AgendaControllerEvent
// 0x0018 (0x0048 - 0x0030)
class UAgendaControllerEvent final : public UAgendaEvent
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bForceNull;                                        // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Call(class APlayerController* Controller);
	void CallWithWorldContextObject(class APlayerController* Controller, class AActor* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgendaControllerEvent">();
	}
	static class UAgendaControllerEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgendaControllerEvent>();
	}
};
static_assert(alignof(UAgendaControllerEvent) == 0x000008, "Wrong alignment on UAgendaControllerEvent");
static_assert(sizeof(UAgendaControllerEvent) == 0x000048, "Wrong size on UAgendaControllerEvent");
static_assert(offsetof(UAgendaControllerEvent, Event) == 0x000030, "Member 'UAgendaControllerEvent::Event' has a wrong offset!");
static_assert(offsetof(UAgendaControllerEvent, bForceNull) == 0x000040, "Member 'UAgendaControllerEvent::bForceNull' has a wrong offset!");

// Class SCT.AgendaControllerPowerEvent
// 0x0020 (0x0050 - 0x0030)
class UAgendaControllerPowerEvent final : public UAgendaEvent
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bForceNull;                                        // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPower>                     DebugPower;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Call(class APlayerController* Controller, TSubclassOf<class UPower> Power);
	void CallWithWorldContextObject(class APlayerController* Controller, TSubclassOf<class UPower> Power, class AActor* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgendaControllerPowerEvent">();
	}
	static class UAgendaControllerPowerEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgendaControllerPowerEvent>();
	}
};
static_assert(alignof(UAgendaControllerPowerEvent) == 0x000008, "Wrong alignment on UAgendaControllerPowerEvent");
static_assert(sizeof(UAgendaControllerPowerEvent) == 0x000050, "Wrong size on UAgendaControllerPowerEvent");
static_assert(offsetof(UAgendaControllerPowerEvent, Event) == 0x000030, "Member 'UAgendaControllerPowerEvent::Event' has a wrong offset!");
static_assert(offsetof(UAgendaControllerPowerEvent, bForceNull) == 0x000040, "Member 'UAgendaControllerPowerEvent::bForceNull' has a wrong offset!");
static_assert(offsetof(UAgendaControllerPowerEvent, DebugPower) == 0x000048, "Member 'UAgendaControllerPowerEvent::DebugPower' has a wrong offset!");

// Class SCT.AgendaCoopPowerEvent
// 0x0020 (0x0050 - 0x0030)
class UAgendaCoopPowerEvent final : public UAgendaEvent
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bForceNull;                                        // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPower>                     DebugPower;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Call(class APlayerController* InstigatorController, class APlayerController* TargetController, TSubclassOf<class UPower> PowerType);
	void CallWithWorldContextObject(class APlayerController* InstigatorController, class APlayerController* TargetController, TSubclassOf<class UPower> PowerType, class AActor* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgendaCoopPowerEvent">();
	}
	static class UAgendaCoopPowerEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgendaCoopPowerEvent>();
	}
};
static_assert(alignof(UAgendaCoopPowerEvent) == 0x000008, "Wrong alignment on UAgendaCoopPowerEvent");
static_assert(sizeof(UAgendaCoopPowerEvent) == 0x000050, "Wrong size on UAgendaCoopPowerEvent");
static_assert(offsetof(UAgendaCoopPowerEvent, Event) == 0x000030, "Member 'UAgendaCoopPowerEvent::Event' has a wrong offset!");
static_assert(offsetof(UAgendaCoopPowerEvent, bForceNull) == 0x000040, "Member 'UAgendaCoopPowerEvent::bForceNull' has a wrong offset!");
static_assert(offsetof(UAgendaCoopPowerEvent, DebugPower) == 0x000048, "Member 'UAgendaCoopPowerEvent::DebugPower' has a wrong offset!");

// Class SCT.AgendaObject
// 0x0010 (0x0048 - 0x0038)
class UAgendaObject : public UProgressionObject
{
public:
	class FName                                   ScoreEntry;                                        // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EScoreCondition                               ScoreCondition;                                    // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAgendaObjectState                            CurrentState;                                      // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GiveScore();
	void SetState(EAgendaObjectState State);
	void UpdateDescription();
	void UpdateProgression();

	class FString GetDescription() const;
	class FString GetProgression() const;
	EAgendaObjectState GetState() const;
	bool HasFailed() const;
	bool HasGivenScore() const;
	bool HasSucceeded() const;
	bool IsInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AgendaObject">();
	}
	static class UAgendaObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAgendaObject>();
	}
};
static_assert(alignof(UAgendaObject) == 0x000008, "Wrong alignment on UAgendaObject");
static_assert(sizeof(UAgendaObject) == 0x000048, "Wrong size on UAgendaObject");
static_assert(offsetof(UAgendaObject, ScoreEntry) == 0x000038, "Member 'UAgendaObject::ScoreEntry' has a wrong offset!");
static_assert(offsetof(UAgendaObject, ScoreCondition) == 0x000040, "Member 'UAgendaObject::ScoreCondition' has a wrong offset!");
static_assert(offsetof(UAgendaObject, CurrentState) == 0x000041, "Member 'UAgendaObject::CurrentState' has a wrong offset!");

// Class SCT.AppearanceCustomizationSettings
// 0x0050 (0x0270 - 0x0220)
class AAppearanceCustomizationSettings final : public AInfo
{
public:
	uint8                                         Pad_220[0x50];                                     // 0x0220(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetBodyCustomizationList();
	void GetFeetCustomizationList();
	void GetHeadCustomizationList();
	void GetLegsCustomizationList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AppearanceCustomizationSettings">();
	}
	static class AAppearanceCustomizationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAppearanceCustomizationSettings>();
	}
};
static_assert(alignof(AAppearanceCustomizationSettings) == 0x000008, "Wrong alignment on AAppearanceCustomizationSettings");
static_assert(sizeof(AAppearanceCustomizationSettings) == 0x000270, "Wrong size on AAppearanceCustomizationSettings");

// Class SCT.AsyncTaskAttributeChanged
// 0x0060 (0x0090 - 0x0030)
class UAsyncTaskAttributeChanged final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnAttributeChanged;                                // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAbilitySystemComponent*                AbilitySystemComponent;                            // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x48];                                      // 0x0048(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskAttributeChanged* ListenForAttributeChange(class UAbilitySystemComponent* AbilitySystemComponent_0, const struct FGameplayAttribute& Attribute);
	static class UAsyncTaskAttributeChanged* ListenForAttributesChange(class UAbilitySystemComponent* AbilitySystemComponent_0, const TArray<struct FGameplayAttribute>& Attributes);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskAttributeChanged">();
	}
	static class UAsyncTaskAttributeChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskAttributeChanged>();
	}
};
static_assert(alignof(UAsyncTaskAttributeChanged) == 0x000008, "Wrong alignment on UAsyncTaskAttributeChanged");
static_assert(sizeof(UAsyncTaskAttributeChanged) == 0x000090, "Wrong size on UAsyncTaskAttributeChanged");
static_assert(offsetof(UAsyncTaskAttributeChanged, OnAttributeChanged) == 0x000030, "Member 'UAsyncTaskAttributeChanged::OnAttributeChanged' has a wrong offset!");
static_assert(offsetof(UAsyncTaskAttributeChanged, AbilitySystemComponent) == 0x000040, "Member 'UAsyncTaskAttributeChanged::AbilitySystemComponent' has a wrong offset!");

// Class SCT.BlueprintConsolePrivilegeCheckerCallbackProxy
// 0x0038 (0x0068 - 0x0030)
class UBlueprintConsolePrivilegeCheckerCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBlueprintConsolePrivilegeCheckerCallbackProxy* CheckConsoleCommunicationPrivilege(class UObject* WorldContextObject, class APlayerController* InPlayerController);
	static class UBlueprintConsolePrivilegeCheckerCallbackProxy* CheckConsoleCrossplayPrivilege(class UObject* WorldContextObject, class APlayerController* InPlayerController);
	static class UBlueprintConsolePrivilegeCheckerCallbackProxy* CheckConsoleOnlinePrivilege(class UObject* WorldContextObject, class APlayerController* InPlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintConsolePrivilegeCheckerCallbackProxy">();
	}
	static class UBlueprintConsolePrivilegeCheckerCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintConsolePrivilegeCheckerCallbackProxy>();
	}
};
static_assert(alignof(UBlueprintConsolePrivilegeCheckerCallbackProxy) == 0x000008, "Wrong alignment on UBlueprintConsolePrivilegeCheckerCallbackProxy");
static_assert(sizeof(UBlueprintConsolePrivilegeCheckerCallbackProxy) == 0x000068, "Wrong size on UBlueprintConsolePrivilegeCheckerCallbackProxy");
static_assert(offsetof(UBlueprintConsolePrivilegeCheckerCallbackProxy, OnSuccess) == 0x000030, "Member 'UBlueprintConsolePrivilegeCheckerCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UBlueprintConsolePrivilegeCheckerCallbackProxy, OnFailure) == 0x000040, "Member 'UBlueprintConsolePrivilegeCheckerCallbackProxy::OnFailure' has a wrong offset!");

// Class SCT.BlueprintConsoleQueryBlockListCallbackProxy
// 0x0028 (0x0058 - 0x0030)
class UBlueprintConsoleQueryBlockListCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnComplete;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBlueprintConsoleQueryBlockListCallbackProxy* QueryConsoleBlockList(class UObject* WorldContextObject, class APlayerController* InPlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintConsoleQueryBlockListCallbackProxy">();
	}
	static class UBlueprintConsoleQueryBlockListCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintConsoleQueryBlockListCallbackProxy>();
	}
};
static_assert(alignof(UBlueprintConsoleQueryBlockListCallbackProxy) == 0x000008, "Wrong alignment on UBlueprintConsoleQueryBlockListCallbackProxy");
static_assert(sizeof(UBlueprintConsoleQueryBlockListCallbackProxy) == 0x000058, "Wrong size on UBlueprintConsoleQueryBlockListCallbackProxy");
static_assert(offsetof(UBlueprintConsoleQueryBlockListCallbackProxy, OnComplete) == 0x000030, "Member 'UBlueprintConsoleQueryBlockListCallbackProxy::OnComplete' has a wrong offset!");

// Class SCT.BlueprintFunctionLibrarySCT
// 0x0000 (0x0028 - 0x0028)
class UBlueprintFunctionLibrarySCT final : public UBlueprintFunctionLibrary
{
public:
	static class UPanelSlot* AddChildMenuToMenuController(class UObject* WorldContextObject, class UUserWidget* Menu, class UUserWidget* ParentMenu, bool SetFocus, bool NonInteractable, class USCTGameInstance* GameInstance);
	static void AddMenuToMenuController(class UObject* WorldContextObject, class UUserWidget* Menu, int32 ZOrder, bool NonInteractable, bool SetFocus, class USCTGameInstance* GameInstance);
	static void AddWorldOxygenLevel(class UObject* WorldContextObject, float Value);
	static void BlockModalsDuringEmergencyMeeting(class UObject* WorldContextObject);
	static bool CanReviewPS5Match(class UObject* WorldContextObject);
	static void ClearBlockedModalsDuringEmergencyMeeting(class UObject* WorldContextObject);
	static class FString ColorToHex(const struct FLinearColor& Color);
	static struct FMatchEndData CreateEndData(EEndConditions EndCondition, class UPlayerInfoGIS* PlayerInfo);
	static class UUserWidget* CreateOrganizedWidget(TSubclassOf<class UWidgetSCT> WidgetType, int32 behaviour, class AActor* WorldContextObject);
	static TArray<int32> CreateShuffledIndexArrayWithSelection(int32 Seed, int32 Count, int32* SelectedIndex);
	static void DisableLocalCharacterMovementBriefly(class UObject* WorldContextObject);
	static struct FSlateColor GetAgendaProgressionColor(EAgendaObjectState State);
	static class FString GetColoredCharacterText(class UObject* WorldContextObject, int32 PlayerId);
	static bool GetControllerConnectionState(class APlayerController* InPlayerController, bool* OutConnected, int32* OutControllerID);
	static struct FDeathEffectDetails GetDeathEffectDetails(const struct FGameplayEffectSpecHandle& Handle);
	static class UAbilitySystemComponent* GetExecutionSource(const struct FGameplayEffectCustomExecutionParameters& ExecutionParams);
	static class UAbilitySystemComponent* GetExecutionTarget(const struct FGameplayEffectCustomExecutionParameters& ExecutionParams);
	static void GetFilterdHighestFromActorToIntMap(const TMap<class AActor*, int32>& UnfilteredActorToInt, bool* DuplicateFound, TMap<class AActor*, int32>* OutFilteredActorToInt);
	static class UObject* GetGlobalObject(class UObject* WorldContextObject, TSubclassOf<class UObject> ObjectType);
	static void GetIntermediateLevelsFromProjectSettings(TMap<int32, class FString>* Levels);
	static struct FInputActionKeyMapping GetKeyFromCharacterInput(const class UObject* WorldContextObject, ECharacterInput Input);
	static ESCTControllerType GetLastControllerType(class UObject* WorldContextObject);
	static TArray<struct FLevelVoteData> GetLevelVoteData();
	static class ULevelVoteComponent* GetLevelVoteManager(class UObject* WorldContextObject);
	static class UTexture2D* GetLoadingScreenTexture(const class FString& TargetLevelURL);
	static class USkillcheckController* GetLocalSkillcheckController(class UObject* WorldContextObject);
	static class AClientEntryPC* GetMainMenuPlayerController(class UObject* WorldContextObject);
	static float GetMaxOxygen(class UObject* WorldContextObject);
	static int32 GetNumberOfPersonoids(class UObject* WorldContextObject);
	static int32 GetNumberOfResidents(class UObject* WorldContextObject);
	static class ASCTPlayerController* GetPlayerController(class AActor* Actor, bool PrintError);
	static EPlayerFaction GetPlayerFaction(class UObject* WorldContextObject, int32 PlayerId);
	static class FString GetProjectVersionHumanReadableName();
	static EPlayerFaction GetSelfFaction(class UObject* WorldContextObject);
	static class UTexture2D* GetSteamAvatarFromPlayerID(class UObject* WorldContextObject, int32 PlayerId);
	static class UTexture2D* GetSteamAvatarFromPlayerState(class UObject* WorldContextObject, const class ASCTPlayerState* PlayerState);
	static class UTexture2D* GetSteamAvatarFromSteamID(class UObject* WorldContextObject, const class FString& SteamID);
	static float GetTimeUntilFullyDrained(class UObject* WorldContextObject);
	static class UWidgetOrganizer* GetWidgetOrganizer(class AActor* WorldContextObject);
	static float GetWolrdOxygenPercent(class UObject* WorldContextObject);
	static float GetWorldOxygenLevel(class UObject* WorldContextObject);
	static class AWorldSettingsSCT* GetWorldSettingsSCT(class UObject* WorldContextObject);
	static bool HasReplicatedLocalPlayerStateSCT(class UObject* WorldContextObject);
	static bool HasWorldOxygen(class UObject* WorldContextObject);
	static class ASCTPlayerState* IDToPlayerState(class UObject* WorldContextObject, int32 PlayerId);
	static bool InitialLoadComplete(class UObject* WorldContextObject, class USCTGameInstance* GameInstance);
	static class FString IntegerToHex(const int32 Value, int32 MinDigits);
	static bool IsAlive(EFate Fate);
	static bool IsPlayerPersonoid(class UObject* WorldContextObject, int32 PlayerId);
	static bool IsPlayerResident(class UObject* WorldContextObject, int32 PlayerId);
	static bool IsSelfPersonoid(class UObject* WorldContextObject);
	static bool IsSelfResident(class UObject* WorldContextObject);
	static bool IsUsingControllerOnPC(class UObject* WorldContextObject);
	static bool IsValidPlayerID(int32 PlayerId);
	static bool IsWidgetInActiveMenu(class UObject* WorldContextObject, class UWidget* Widget);
	static bool IsWidgetInAnyMenu(class UObject* WorldContextObject, class UWidget* Widget);
	static class FText KeyToText(const struct FKey& Key);
	static class USaveGame* LoadGame(class UObject* WorldContextObject, const class FString& SlotName, class USCTGameInstance* GameInstance);
	static void PrintMissingTagsToScreen();
	static void RemoveBlockedModalsDuringEmergencyMeeting(class UObject* WorldContextObject);
	static void RemoveMenuFromMenuController(class UObject* WorldContextObject, class UUserWidget* Menu, class USCTGameInstance* GameInstance);
	static void ResetWorldOxygenLevel(class UObject* WorldContextObject);
	static bool SaveGame(class UObject* WorldContextObject, const class FString& SlotName, class USaveGame* SaveGame_0, class USCTGameInstance* GameInstance);
	static bool SaveGameWithMetaData(class UObject* WorldContextObject, const class FString& SlotName, class USaveGame* SaveGame, const class FText& DisplayName, const class FText& DisplaySubtitle, const class FText& DisplayDescription, const class FString& IconPath, int32 MaxBytes, bool KeepMetaData, class USCTGameInstance* GameInstance);
	static void SetDownedEffect(class UAbilitySystemComponent* Target, float Duration);
	static void SetOverlayDialogForMenuController(class UObject* WorldContextObject, class UUserWidget* Menu, int32 ZOrder, bool NonInteractable, class USCTGameInstance* GameInstance);
	static void SetSaveGameMetaData(class UObject* WorldContextObject, const class FString& SlotName, const class FText& DisplayName, const class FText& DisplaySubtitle, const class FText& DisplayDescription, const class FString& IconPath, int32 MaxBytes, class USCTGameInstance* GameInstance);
	static void SetWorldOxygenLevel(class UObject* WorldContextObject, float NewValue);
	static bool ShouldDisableAirlockInEditor(class UObject* WorldContextObject);
	static bool ShouldDisableIntroSequence(class UObject* WorldContextObject);
	static void ShowSystemInviteDialog(class UObject* WorldContextObject);
	static void ShowSystemMatchReviewDialog(class UObject* WorldContextObject);
	static void ShowSystemProfileForFriend(class UObject* WorldContextObject, const class FString& AccelByteId);
	static void ShowSystemProfileForPlayer(class UObject* WorldContextObject, class AActor* PlayerState);
	static void ShowSystemProfileWithPlatformID(class UObject* WorldContextObject, const class FString& PlatformId);
	static TArray<float> SortFloatArray(const TArray<float>& ToSort);
	static TArray<int32> SortIntegerArray(const TArray<int32>& ToSort);
	static void SubtractWorldOxygenLevel(class UObject* WorldContextObject, float Value);
	static int32 ToBitMask(int32 Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintFunctionLibrarySCT">();
	}
	static class UBlueprintFunctionLibrarySCT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintFunctionLibrarySCT>();
	}
};
static_assert(alignof(UBlueprintFunctionLibrarySCT) == 0x000008, "Wrong alignment on UBlueprintFunctionLibrarySCT");
static_assert(sizeof(UBlueprintFunctionLibrarySCT) == 0x000028, "Wrong size on UBlueprintFunctionLibrarySCT");

// Class SCT.BlueprintXboxUserSwitcherCallbackProxy
// 0x0040 (0x0070 - 0x0030)
class UBlueprintXboxUserSwitcherCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccessNewUser;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSuccessExistingUser;                             // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBlueprintXboxUserSwitcherCallbackProxy* XboxUserSwitch(class UObject* WorldContextObject, class APlayerController* InPlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintXboxUserSwitcherCallbackProxy">();
	}
	static class UBlueprintXboxUserSwitcherCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintXboxUserSwitcherCallbackProxy>();
	}
};
static_assert(alignof(UBlueprintXboxUserSwitcherCallbackProxy) == 0x000008, "Wrong alignment on UBlueprintXboxUserSwitcherCallbackProxy");
static_assert(sizeof(UBlueprintXboxUserSwitcherCallbackProxy) == 0x000070, "Wrong size on UBlueprintXboxUserSwitcherCallbackProxy");
static_assert(offsetof(UBlueprintXboxUserSwitcherCallbackProxy, OnSuccessNewUser) == 0x000030, "Member 'UBlueprintXboxUserSwitcherCallbackProxy::OnSuccessNewUser' has a wrong offset!");
static_assert(offsetof(UBlueprintXboxUserSwitcherCallbackProxy, OnSuccessExistingUser) == 0x000040, "Member 'UBlueprintXboxUserSwitcherCallbackProxy::OnSuccessExistingUser' has a wrong offset!");
static_assert(offsetof(UBlueprintXboxUserSwitcherCallbackProxy, OnFailure) == 0x000050, "Member 'UBlueprintXboxUserSwitcherCallbackProxy::OnFailure' has a wrong offset!");

// Class SCT.GlobalEvent
// 0x0008 (0x0030 - 0x0028)
class UGlobalEvent : public UObject
{
public:
	bool                                          bPrintOnBroadcast;                                 // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrintDuration;                                     // 0x002C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class FString GetBaseDebugString() const;
	class FString GetDebugString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalEvent">();
	}
	static class UGlobalEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalEvent>();
	}
};
static_assert(alignof(UGlobalEvent) == 0x000008, "Wrong alignment on UGlobalEvent");
static_assert(sizeof(UGlobalEvent) == 0x000030, "Wrong size on UGlobalEvent");
static_assert(offsetof(UGlobalEvent, bPrintOnBroadcast) == 0x000028, "Member 'UGlobalEvent::bPrintOnBroadcast' has a wrong offset!");
static_assert(offsetof(UGlobalEvent, PrintDuration) == 0x00002C, "Member 'UGlobalEvent::PrintDuration' has a wrong offset!");

// Class SCT.GlobalEventVoid
// 0x0010 (0x0040 - 0x0030)
class UGlobalEventVoid : public UGlobalEvent
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Broadcast() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalEventVoid">();
	}
	static class UGlobalEventVoid* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalEventVoid>();
	}
};
static_assert(alignof(UGlobalEventVoid) == 0x000008, "Wrong alignment on UGlobalEventVoid");
static_assert(sizeof(UGlobalEventVoid) == 0x000040, "Wrong size on UGlobalEventVoid");
static_assert(offsetof(UGlobalEventVoid, Event) == 0x000030, "Member 'UGlobalEventVoid::Event' has a wrong offset!");

// Class SCT.CachedItemsReplicated
// 0x0000 (0x0040 - 0x0040)
class UCachedItemsReplicated final : public UGlobalEventVoid
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CachedItemsReplicated">();
	}
	static class UCachedItemsReplicated* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCachedItemsReplicated>();
	}
};
static_assert(alignof(UCachedItemsReplicated) == 0x000008, "Wrong alignment on UCachedItemsReplicated");
static_assert(sizeof(UCachedItemsReplicated) == 0x000040, "Wrong size on UCachedItemsReplicated");

// Class SCT.Power
// 0x0090 (0x0440 - 0x03B0)
class UPower : public UGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             OnPowerChanged;                                    // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  OwnedTags;                                         // 0x03C0(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         CurrentStackSize;                                  // 0x03E0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AEquipablePower*                        EquipablePower;                                    // 0x03E8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AEquipablePower>            EquipablePowerClass;                               // 0x03F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastExecutionTime;                                 // 0x03F8(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UContextStaticMeshComponent> CurrentContextStaticMeshComponent;                 // 0x03FC(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionComponent*                  ActivatedInteractionComponents;                    // 0x0408(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPowerData*                             Data;                                              // 0x0410(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x28];                                     // 0x0418(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateEquipablePower();
	void CancelCurrentAbility();
	void CancelEquipablePower();
	void CancelInteraction();
	void ClientCancelInteraction();
	void ClientEndInteraction();
	void CommitGlobalCooldown();
	void CommitLocalCooldown();
	void CommitPowerCooldown();
	void CommitStacks();
	void ContextStaticMeshAdded(class UContextStaticMeshComponent* NewContextStaticMeshComponent);
	void ContextStaticMeshRemoved(class UContextStaticMeshComponent* RemovedContextStaticMeshComponent);
	void DeactivateEquipablePower();
	void DestroyEquipablePower();
	void Drop();
	void EndCurrentAbility();
	void EndInteraction();
	class FText GetActiveContextDescription();
	class FText GetContextDescription();
	class FText GetCooldownContextDescription();
	class FText GetDefaultContextDescriptionImplementation();
	class FText GetInactiveContextDescription();
	void HideEquipablePower();
	void K2_OnRep_EquipablePower();
	void OnAdded();
	void OnInputReleased(float Heldtime);
	void OnRemoved();
	void OnRep_CurrentStackSize();
	void OnRep_EquipablePower();
	void ShowEquipablePower();
	void StartInteraction();

	bool CanActivateAbility() const;
	bool CanAddMoreStacks() const;
	struct FInteractionPayload CreatePayload() const;
	float GetCooldownTotalDuration() const;
	const struct FPowerDetails GetDetails() const;
	struct FVector GetDropLocation() const;
	float GetGlobalCooldownEndTime() const;
	float GetGlobalCooldownTotalDuration() const;
	struct FInputActionKeyMapping GetKeyMapping() const;
	float GetLastExecutionTime() const;
	float GetLocalCooldownEndTime() const;
	float GetLocalCooldownEndTimeNative() const;
	float GetLocalCooldownTotalDuration() const;
	float GetLocalCooldownTotalDurationNative() const;
	float GetNetTime() const;
	float GetPowerCooldownEndTime() const;
	bool HasContextInteractionComponent() const;
	bool HasContextStaticMesh() const;
	bool IsAnyPowerInUse() const;
	bool IsNetAuthority() const;
	bool IsOnCooldown() const;
	bool IsOnGlobalCooldown() const;
	bool IsOnLocalCooldown() const;
	bool IsOnLocalCooldownNative() const;
	bool IsPretendAction() const;
	bool K2_CanUseContextSpec(const struct FContextSpec& Spec) const;
	class UInteractionComponent* K2_GetInteractionComponent() const;
	bool K2_IsPretendAction() const;
	bool ShouldShowContextUI() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Power">();
	}
	static class UPower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPower>();
	}
};
static_assert(alignof(UPower) == 0x000008, "Wrong alignment on UPower");
static_assert(sizeof(UPower) == 0x000440, "Wrong size on UPower");
static_assert(offsetof(UPower, OnPowerChanged) == 0x0003B0, "Member 'UPower::OnPowerChanged' has a wrong offset!");
static_assert(offsetof(UPower, OwnedTags) == 0x0003C0, "Member 'UPower::OwnedTags' has a wrong offset!");
static_assert(offsetof(UPower, CurrentStackSize) == 0x0003E0, "Member 'UPower::CurrentStackSize' has a wrong offset!");
static_assert(offsetof(UPower, EquipablePower) == 0x0003E8, "Member 'UPower::EquipablePower' has a wrong offset!");
static_assert(offsetof(UPower, EquipablePowerClass) == 0x0003F0, "Member 'UPower::EquipablePowerClass' has a wrong offset!");
static_assert(offsetof(UPower, LastExecutionTime) == 0x0003F8, "Member 'UPower::LastExecutionTime' has a wrong offset!");
static_assert(offsetof(UPower, CurrentContextStaticMeshComponent) == 0x0003FC, "Member 'UPower::CurrentContextStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(UPower, ActivatedInteractionComponents) == 0x000408, "Member 'UPower::ActivatedInteractionComponents' has a wrong offset!");
static_assert(offsetof(UPower, Data) == 0x000410, "Member 'UPower::Data' has a wrong offset!");

// Class SCT.Item
// 0x0000 (0x0440 - 0x0440)
class UItem : public UPower
{
public:
	const struct FItemDetails GetItemDetails() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Item">();
	}
	static class UItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItem>();
	}
};
static_assert(alignof(UItem) == 0x000008, "Wrong alignment on UItem");
static_assert(sizeof(UItem) == 0x000440, "Wrong size on UItem");

// Class SCT.ChampagneBottle
// 0x0000 (0x0440 - 0x0440)
class UChampagneBottle : public UItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChampagneBottle">();
	}
	static class UChampagneBottle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChampagneBottle>();
	}
};
static_assert(alignof(UChampagneBottle) == 0x000008, "Wrong alignment on UChampagneBottle");
static_assert(sizeof(UChampagneBottle) == 0x000440, "Wrong size on UChampagneBottle");

// Class SCT.PowerData
// 0x00D0 (0x0100 - 0x0030)
class UPowerData : public UPrimaryDataAsset
{
public:
	float                                         CooldownDuration;                                  // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxContextDistance;                                // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnique;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SavedDuringTravel;                                 // 0x0039(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyStartInteraction;                    // 0x003A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyEndInteraction;                      // 0x003B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyCancelInteraction;                   // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockOtherAbilities;                              // 0x003D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockMovement;                                    // 0x003E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockRotation;                                     // 0x003F(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForcePersonoidAppearance;                         // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlockAllCancelCalls;                              // 0x0041(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoCommitGlobalCooldown;                         // 0x0042(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UPower>>             SwapableTypes;                                     // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class FText                                   ItemName;                                          // 0x0058(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ItemDescription;                                   // 0x0070(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FString                                 PickupAudioEvent;                                  // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ItemIcon;                                          // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxStackSize;                                      // 0x00A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EContextPriority                              ContextPriority;                                   // 0x00A4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A5[0x3];                                       // 0x00A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     DropObject;                                        // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDropOnOwnerDeath;                                 // 0x00B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStacking;                                   // 0x00B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoCommitCooldown;                               // 0x00B2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroyEquipablePower;                        // 0x00B3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoHideEquipablePower;                           // 0x00B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndAbilityOnInputRelease;                         // 0x00B5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             DropRaycastCollisionChannel;                       // 0x00B6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B7[0x1];                                       // 0x00B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ContextRequiredTags;                               // 0x00B8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ContextBlockedTags;                                // 0x00D8(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bCanActivateWithoutCSM;                            // 0x00F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerData">();
	}
	static class UPowerData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerData>();
	}
};
static_assert(alignof(UPowerData) == 0x000008, "Wrong alignment on UPowerData");
static_assert(sizeof(UPowerData) == 0x000100, "Wrong size on UPowerData");
static_assert(offsetof(UPowerData, CooldownDuration) == 0x000030, "Member 'UPowerData::CooldownDuration' has a wrong offset!");
static_assert(offsetof(UPowerData, MaxContextDistance) == 0x000034, "Member 'UPowerData::MaxContextDistance' has a wrong offset!");
static_assert(offsetof(UPowerData, IsUnique) == 0x000038, "Member 'UPowerData::IsUnique' has a wrong offset!");
static_assert(offsetof(UPowerData, SavedDuringTravel) == 0x000039, "Member 'UPowerData::SavedDuringTravel' has a wrong offset!");
static_assert(offsetof(UPowerData, bAutomaticallyStartInteraction) == 0x00003A, "Member 'UPowerData::bAutomaticallyStartInteraction' has a wrong offset!");
static_assert(offsetof(UPowerData, bAutomaticallyEndInteraction) == 0x00003B, "Member 'UPowerData::bAutomaticallyEndInteraction' has a wrong offset!");
static_assert(offsetof(UPowerData, bAutomaticallyCancelInteraction) == 0x00003C, "Member 'UPowerData::bAutomaticallyCancelInteraction' has a wrong offset!");
static_assert(offsetof(UPowerData, bBlockOtherAbilities) == 0x00003D, "Member 'UPowerData::bBlockOtherAbilities' has a wrong offset!");
static_assert(offsetof(UPowerData, bBlockMovement) == 0x00003E, "Member 'UPowerData::bBlockMovement' has a wrong offset!");
static_assert(offsetof(UPowerData, bLockRotation) == 0x00003F, "Member 'UPowerData::bLockRotation' has a wrong offset!");
static_assert(offsetof(UPowerData, bForcePersonoidAppearance) == 0x000040, "Member 'UPowerData::bForcePersonoidAppearance' has a wrong offset!");
static_assert(offsetof(UPowerData, bBlockAllCancelCalls) == 0x000041, "Member 'UPowerData::bBlockAllCancelCalls' has a wrong offset!");
static_assert(offsetof(UPowerData, bAutoCommitGlobalCooldown) == 0x000042, "Member 'UPowerData::bAutoCommitGlobalCooldown' has a wrong offset!");
static_assert(offsetof(UPowerData, SwapableTypes) == 0x000048, "Member 'UPowerData::SwapableTypes' has a wrong offset!");
static_assert(offsetof(UPowerData, ItemName) == 0x000058, "Member 'UPowerData::ItemName' has a wrong offset!");
static_assert(offsetof(UPowerData, ItemDescription) == 0x000070, "Member 'UPowerData::ItemDescription' has a wrong offset!");
static_assert(offsetof(UPowerData, PickupAudioEvent) == 0x000088, "Member 'UPowerData::PickupAudioEvent' has a wrong offset!");
static_assert(offsetof(UPowerData, ItemIcon) == 0x000098, "Member 'UPowerData::ItemIcon' has a wrong offset!");
static_assert(offsetof(UPowerData, MaxStackSize) == 0x0000A0, "Member 'UPowerData::MaxStackSize' has a wrong offset!");
static_assert(offsetof(UPowerData, ContextPriority) == 0x0000A4, "Member 'UPowerData::ContextPriority' has a wrong offset!");
static_assert(offsetof(UPowerData, DropObject) == 0x0000A8, "Member 'UPowerData::DropObject' has a wrong offset!");
static_assert(offsetof(UPowerData, bDropOnOwnerDeath) == 0x0000B0, "Member 'UPowerData::bDropOnOwnerDeath' has a wrong offset!");
static_assert(offsetof(UPowerData, bEnableStacking) == 0x0000B1, "Member 'UPowerData::bEnableStacking' has a wrong offset!");
static_assert(offsetof(UPowerData, bAutoCommitCooldown) == 0x0000B2, "Member 'UPowerData::bAutoCommitCooldown' has a wrong offset!");
static_assert(offsetof(UPowerData, bAutoDestroyEquipablePower) == 0x0000B3, "Member 'UPowerData::bAutoDestroyEquipablePower' has a wrong offset!");
static_assert(offsetof(UPowerData, bAutoHideEquipablePower) == 0x0000B4, "Member 'UPowerData::bAutoHideEquipablePower' has a wrong offset!");
static_assert(offsetof(UPowerData, bEndAbilityOnInputRelease) == 0x0000B5, "Member 'UPowerData::bEndAbilityOnInputRelease' has a wrong offset!");
static_assert(offsetof(UPowerData, DropRaycastCollisionChannel) == 0x0000B6, "Member 'UPowerData::DropRaycastCollisionChannel' has a wrong offset!");
static_assert(offsetof(UPowerData, ContextRequiredTags) == 0x0000B8, "Member 'UPowerData::ContextRequiredTags' has a wrong offset!");
static_assert(offsetof(UPowerData, ContextBlockedTags) == 0x0000D8, "Member 'UPowerData::ContextBlockedTags' has a wrong offset!");
static_assert(offsetof(UPowerData, bCanActivateWithoutCSM) == 0x0000F8, "Member 'UPowerData::bCanActivateWithoutCSM' has a wrong offset!");

// Class SCT.ItemData
// 0x0008 (0x0108 - 0x0100)
class UItemData : public UPowerData
{
public:
	bool                                          IsPassive;                                         // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemData">();
	}
	static class UItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemData>();
	}
};
static_assert(alignof(UItemData) == 0x000008, "Wrong alignment on UItemData");
static_assert(sizeof(UItemData) == 0x000108, "Wrong size on UItemData");
static_assert(offsetof(UItemData, IsPassive) == 0x000100, "Member 'UItemData::IsPassive' has a wrong offset!");

// Class SCT.ChampagneBottleData
// 0x0000 (0x0108 - 0x0108)
class UChampagneBottleData final : public UItemData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChampagneBottleData">();
	}
	static class UChampagneBottleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UChampagneBottleData>();
	}
};
static_assert(alignof(UChampagneBottleData) == 0x000008, "Wrong alignment on UChampagneBottleData");
static_assert(sizeof(UChampagneBottleData) == 0x000108, "Wrong size on UChampagneBottleData");

// Class SCT.CharacterOxygenStateManager
// 0x0050 (0x0100 - 0x00B0)
class UCharacterOxygenStateManager final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnStateChanged;                                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnValueChanged;                                    // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         LowOxygenThreshold;                                // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CriticalOxygenThreshold;                           // 0x00D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            NormalEffect;                                      // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            LowEffect;                                         // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            CriticalEffect;                                    // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            EmptyEffect;                                       // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EOxygenState                                  CurrentState;                                      // 0x00F8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOxygenChanged(float OxygenValue);
	void OnRep_CurrentState();

	class AHumanoidCharacter* GetHumanoidOwner() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterOxygenStateManager">();
	}
	static class UCharacterOxygenStateManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterOxygenStateManager>();
	}
};
static_assert(alignof(UCharacterOxygenStateManager) == 0x000008, "Wrong alignment on UCharacterOxygenStateManager");
static_assert(sizeof(UCharacterOxygenStateManager) == 0x000100, "Wrong size on UCharacterOxygenStateManager");
static_assert(offsetof(UCharacterOxygenStateManager, OnStateChanged) == 0x0000B0, "Member 'UCharacterOxygenStateManager::OnStateChanged' has a wrong offset!");
static_assert(offsetof(UCharacterOxygenStateManager, OnValueChanged) == 0x0000C0, "Member 'UCharacterOxygenStateManager::OnValueChanged' has a wrong offset!");
static_assert(offsetof(UCharacterOxygenStateManager, LowOxygenThreshold) == 0x0000D0, "Member 'UCharacterOxygenStateManager::LowOxygenThreshold' has a wrong offset!");
static_assert(offsetof(UCharacterOxygenStateManager, CriticalOxygenThreshold) == 0x0000D4, "Member 'UCharacterOxygenStateManager::CriticalOxygenThreshold' has a wrong offset!");
static_assert(offsetof(UCharacterOxygenStateManager, NormalEffect) == 0x0000D8, "Member 'UCharacterOxygenStateManager::NormalEffect' has a wrong offset!");
static_assert(offsetof(UCharacterOxygenStateManager, LowEffect) == 0x0000E0, "Member 'UCharacterOxygenStateManager::LowEffect' has a wrong offset!");
static_assert(offsetof(UCharacterOxygenStateManager, CriticalEffect) == 0x0000E8, "Member 'UCharacterOxygenStateManager::CriticalEffect' has a wrong offset!");
static_assert(offsetof(UCharacterOxygenStateManager, EmptyEffect) == 0x0000F0, "Member 'UCharacterOxygenStateManager::EmptyEffect' has a wrong offset!");
static_assert(offsetof(UCharacterOxygenStateManager, CurrentState) == 0x0000F8, "Member 'UCharacterOxygenStateManager::CurrentState' has a wrong offset!");

// Class SCT.CharacterSCTEvent
// 0x0010 (0x0040 - 0x0030)
class UCharacterSCTEvent : public UGlobalEvent
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Broadcast(class ACharacterSCT* NewCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterSCTEvent">();
	}
	static class UCharacterSCTEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterSCTEvent>();
	}
};
static_assert(alignof(UCharacterSCTEvent) == 0x000008, "Wrong alignment on UCharacterSCTEvent");
static_assert(sizeof(UCharacterSCTEvent) == 0x000040, "Wrong size on UCharacterSCTEvent");
static_assert(offsetof(UCharacterSCTEvent, Event) == 0x000030, "Member 'UCharacterSCTEvent::Event' has a wrong offset!");

// Class SCT.CheatComponent
// 0x0018 (0x00C8 - 0x00B0)
class UCheatComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x18];                                      // 0x00B0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ListAllAbilities();
	void OutputSpec(struct FGameplayAbilitySpec* Spec);
	void ServerAddPower(TSubclassOf<class UPower> PowerType, class ACharacterSCT* SourceCharacter, int32 StacksToAdd);
	void ServerAssignToSlot(class UPower* Power, EInventorySlotID SlotId);
	void ServerChangeLevel(const struct FSoftObjectPath& ObjPath);
	void ServerClearInventory();
	void ServerClearSlot(EInventorySlotID SlotId);
	void ServerEndMatch();
	void ServerForcePostSeamlessTravel();
	void ServerForcePreSeamlessTravel();
	void ServerKillSelf();
	void ServerListAllAbilities();
	void ServerRemoveEffectsWithTag(class UAbilitySystemComponent* Target, const struct FGameplayTagContainer& Container);
	void ServerRemovePower(TSubclassOf<class UPower> PowerType, int32 StacksToRemove);
	void ServerResurrectSelf();
	void ServerSetOxygen(float Amount);
	void ServerSpawnInWorld(TSubclassOf<class AActor> ActorType, const struct FVector& Position);
	void ServerTeleportToLocation(const struct FTransform& Transform);
	void ServerToggleGodlungs();
	void ServerToggleImmunity();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheatComponent">();
	}
	static class UCheatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheatComponent>();
	}
};
static_assert(alignof(UCheatComponent) == 0x000008, "Wrong alignment on UCheatComponent");
static_assert(sizeof(UCheatComponent) == 0x0000C8, "Wrong size on UCheatComponent");

// Class SCT.InteractionComponent
// 0x0168 (0x0218 - 0x00B0)
class UInteractionComponent : public UActorComponent
{
public:
	float                                         CooldownDuration;                                  // 0x00B0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DefaultContextDescription;                         // 0x00B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	class FText                                   InactiveContextDescription;                        // 0x00D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	class FText                                   InProgressContextDescription;                      // 0x00E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	class FText                                   CooldownContextDescription;                        // 0x0100(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPublic)
	bool                                          bAllowMultiplayerInteraction;                      // 0x0118(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInteractionEnabled;                               // 0x0119(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11A[0x2];                                      // 0x011A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxDistance;                                       // 0x011C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ContextStaticMeshIdentifierTags;                   // 0x0120(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyCommit;                              // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyCommitCooldown;                      // 0x0141(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyCommitExecutions;                    // 0x0142(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyEndOnSuccess;                        // 0x0143(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockCharacterRotation;                            // 0x0144(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockCharacterMovement;                            // 0x0145(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_146[0x2];                                      // 0x0146(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnEnabledChanged;                                  // 0x0148(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionStarted;                              // 0x0158(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionEnded;                                // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionCancelled;                            // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInteractionSucceeded;                            // 0x0188(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FInteractionPayload>            InteractingActors;                                 // 0x0198(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<TScriptInterface<class IInteractionSubComponentInterface>> SubComponents;                                     // 0x01A8(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	int32                                         MaxExecutions;                                     // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentExecutions;                                 // 0x01BC(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LastExecutionTime;                                 // 0x01C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsVisible;                                        // 0x01C4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInteractionActive;                              // 0x01C5(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C6[0x2];                                      // 0x01C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class AGameStateBase*                         GameState;                                         // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FInteractionPayload                    CachedPayload;                                     // 0x01D0(0x0030)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_200[0x18];                                     // 0x0200(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSubComponent(TScriptInterface<class IInteractionSubComponentInterface> Component);
	void CancelInteraction(const struct FInteractionPayload& Payload);
	void CancelInteractionSelf();
	void CommitCooldown();
	void CommitInteraction();
	void ConsumeExecution();
	void EndInteraction(const struct FInteractionPayload& Payload, bool WasCancelled);
	void EndInteractionSelf();
	void EndTimerFinished();
	void InteractionCancelled(const struct FInteractionPayload& Payload);
	void InteractionEnded(const struct FInteractionPayload& Payload, bool WasCancelled);
	void InteractionStarted(const struct FInteractionPayload& Payload);
	void InteractionSuccessful();
	void MulticastSuccessfulInteraction();
	void OnIsVisibleChanged();
	void OnRep_IsVisible();
	void RemoveInteractingActor(const class AActor* Actor);
	void RemoveSubComponent(TScriptInterface<class IInteractionSubComponentInterface> Component);
	void SetActiveContextDescription(const class FText& Description);
	void SetAllowMultiplayerInteraction(bool Enabled);
	void SetCooldownContextDescription(const class FText& Description);
	void SetInactiveContextDescription(const class FText& Description);
	void SetInProgressContextDescription(const class FText& Description);
	void SetInteractionEnabled(bool Enabled);
	void StartInteraction(const struct FInteractionPayload& Payload);
	void SuccessfulInteraction();
	void ToggleIsVisible(bool Enabled);

	bool CanActivate(const struct FInteractionPayload& Payload) const;
	class FText GetActiveContextDescription(const struct FInteractionPayload& Payload) const;
	class FText GetContextDescription(const struct FInteractionPayload& Payload) const;
	class FText GetCooldownContextDescription(const struct FInteractionPayload& Payload) const;
	float GetCooldownEndTime() const;
	float GetCooldownTotalDuration() const;
	class FText GetInactiveContextDescription(const struct FInteractionPayload& Payload) const;
	class FText GetInProgressContextDescription(const struct FInteractionPayload& Payload) const;
	bool IsAnyPayloadControlled() const;
	bool IsInteractionActive() const;
	bool IsOnCooldown() const;
	bool IsVisible() const;
	bool ShouldLockCharacterRotation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionComponent">();
	}
	static class UInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionComponent>();
	}
};
static_assert(alignof(UInteractionComponent) == 0x000008, "Wrong alignment on UInteractionComponent");
static_assert(sizeof(UInteractionComponent) == 0x000218, "Wrong size on UInteractionComponent");
static_assert(offsetof(UInteractionComponent, CooldownDuration) == 0x0000B0, "Member 'UInteractionComponent::CooldownDuration' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, DefaultContextDescription) == 0x0000B8, "Member 'UInteractionComponent::DefaultContextDescription' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, InactiveContextDescription) == 0x0000D0, "Member 'UInteractionComponent::InactiveContextDescription' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, InProgressContextDescription) == 0x0000E8, "Member 'UInteractionComponent::InProgressContextDescription' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, CooldownContextDescription) == 0x000100, "Member 'UInteractionComponent::CooldownContextDescription' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bAllowMultiplayerInteraction) == 0x000118, "Member 'UInteractionComponent::bAllowMultiplayerInteraction' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bInteractionEnabled) == 0x000119, "Member 'UInteractionComponent::bInteractionEnabled' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, MaxDistance) == 0x00011C, "Member 'UInteractionComponent::MaxDistance' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, ContextStaticMeshIdentifierTags) == 0x000120, "Member 'UInteractionComponent::ContextStaticMeshIdentifierTags' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bAutomaticallyCommit) == 0x000140, "Member 'UInteractionComponent::bAutomaticallyCommit' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bAutomaticallyCommitCooldown) == 0x000141, "Member 'UInteractionComponent::bAutomaticallyCommitCooldown' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bAutomaticallyCommitExecutions) == 0x000142, "Member 'UInteractionComponent::bAutomaticallyCommitExecutions' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bAutomaticallyEndOnSuccess) == 0x000143, "Member 'UInteractionComponent::bAutomaticallyEndOnSuccess' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bLockCharacterRotation) == 0x000144, "Member 'UInteractionComponent::bLockCharacterRotation' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bLockCharacterMovement) == 0x000145, "Member 'UInteractionComponent::bLockCharacterMovement' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnEnabledChanged) == 0x000148, "Member 'UInteractionComponent::OnEnabledChanged' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnInteractionStarted) == 0x000158, "Member 'UInteractionComponent::OnInteractionStarted' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnInteractionEnded) == 0x000168, "Member 'UInteractionComponent::OnInteractionEnded' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnInteractionCancelled) == 0x000178, "Member 'UInteractionComponent::OnInteractionCancelled' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, OnInteractionSucceeded) == 0x000188, "Member 'UInteractionComponent::OnInteractionSucceeded' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, InteractingActors) == 0x000198, "Member 'UInteractionComponent::InteractingActors' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, SubComponents) == 0x0001A8, "Member 'UInteractionComponent::SubComponents' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, MaxExecutions) == 0x0001B8, "Member 'UInteractionComponent::MaxExecutions' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, CurrentExecutions) == 0x0001BC, "Member 'UInteractionComponent::CurrentExecutions' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, LastExecutionTime) == 0x0001C0, "Member 'UInteractionComponent::LastExecutionTime' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bIsVisible) == 0x0001C4, "Member 'UInteractionComponent::bIsVisible' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, bIsInteractionActive) == 0x0001C5, "Member 'UInteractionComponent::bIsInteractionActive' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, GameState) == 0x0001C8, "Member 'UInteractionComponent::GameState' has a wrong offset!");
static_assert(offsetof(UInteractionComponent, CachedPayload) == 0x0001D0, "Member 'UInteractionComponent::CachedPayload' has a wrong offset!");

// Class SCT.CheatInteractionComponent
// 0x0000 (0x0218 - 0x0218)
class UCheatInteractionComponent final : public UInteractionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CheatInteractionComponent">();
	}
	static class UCheatInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCheatInteractionComponent>();
	}
};
static_assert(alignof(UCheatInteractionComponent) == 0x000008, "Wrong alignment on UCheatInteractionComponent");
static_assert(sizeof(UCheatInteractionComponent) == 0x000218, "Wrong size on UCheatInteractionComponent");

// Class SCT.ClearCustomGameSettingsComponent
// 0x0000 (0x00B0 - 0x00B0)
class UClearCustomGameSettingsComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClearCustomGameSettingsComponent">();
	}
	static class UClearCustomGameSettingsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClearCustomGameSettingsComponent>();
	}
};
static_assert(alignof(UClearCustomGameSettingsComponent) == 0x000008, "Wrong alignment on UClearCustomGameSettingsComponent");
static_assert(sizeof(UClearCustomGameSettingsComponent) == 0x0000B0, "Wrong size on UClearCustomGameSettingsComponent");

// Class SCT.ClientInfoCacheGIS
// 0x0050 (0x0080 - 0x0030)
class UClientInfoCacheGIS final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	struct FLinearColor GetIdentificationColor(int32 PlayerId);
	class FString GetPSNID(int32 PlayerId);
	bool GetRunningOnPS5(int32 PlayerId);
	class FString GetSteamID(int32 PlayerId);
	class FString GetXboxLiveID(int32 PlayerId);
	void SetHasBeenReported(int32 PlayerId, bool HasBeenReported);

	TArray<struct FClientPlayerInfo> GetAllPlayerInfo() const;
	struct FClientPlayerInfo GetPlayerInfo(int32 PlayerId) const;
	bool HasIdentificationColor(int32 PlayerId) const;
	bool HasPlayerInfo(int32 PlayerId) const;
	bool HasPSNID(int32 PlayerId) const;
	bool HasRunningOnPS5(int32 PlayerId) const;
	bool HasSteamID(int32 PlayerId) const;
	bool HasXboxLiveID(int32 PlayerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientInfoCacheGIS">();
	}
	static class UClientInfoCacheGIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientInfoCacheGIS>();
	}
};
static_assert(alignof(UClientInfoCacheGIS) == 0x000008, "Wrong alignment on UClientInfoCacheGIS");
static_assert(sizeof(UClientInfoCacheGIS) == 0x000080, "Wrong size on UClientInfoCacheGIS");

// Class SCT.ContextChannel
// 0x0000 (0x0028 - 0x0028)
class UContextChannel : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextChannel">();
	}
	static class UContextChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextChannel>();
	}
};
static_assert(alignof(UContextChannel) == 0x000008, "Wrong alignment on UContextChannel");
static_assert(sizeof(UContextChannel) == 0x000028, "Wrong size on UContextChannel");

// Class SCT.ContextInputManager
// 0x0060 (0x0110 - 0x00B0)
class UContextInputManager final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnSpecsChanged;                                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x50];                                      // 0x00C0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextInputManager">();
	}
	static class UContextInputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextInputManager>();
	}
};
static_assert(alignof(UContextInputManager) == 0x000008, "Wrong alignment on UContextInputManager");
static_assert(sizeof(UContextInputManager) == 0x000110, "Wrong size on UContextInputManager");
static_assert(offsetof(UContextInputManager, OnSpecsChanged) == 0x0000B0, "Member 'UContextInputManager::OnSpecsChanged' has a wrong offset!");

// Class SCT.ContextItem
// 0x0000 (0x0440 - 0x0440)
class UContextItem : public UItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextItem">();
	}
	static class UContextItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextItem>();
	}
};
static_assert(alignof(UContextItem) == 0x000008, "Wrong alignment on UContextItem");
static_assert(sizeof(UContextItem) == 0x000440, "Wrong size on UContextItem");

// Class SCT.ContextPowerManager
// 0x00E8 (0x0198 - 0x00B0)
class UContextPowerManager final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  BlockedTags;                                       // 0x00B8(0x0020)(Edit, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponentSCT*             AbilitySystemComponent;                            // 0x00D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UContextSensor*                         ContextSensor;                                     // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UContextInputManager*                   InputManager;                                      // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, class UPowerChannel*>             Channels;                                          // 0x00F0(0x0050)(NativeAccessSpecifierPrivate)
	TMap<class UPower*, int32>                    ManagedPowers;                                     // 0x0140(0x0050)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_190[0x8];                                      // 0x0190(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbilitySpecRemoved(struct FGameplayAbilitySpec* Spec);
	void CheckForIncompatibleTags();
	void DisableManager();
	void EnableManager();
	void HighestPriorityCleared(class UPowerChannel* Channel, class UPower* ClearedPower);
	void HighestPrioritySet(class UPowerChannel* Channel);
	void SensorEnabledStateChanged(bool SensorEnabled);
	void SensorUpdate();
	void ServerSetPowerContextData(class UPower* Power, class UContextStaticMeshComponent* ContextStaticMeshComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextPowerManager">();
	}
	static class UContextPowerManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextPowerManager>();
	}
};
static_assert(alignof(UContextPowerManager) == 0x000008, "Wrong alignment on UContextPowerManager");
static_assert(sizeof(UContextPowerManager) == 0x000198, "Wrong size on UContextPowerManager");
static_assert(offsetof(UContextPowerManager, BlockedTags) == 0x0000B8, "Member 'UContextPowerManager::BlockedTags' has a wrong offset!");
static_assert(offsetof(UContextPowerManager, AbilitySystemComponent) == 0x0000D8, "Member 'UContextPowerManager::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(UContextPowerManager, ContextSensor) == 0x0000E0, "Member 'UContextPowerManager::ContextSensor' has a wrong offset!");
static_assert(offsetof(UContextPowerManager, InputManager) == 0x0000E8, "Member 'UContextPowerManager::InputManager' has a wrong offset!");
static_assert(offsetof(UContextPowerManager, Channels) == 0x0000F0, "Member 'UContextPowerManager::Channels' has a wrong offset!");
static_assert(offsetof(UContextPowerManager, ManagedPowers) == 0x000140, "Member 'UContextPowerManager::ManagedPowers' has a wrong offset!");

// Class SCT.ContextSensor
// 0x0190 (0x05F0 - 0x0460)
class UContextSensor final : public UCapsuleComponent
{
public:
	FMulticastInlineDelegateProperty_             K2_OnSpecAdded;                                    // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_470[0x18];                                     // 0x0470(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             K2_OnSpecRemoved;                                  // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_498[0x18];                                     // 0x0498(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             K2_OnSpecChanged;                                  // 0x04B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C0[0x18];                                     // 0x04C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             K2_OnAnySpecChanged;                               // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0x18];                                     // 0x04E8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             K2_OnSpecsUpdated;                                 // 0x0500(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_510[0x30];                                     // 0x0510(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  RequiredTags;                                      // 0x0540(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  BlockedTags;                                       // 0x0560(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  DisableSelfTags;                                   // 0x0580(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	float                                         UpdateInterval;                                    // 0x05A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                LineOfSightOffset;                                 // 0x05A4(0x000C)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionChannel                             LineOfSightChannel;                                // 0x05B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B1[0x27];                                     // 0x05B1(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraComponent*                       Camera;                                            // 0x05D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponentSCT*             OwnerAbilitySystemComponent;                       // 0x05E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableSensor();
	void EnableSensor();
	void ForceCheckVision();
	void OnOwnerTagsChanged();
	void OnSenseBegin(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnSenseEnd(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

	bool AnyHaveTag(struct FGameplayTagContainer* Container) const;
	TArray<struct FContextSpec> GetAllSpecs() const;
	TArray<struct FContextSpec> GetAllSpecsFromTag(struct FGameplayTagContainer* Container) const;
	struct FVector GetLineOfSightWorldPosition() const;
	struct FContextSpec GetSpecFromTag(struct FGameplayTagContainer* Container) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextSensor">();
	}
	static class UContextSensor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextSensor>();
	}
};
static_assert(alignof(UContextSensor) == 0x000010, "Wrong alignment on UContextSensor");
static_assert(sizeof(UContextSensor) == 0x0005F0, "Wrong size on UContextSensor");
static_assert(offsetof(UContextSensor, K2_OnSpecAdded) == 0x000460, "Member 'UContextSensor::K2_OnSpecAdded' has a wrong offset!");
static_assert(offsetof(UContextSensor, K2_OnSpecRemoved) == 0x000488, "Member 'UContextSensor::K2_OnSpecRemoved' has a wrong offset!");
static_assert(offsetof(UContextSensor, K2_OnSpecChanged) == 0x0004B0, "Member 'UContextSensor::K2_OnSpecChanged' has a wrong offset!");
static_assert(offsetof(UContextSensor, K2_OnAnySpecChanged) == 0x0004D8, "Member 'UContextSensor::K2_OnAnySpecChanged' has a wrong offset!");
static_assert(offsetof(UContextSensor, K2_OnSpecsUpdated) == 0x000500, "Member 'UContextSensor::K2_OnSpecsUpdated' has a wrong offset!");
static_assert(offsetof(UContextSensor, RequiredTags) == 0x000540, "Member 'UContextSensor::RequiredTags' has a wrong offset!");
static_assert(offsetof(UContextSensor, BlockedTags) == 0x000560, "Member 'UContextSensor::BlockedTags' has a wrong offset!");
static_assert(offsetof(UContextSensor, DisableSelfTags) == 0x000580, "Member 'UContextSensor::DisableSelfTags' has a wrong offset!");
static_assert(offsetof(UContextSensor, UpdateInterval) == 0x0005A0, "Member 'UContextSensor::UpdateInterval' has a wrong offset!");
static_assert(offsetof(UContextSensor, LineOfSightOffset) == 0x0005A4, "Member 'UContextSensor::LineOfSightOffset' has a wrong offset!");
static_assert(offsetof(UContextSensor, LineOfSightChannel) == 0x0005B0, "Member 'UContextSensor::LineOfSightChannel' has a wrong offset!");
static_assert(offsetof(UContextSensor, Camera) == 0x0005D8, "Member 'UContextSensor::Camera' has a wrong offset!");
static_assert(offsetof(UContextSensor, OwnerAbilitySystemComponent) == 0x0005E0, "Member 'UContextSensor::OwnerAbilitySystemComponent' has a wrong offset!");

// Class SCT.Skill
// 0x0000 (0x0440 - 0x0440)
class USkill : public UPower
{
public:
	const struct FSkillDetails GetSkillDetails() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Skill">();
	}
	static class USkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkill>();
	}
};
static_assert(alignof(USkill) == 0x000008, "Wrong alignment on USkill");
static_assert(sizeof(USkill) == 0x000440, "Wrong size on USkill");

// Class SCT.ContextSkill
// 0x0000 (0x0440 - 0x0440)
class UContextSkill : public USkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextSkill">();
	}
	static class UContextSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextSkill>();
	}
};
static_assert(alignof(UContextSkill) == 0x000008, "Wrong alignment on UContextSkill");
static_assert(sizeof(UContextSkill) == 0x000440, "Wrong size on UContextSkill");

// Class SCT.ContextStaticMeshComponent
// 0x0100 (0x05D0 - 0x04D0)
class UContextStaticMeshComponent final : public UStaticMeshComponent
{
public:
	uint8                                         Pad_4D0[0x8];                                      // 0x04D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGainedHighestPriority;                           // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAddedHighestPriority;                            // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLostHighestPriority;                             // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnRemovedHighestPriority;                          // 0x0508(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnToggleHighlightEffect;                           // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnComponentTagsReplicated;                         // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ComponentGameplayTags;                             // 0x0538(0x0020)(Edit, BlueprintVisible, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  InteractionComponentIdentifierTags;                // 0x0558(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FVector                                WidgetOffset;                                      // 0x0578(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInteractionType                              Type;                                              // 0x0584(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_585[0x3];                                      // 0x0585(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        AdditionalLineOfSightPoints;                       // 0x0588(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_598[0x18];                                     // 0x0598(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EContextPriority                              Priority;                                          // 0x05B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5B1[0x3];                                      // 0x05B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HighestPriorityCount;                              // 0x05B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FVector>                        AllLineOfSightLocalPoints;                         // 0x05B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bShouldShowHighlightEffect;                        // 0x05C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsBeingInteractedWith;                            // 0x05C9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5CA[0x6];                                      // 0x05CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConstructLineOfSightLocalPoints();
	void K2_OnRep_ComponentGameplayTags();
	void OnRep_ComponentGameplayTags();

	class UAbilitySystemComponentSCT* GetAbilitySystemComponentFromOwner() const;
	struct FGameplayTagContainer GetAbilitySystemComponentTagsFromOwner() const;
	struct FVector GetContextWidgetWorldPosition() const;
	bool HasValidInteractionComponent() const;
	bool IsHighestPriority() const;
	class UInteractionComponent* K2_GetInteractionComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextStaticMeshComponent">();
	}
	static class UContextStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextStaticMeshComponent>();
	}
};
static_assert(alignof(UContextStaticMeshComponent) == 0x000010, "Wrong alignment on UContextStaticMeshComponent");
static_assert(sizeof(UContextStaticMeshComponent) == 0x0005D0, "Wrong size on UContextStaticMeshComponent");
static_assert(offsetof(UContextStaticMeshComponent, OnGainedHighestPriority) == 0x0004D8, "Member 'UContextStaticMeshComponent::OnGainedHighestPriority' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, OnAddedHighestPriority) == 0x0004E8, "Member 'UContextStaticMeshComponent::OnAddedHighestPriority' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, OnLostHighestPriority) == 0x0004F8, "Member 'UContextStaticMeshComponent::OnLostHighestPriority' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, OnRemovedHighestPriority) == 0x000508, "Member 'UContextStaticMeshComponent::OnRemovedHighestPriority' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, OnToggleHighlightEffect) == 0x000518, "Member 'UContextStaticMeshComponent::OnToggleHighlightEffect' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, OnComponentTagsReplicated) == 0x000528, "Member 'UContextStaticMeshComponent::OnComponentTagsReplicated' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, ComponentGameplayTags) == 0x000538, "Member 'UContextStaticMeshComponent::ComponentGameplayTags' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, InteractionComponentIdentifierTags) == 0x000558, "Member 'UContextStaticMeshComponent::InteractionComponentIdentifierTags' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, WidgetOffset) == 0x000578, "Member 'UContextStaticMeshComponent::WidgetOffset' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, Type) == 0x000584, "Member 'UContextStaticMeshComponent::Type' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, AdditionalLineOfSightPoints) == 0x000588, "Member 'UContextStaticMeshComponent::AdditionalLineOfSightPoints' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, Priority) == 0x0005B0, "Member 'UContextStaticMeshComponent::Priority' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, HighestPriorityCount) == 0x0005B4, "Member 'UContextStaticMeshComponent::HighestPriorityCount' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, AllLineOfSightLocalPoints) == 0x0005B8, "Member 'UContextStaticMeshComponent::AllLineOfSightLocalPoints' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, bShouldShowHighlightEffect) == 0x0005C8, "Member 'UContextStaticMeshComponent::bShouldShowHighlightEffect' has a wrong offset!");
static_assert(offsetof(UContextStaticMeshComponent, bIsBeingInteractedWith) == 0x0005C9, "Member 'UContextStaticMeshComponent::bIsBeingInteractedWith' has a wrong offset!");

// Class SCT.ControllerDisconnectWidget
// 0x0018 (0x0278 - 0x0260)
class UControllerDisconnectWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonAPressed();
	void WaitForButtonPress();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerDisconnectWidget">();
	}
	static class UControllerDisconnectWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerDisconnectWidget>();
	}
};
static_assert(alignof(UControllerDisconnectWidget) == 0x000008, "Wrong alignment on UControllerDisconnectWidget");
static_assert(sizeof(UControllerDisconnectWidget) == 0x000278, "Wrong size on UControllerDisconnectWidget");

// Class SCT.ControllerHapticsComponent
// 0x0010 (0x0210 - 0x0200)
class UControllerHapticsComponent final : public USceneComponent
{
public:
	class UPlayerHapticsComponent*                PlayerHaptics;                                     // 0x01F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAudioComponent*                        PadAudioComponent;                                 // 0x0200(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        PadTactileComponent;                               // 0x0208(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void Play(const class UControllerHapticsData* HapticsData, class USoundAttenuation* SpatialAttenuation);
	void ResetUseKeyHaptics();
	void ResistUseKeyPress(float PressRangeStart, float PressRangeEnd, float Strength);
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerHapticsComponent">();
	}
	static class UControllerHapticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerHapticsComponent>();
	}
};
static_assert(alignof(UControllerHapticsComponent) == 0x000010, "Wrong alignment on UControllerHapticsComponent");
static_assert(sizeof(UControllerHapticsComponent) == 0x000210, "Wrong size on UControllerHapticsComponent");
static_assert(offsetof(UControllerHapticsComponent, PlayerHaptics) == 0x0001F8, "Member 'UControllerHapticsComponent::PlayerHaptics' has a wrong offset!");
static_assert(offsetof(UControllerHapticsComponent, PadAudioComponent) == 0x000200, "Member 'UControllerHapticsComponent::PadAudioComponent' has a wrong offset!");
static_assert(offsetof(UControllerHapticsComponent, PadTactileComponent) == 0x000208, "Member 'UControllerHapticsComponent::PadTactileComponent' has a wrong offset!");

// Class SCT.ControllerHapticsData
// 0x0020 (0x0050 - 0x0030)
class UControllerHapticsData final : public UPrimaryDataAsset
{
public:
	class USoundCue*                              PadAudioCue;                                       // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundCue*                              PadTactileCue;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   PadRumbleEffect;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TriggerRumbleFrequency;                            // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TriggerRumbleAmplitude;                            // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerHapticsData">();
	}
	static class UControllerHapticsData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerHapticsData>();
	}
};
static_assert(alignof(UControllerHapticsData) == 0x000008, "Wrong alignment on UControllerHapticsData");
static_assert(sizeof(UControllerHapticsData) == 0x000050, "Wrong size on UControllerHapticsData");
static_assert(offsetof(UControllerHapticsData, PadAudioCue) == 0x000030, "Member 'UControllerHapticsData::PadAudioCue' has a wrong offset!");
static_assert(offsetof(UControllerHapticsData, PadTactileCue) == 0x000038, "Member 'UControllerHapticsData::PadTactileCue' has a wrong offset!");
static_assert(offsetof(UControllerHapticsData, PadRumbleEffect) == 0x000040, "Member 'UControllerHapticsData::PadRumbleEffect' has a wrong offset!");
static_assert(offsetof(UControllerHapticsData, TriggerRumbleFrequency) == 0x000048, "Member 'UControllerHapticsData::TriggerRumbleFrequency' has a wrong offset!");
static_assert(offsetof(UControllerHapticsData, TriggerRumbleAmplitude) == 0x000049, "Member 'UControllerHapticsData::TriggerRumbleAmplitude' has a wrong offset!");

// Class SCT.ControllerIconData
// 0x0140 (0x0170 - 0x0030)
class UControllerIconData final : public UPrimaryDataAsset
{
public:
	TMap<struct FKey, class UTexture2D*>          XboxMap;                                           // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FKey, class UTexture2D*>          PS4Map;                                            // 0x0080(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FKey, class UTexture2D*>          PS5Map;                                            // 0x00D0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<struct FKey, class UTexture2D*>          MouseMap;                                          // 0x0120(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	class UTexture2D* GetControllerIconForKey(const struct FKey& Key, ESCTControllerType ControllerType, bool OverridePlatformSetting);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerIconData">();
	}
	static class UControllerIconData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerIconData>();
	}
};
static_assert(alignof(UControllerIconData) == 0x000008, "Wrong alignment on UControllerIconData");
static_assert(sizeof(UControllerIconData) == 0x000170, "Wrong size on UControllerIconData");
static_assert(offsetof(UControllerIconData, XboxMap) == 0x000030, "Member 'UControllerIconData::XboxMap' has a wrong offset!");
static_assert(offsetof(UControllerIconData, PS4Map) == 0x000080, "Member 'UControllerIconData::PS4Map' has a wrong offset!");
static_assert(offsetof(UControllerIconData, PS5Map) == 0x0000D0, "Member 'UControllerIconData::PS5Map' has a wrong offset!");
static_assert(offsetof(UControllerIconData, MouseMap) == 0x000120, "Member 'UControllerIconData::MouseMap' has a wrong offset!");

// Class SCT.ControllerIconWidget
// 0x0050 (0x02B0 - 0x0260)
class UControllerIconWidget : public UUserWidget
{
public:
	class FName                                   ActionMapping;                                     // 0x0260(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UControllerIconData*                    ControllerIconData;                                // 0x0268(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowGamepadDisplay;                              // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowMouseDisplay;                                // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnShowKeyboardDisplay;                             // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResetDisplay;                                    // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void OnRefreshDisplay();
	void RefreshDisplay();
	void ResetDisplay();
	void ShowGamepadDisplay(class UTexture2D* ButtonIcon);
	void ShowKeyboardDisplay(const class FText& KeyDisplayText);
	void ShowMouseDisplay(class UTexture2D* MouseIcon);

	class FText GetCurrentKeyText() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerIconWidget">();
	}
	static class UControllerIconWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerIconWidget>();
	}
};
static_assert(alignof(UControllerIconWidget) == 0x000008, "Wrong alignment on UControllerIconWidget");
static_assert(sizeof(UControllerIconWidget) == 0x0002B0, "Wrong size on UControllerIconWidget");
static_assert(offsetof(UControllerIconWidget, ActionMapping) == 0x000260, "Member 'UControllerIconWidget::ActionMapping' has a wrong offset!");
static_assert(offsetof(UControllerIconWidget, ControllerIconData) == 0x000268, "Member 'UControllerIconWidget::ControllerIconData' has a wrong offset!");
static_assert(offsetof(UControllerIconWidget, OnShowGamepadDisplay) == 0x000270, "Member 'UControllerIconWidget::OnShowGamepadDisplay' has a wrong offset!");
static_assert(offsetof(UControllerIconWidget, OnShowMouseDisplay) == 0x000280, "Member 'UControllerIconWidget::OnShowMouseDisplay' has a wrong offset!");
static_assert(offsetof(UControllerIconWidget, OnShowKeyboardDisplay) == 0x000290, "Member 'UControllerIconWidget::OnShowKeyboardDisplay' has a wrong offset!");
static_assert(offsetof(UControllerIconWidget, OnResetDisplay) == 0x0002A0, "Member 'UControllerIconWidget::OnResetDisplay' has a wrong offset!");

// Class SCT.ControllerInputWidget
// 0x0050 (0x0300 - 0x02B0)
class UControllerInputWidget : public UControllerIconWidget
{
public:
	TMap<class UTexture2D*, class UTexture2D*>    PSNRegionIconConversionMap;                        // 0x02B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void ListenForInputActionByPSNRegion(const class FName ActionName, const EInputEvent EventType, const bool bConsume, const TDelegate<void()> Callback);

	class FName GetPressedInputActionName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerInputWidget">();
	}
	static class UControllerInputWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerInputWidget>();
	}
};
static_assert(alignof(UControllerInputWidget) == 0x000008, "Wrong alignment on UControllerInputWidget");
static_assert(sizeof(UControllerInputWidget) == 0x000300, "Wrong size on UControllerInputWidget");
static_assert(offsetof(UControllerInputWidget, PSNRegionIconConversionMap) == 0x0002B0, "Member 'UControllerInputWidget::PSNRegionIconConversionMap' has a wrong offset!");

// Class SCT.ControllerSelectionStateWidget
// 0x0278 (0x0578 - 0x0300)
class UControllerSelectionStateWidget : public UControllerInputWidget
{
public:
	class UImage*                                 CosmeticImage;                                     // 0x0300(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                SelectButton;                                      // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateBrush                            NormalStyle;                                       // 0x0310(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            HoveredStyle;                                      // 0x0398(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            PressedStyle;                                      // 0x0420(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FSlateBrush                            SelectedStyle;                                     // 0x04A8(0x0088)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHovered;                                         // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnhovered;                                       // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPressed;                                         // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSelected;                                        // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bHasPersistentSelectedState;                       // 0x0570(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetNormalCosmeticsOnSelectionReleased;            // 0x0571(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasCosmetics;                                     // 0x0572(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelected;                                       // 0x0573(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_574[0x4];                                      // 0x0574(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_EventOnSelectionPressed();
	void K2_EventOnSelectionReleased();
	void K2_EventOnSetHoveredCosmetics();
	void K2_EventOnSetNormalCosmetics();
	void K2_EventOnSetPressedCosmetics();
	void K2_EventOnSetSelectedCosmetics();
	void OnButtonHovered();
	void OnButtonPressed();
	void OnButtonReleased();
	void OnButtonUnhovered();
	void SetHoveredCosmetics();
	void SetNormalCosmetics();
	void SetPressedCosmetics();
	void SetSelectedCosmetics();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ControllerSelectionStateWidget">();
	}
	static class UControllerSelectionStateWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UControllerSelectionStateWidget>();
	}
};
static_assert(alignof(UControllerSelectionStateWidget) == 0x000008, "Wrong alignment on UControllerSelectionStateWidget");
static_assert(sizeof(UControllerSelectionStateWidget) == 0x000578, "Wrong size on UControllerSelectionStateWidget");
static_assert(offsetof(UControllerSelectionStateWidget, CosmeticImage) == 0x000300, "Member 'UControllerSelectionStateWidget::CosmeticImage' has a wrong offset!");
static_assert(offsetof(UControllerSelectionStateWidget, SelectButton) == 0x000308, "Member 'UControllerSelectionStateWidget::SelectButton' has a wrong offset!");
static_assert(offsetof(UControllerSelectionStateWidget, NormalStyle) == 0x000310, "Member 'UControllerSelectionStateWidget::NormalStyle' has a wrong offset!");
static_assert(offsetof(UControllerSelectionStateWidget, HoveredStyle) == 0x000398, "Member 'UControllerSelectionStateWidget::HoveredStyle' has a wrong offset!");
static_assert(offsetof(UControllerSelectionStateWidget, PressedStyle) == 0x000420, "Member 'UControllerSelectionStateWidget::PressedStyle' has a wrong offset!");
static_assert(offsetof(UControllerSelectionStateWidget, SelectedStyle) == 0x0004A8, "Member 'UControllerSelectionStateWidget::SelectedStyle' has a wrong offset!");
static_assert(offsetof(UControllerSelectionStateWidget, OnHovered) == 0x000530, "Member 'UControllerSelectionStateWidget::OnHovered' has a wrong offset!");
static_assert(offsetof(UControllerSelectionStateWidget, OnUnhovered) == 0x000540, "Member 'UControllerSelectionStateWidget::OnUnhovered' has a wrong offset!");
static_assert(offsetof(UControllerSelectionStateWidget, OnPressed) == 0x000550, "Member 'UControllerSelectionStateWidget::OnPressed' has a wrong offset!");
static_assert(offsetof(UControllerSelectionStateWidget, OnSelected) == 0x000560, "Member 'UControllerSelectionStateWidget::OnSelected' has a wrong offset!");
static_assert(offsetof(UControllerSelectionStateWidget, bHasPersistentSelectedState) == 0x000570, "Member 'UControllerSelectionStateWidget::bHasPersistentSelectedState' has a wrong offset!");
static_assert(offsetof(UControllerSelectionStateWidget, bSetNormalCosmeticsOnSelectionReleased) == 0x000571, "Member 'UControllerSelectionStateWidget::bSetNormalCosmeticsOnSelectionReleased' has a wrong offset!");
static_assert(offsetof(UControllerSelectionStateWidget, bHasCosmetics) == 0x000572, "Member 'UControllerSelectionStateWidget::bHasCosmetics' has a wrong offset!");
static_assert(offsetof(UControllerSelectionStateWidget, bIsSelected) == 0x000573, "Member 'UControllerSelectionStateWidget::bIsSelected' has a wrong offset!");

// Class SCT.CoopKillCharacterSkill
// 0x0000 (0x0440 - 0x0440)
class UCoopKillCharacterSkill : public UContextSkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoopKillCharacterSkill">();
	}
	static class UCoopKillCharacterSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoopKillCharacterSkill>();
	}
};
static_assert(alignof(UCoopKillCharacterSkill) == 0x000008, "Wrong alignment on UCoopKillCharacterSkill");
static_assert(sizeof(UCoopKillCharacterSkill) == 0x000440, "Wrong size on UCoopKillCharacterSkill");

// Class SCT.CustomGameSettingsGIS
// 0x0078 (0x00A8 - 0x0030)
class UCustomGameSettingsGIS final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnCustomGameSettingsApplied;                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FCustomGameSettings                    HostCachedSettings;                                // 0x0040(0x0034)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCustomGameSettings                    GameSettings;                                      // 0x0074(0x0034)(NoDestructor, NativeAccessSpecifierPrivate)

public:
	bool ArePersonoidsHidden();
	void CacheHostSettings(const struct FCustomGameSettings& Settings);
	void ClearHostSettings();
	int32 GetAmountOfSyringes();
	struct FCustomGameSettings GetCustomGameSettings();
	int32 GetIntermediateLevels();
	int32 GetMaxPersonoids();
	int32 GetMinPersonoids();
	float GetOxygenCanisterMultiplier();
	float GetOxygenGeneratorFailedMultiplier();
	float GetOxygenGeneratorRepairMultiplier();
	float GetOxygenGeneratorSabotageMultiplier();
	float GetOxygenMultiplier();
	float GetOxygenOutletSabotageMultiplier();
	float GetPassengerLogSpawnMultiplier();
	bool HasGameSettings();
	bool IsCatastropheEventEnabled();

	bool HasHostSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomGameSettingsGIS">();
	}
	static class UCustomGameSettingsGIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomGameSettingsGIS>();
	}
};
static_assert(alignof(UCustomGameSettingsGIS) == 0x000008, "Wrong alignment on UCustomGameSettingsGIS");
static_assert(sizeof(UCustomGameSettingsGIS) == 0x0000A8, "Wrong size on UCustomGameSettingsGIS");
static_assert(offsetof(UCustomGameSettingsGIS, OnCustomGameSettingsApplied) == 0x000030, "Member 'UCustomGameSettingsGIS::OnCustomGameSettingsApplied' has a wrong offset!");
static_assert(offsetof(UCustomGameSettingsGIS, HostCachedSettings) == 0x000040, "Member 'UCustomGameSettingsGIS::HostCachedSettings' has a wrong offset!");
static_assert(offsetof(UCustomGameSettingsGIS, GameSettings) == 0x000074, "Member 'UCustomGameSettingsGIS::GameSettings' has a wrong offset!");

// Class SCT.CustomizationGenderUserWidget
// 0x0020 (0x0280 - 0x0260)
class UCustomizationGenderUserWidget : public UUserWidget
{
public:
	class ACustomizationOptions*                  AppearanceSettings;                                // 0x0260(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                MasculineSwapButton;                               // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UButton*                                FeminineSwapButton;                                // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerCustomizationGender                    Gender;                                            // 0x0278(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Init(TSubclassOf<class ACustomizationOptions> OptionsClass, struct FCloudCustomizationPayload& RecordPayload);
	void K2_UpdateEyeMaterial(const class FString& Selected);
	void K2_UpdateHairColor(const class FString& Selected);
	void K2_UpdatePreset(const class FString& Selected);
	void K2_UpdatePrimaryPatternMaterial(const class FString& Selected);
	void K2_UpdateSecondaryPatternMaterial(const class FString& Selected);
	void K2_UpdateSkinMaterial(const class FString& Selected);
	void ValidateCustomizationRecord(struct FCloudCustomizationPayload& UnverifiedRecord);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationGenderUserWidget">();
	}
	static class UCustomizationGenderUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationGenderUserWidget>();
	}
};
static_assert(alignof(UCustomizationGenderUserWidget) == 0x000008, "Wrong alignment on UCustomizationGenderUserWidget");
static_assert(sizeof(UCustomizationGenderUserWidget) == 0x000280, "Wrong size on UCustomizationGenderUserWidget");
static_assert(offsetof(UCustomizationGenderUserWidget, AppearanceSettings) == 0x000260, "Member 'UCustomizationGenderUserWidget::AppearanceSettings' has a wrong offset!");
static_assert(offsetof(UCustomizationGenderUserWidget, MasculineSwapButton) == 0x000268, "Member 'UCustomizationGenderUserWidget::MasculineSwapButton' has a wrong offset!");
static_assert(offsetof(UCustomizationGenderUserWidget, FeminineSwapButton) == 0x000270, "Member 'UCustomizationGenderUserWidget::FeminineSwapButton' has a wrong offset!");
static_assert(offsetof(UCustomizationGenderUserWidget, Gender) == 0x000278, "Member 'UCustomizationGenderUserWidget::Gender' has a wrong offset!");

// Class SCT.VruumbaCustomizationScrollBoxUserWidget
// 0x0000 (0x02F8 - 0x02F8)
class UVruumbaCustomizationScrollBoxUserWidget : public UCustomizationScrollBoxUserWidgetBase
{
public:
	class UWidget* HorizontalBoundaryHit(EUINavigation InNavigation);
	void K2_UpdateAntenna(const class FString& Selected);
	void K2_UpdateBody(const class FString& Selected);
	void K2_UpdateExhaust(const class FString& Selected);
	void K2_UpdateFan(const class FString& Selected);
	void K2_UpdateFlag(const class FString& Selected);
	void K2_UpdateParticleEffect(const class FString& Selected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VruumbaCustomizationScrollBoxUserWidget">();
	}
	static class UVruumbaCustomizationScrollBoxUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UVruumbaCustomizationScrollBoxUserWidget>();
	}
};
static_assert(alignof(UVruumbaCustomizationScrollBoxUserWidget) == 0x000008, "Wrong alignment on UVruumbaCustomizationScrollBoxUserWidget");
static_assert(sizeof(UVruumbaCustomizationScrollBoxUserWidget) == 0x0002F8, "Wrong size on UVruumbaCustomizationScrollBoxUserWidget");

// Class SCT.CustomizationOptions
// 0x00C0 (0x02E0 - 0x0220)
class ACustomizationOptions : public AActor
{
public:
	TArray<struct FPlayerCustomizationPreset>     CharacterPresetOptions;                            // 0x0220(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerCustomizationColorMaterial> SkinToneOptions;                                   // 0x0230(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerCustomizationColorMaterial> EyeColorOptions;                                   // 0x0240(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerCustomizationItem>       HeadOptions;                                       // 0x0250(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerCustomizationItem>       EyewearOptions;                                    // 0x0260(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerCustomizationItem>       BodyOptions;                                       // 0x0270(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerCustomizationItem>       LegOptions;                                        // 0x0280(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerCustomizationItem>       FeetOptions;                                       // 0x0290(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerEntitlementCustomizationItem> HeadEntitlements;                                  // 0x02A0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerEntitlementCustomizationItem> BodyEntitlements;                                  // 0x02B0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerEntitlementCustomizationItem> LegsEntitlements;                                  // 0x02C0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPlayerEntitlementCustomizationItem> FeetEntitlements;                                  // 0x02D0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void AddEyeColor(const struct FLinearColor& ThumbnailColor, class UMaterialInstance* SkinMaterial);
	void AddPreset(class UTexture2D* IconThumbnail, const TMap<class FString, float>& MorphTargets);
	void AddSkinTone(const struct FLinearColor& ThumbnailColor, class UMaterialInstance* SkinMaterial);
	void AddWardrobeOption(ECustomizationOption Type, class UTexture2D* IconThumbnail, class UStreamableRenderAsset* Mesh, const TArray<class UMaterialInstance*>& PrimaryPatterns, const TArray<class UMaterialInstance*>& SecondaryPatterns, const TArray<int32>& PatternCost, int32 UnlockLevel, class UTexture2D* CharacterMask, bool DoMaskLegs);
	void CreateCustomizationOptions();
	void K2_CreateBodyAppearanceOptions();
	void K2_CreateCharacterPresetOptions();
	void K2_CreateCharacterSkinToneOptions();
	void K2_CreateEntitlementsLists();
	void K2_CreateEyeColorOptions();
	void K2_CreateEyewearAppearanceOptions();
	void K2_CreateFeetAppearanceOptions();
	void K2_CreateHeadAppearanceOptions();
	void K2_CreateLegsAppearanceOptions();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationOptions">();
	}
	static class ACustomizationOptions* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACustomizationOptions>();
	}
};
static_assert(alignof(ACustomizationOptions) == 0x000008, "Wrong alignment on ACustomizationOptions");
static_assert(sizeof(ACustomizationOptions) == 0x0002E0, "Wrong size on ACustomizationOptions");
static_assert(offsetof(ACustomizationOptions, CharacterPresetOptions) == 0x000220, "Member 'ACustomizationOptions::CharacterPresetOptions' has a wrong offset!");
static_assert(offsetof(ACustomizationOptions, SkinToneOptions) == 0x000230, "Member 'ACustomizationOptions::SkinToneOptions' has a wrong offset!");
static_assert(offsetof(ACustomizationOptions, EyeColorOptions) == 0x000240, "Member 'ACustomizationOptions::EyeColorOptions' has a wrong offset!");
static_assert(offsetof(ACustomizationOptions, HeadOptions) == 0x000250, "Member 'ACustomizationOptions::HeadOptions' has a wrong offset!");
static_assert(offsetof(ACustomizationOptions, EyewearOptions) == 0x000260, "Member 'ACustomizationOptions::EyewearOptions' has a wrong offset!");
static_assert(offsetof(ACustomizationOptions, BodyOptions) == 0x000270, "Member 'ACustomizationOptions::BodyOptions' has a wrong offset!");
static_assert(offsetof(ACustomizationOptions, LegOptions) == 0x000280, "Member 'ACustomizationOptions::LegOptions' has a wrong offset!");
static_assert(offsetof(ACustomizationOptions, FeetOptions) == 0x000290, "Member 'ACustomizationOptions::FeetOptions' has a wrong offset!");
static_assert(offsetof(ACustomizationOptions, HeadEntitlements) == 0x0002A0, "Member 'ACustomizationOptions::HeadEntitlements' has a wrong offset!");
static_assert(offsetof(ACustomizationOptions, BodyEntitlements) == 0x0002B0, "Member 'ACustomizationOptions::BodyEntitlements' has a wrong offset!");
static_assert(offsetof(ACustomizationOptions, LegsEntitlements) == 0x0002C0, "Member 'ACustomizationOptions::LegsEntitlements' has a wrong offset!");
static_assert(offsetof(ACustomizationOptions, FeetEntitlements) == 0x0002D0, "Member 'ACustomizationOptions::FeetEntitlements' has a wrong offset!");

// Class SCT.CustomizationMenuUserWidget
// 0x0088 (0x02E8 - 0x0260)
class UCustomizationMenuUserWidget : public UUserWidget
{
public:
	EPlayerCustomizationGender                    SelectedGender;                                    // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        GenderSwitcher;                                    // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             ZoomText;                                          // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FocusedGenderButtonSize;                           // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UnfocusedGenderButtonSize;                         // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ClassicColor;                                      // 0x0288(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ElegantColor;                                      // 0x0298(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LuxuriousColor;                                    // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ExtravagentColor;                                  // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnChangeGenderMenu;                                // 0x02C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnZoomInOnCharacter;                               // 0x02D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	void InitializeMenuTabs(bool IsMale);
	void SwitchToFemaleMenu();
	void SwitchToMaleMenu();
	void UpdateGenderTabStates(class UButton* FocusedGenderButton, class UButton* UnfocusedGenderButton);
	void ZoomInOnCharacter(EPlayerCustomizationType Category);
	void ZoomOutOfCharacter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationMenuUserWidget">();
	}
	static class UCustomizationMenuUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationMenuUserWidget>();
	}
};
static_assert(alignof(UCustomizationMenuUserWidget) == 0x000008, "Wrong alignment on UCustomizationMenuUserWidget");
static_assert(sizeof(UCustomizationMenuUserWidget) == 0x0002E8, "Wrong size on UCustomizationMenuUserWidget");
static_assert(offsetof(UCustomizationMenuUserWidget, SelectedGender) == 0x000260, "Member 'UCustomizationMenuUserWidget::SelectedGender' has a wrong offset!");
static_assert(offsetof(UCustomizationMenuUserWidget, GenderSwitcher) == 0x000268, "Member 'UCustomizationMenuUserWidget::GenderSwitcher' has a wrong offset!");
static_assert(offsetof(UCustomizationMenuUserWidget, ZoomText) == 0x000270, "Member 'UCustomizationMenuUserWidget::ZoomText' has a wrong offset!");
static_assert(offsetof(UCustomizationMenuUserWidget, FocusedGenderButtonSize) == 0x000278, "Member 'UCustomizationMenuUserWidget::FocusedGenderButtonSize' has a wrong offset!");
static_assert(offsetof(UCustomizationMenuUserWidget, UnfocusedGenderButtonSize) == 0x000280, "Member 'UCustomizationMenuUserWidget::UnfocusedGenderButtonSize' has a wrong offset!");
static_assert(offsetof(UCustomizationMenuUserWidget, ClassicColor) == 0x000288, "Member 'UCustomizationMenuUserWidget::ClassicColor' has a wrong offset!");
static_assert(offsetof(UCustomizationMenuUserWidget, ElegantColor) == 0x000298, "Member 'UCustomizationMenuUserWidget::ElegantColor' has a wrong offset!");
static_assert(offsetof(UCustomizationMenuUserWidget, LuxuriousColor) == 0x0002A8, "Member 'UCustomizationMenuUserWidget::LuxuriousColor' has a wrong offset!");
static_assert(offsetof(UCustomizationMenuUserWidget, ExtravagentColor) == 0x0002B8, "Member 'UCustomizationMenuUserWidget::ExtravagentColor' has a wrong offset!");
static_assert(offsetof(UCustomizationMenuUserWidget, OnChangeGenderMenu) == 0x0002C8, "Member 'UCustomizationMenuUserWidget::OnChangeGenderMenu' has a wrong offset!");
static_assert(offsetof(UCustomizationMenuUserWidget, OnZoomInOnCharacter) == 0x0002D8, "Member 'UCustomizationMenuUserWidget::OnZoomInOnCharacter' has a wrong offset!");

// Class SCT.CustomizationOptionUserWidget
// 0x0018 (0x0278 - 0x0260)
class UCustomizationOptionUserWidget : public UUserWidget
{
public:
	class UPrimitiveComponent*                    MeshPrimitiveComponent;                            // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      MaterialOption;                                    // 0x0268(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OptionMaterialIndex;                               // 0x0270(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MeshMaterialIndex;                                 // 0x0274(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationOptionUserWidget">();
	}
	static class UCustomizationOptionUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationOptionUserWidget>();
	}
};
static_assert(alignof(UCustomizationOptionUserWidget) == 0x000008, "Wrong alignment on UCustomizationOptionUserWidget");
static_assert(sizeof(UCustomizationOptionUserWidget) == 0x000278, "Wrong size on UCustomizationOptionUserWidget");
static_assert(offsetof(UCustomizationOptionUserWidget, MeshPrimitiveComponent) == 0x000260, "Member 'UCustomizationOptionUserWidget::MeshPrimitiveComponent' has a wrong offset!");
static_assert(offsetof(UCustomizationOptionUserWidget, MaterialOption) == 0x000268, "Member 'UCustomizationOptionUserWidget::MaterialOption' has a wrong offset!");
static_assert(offsetof(UCustomizationOptionUserWidget, OptionMaterialIndex) == 0x000270, "Member 'UCustomizationOptionUserWidget::OptionMaterialIndex' has a wrong offset!");
static_assert(offsetof(UCustomizationOptionUserWidget, MeshMaterialIndex) == 0x000274, "Member 'UCustomizationOptionUserWidget::MeshMaterialIndex' has a wrong offset!");

// Class SCT.CustomizationRowUserWidget
// 0x0060 (0x02C0 - 0x0260)
class UCustomizationRowUserWidget : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateUIOverTime;                                // 0x0260(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateUIImmediately;                             // 0x0270(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpdateOpacityOverTime;                           // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         CustomizationList;                                 // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMeshComponent*                         CustomizationMesh;                                 // 0x0298(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationSlotUserWidget*           CurrentSlot;                                       // 0x02A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCustomizationSlotUserWidget*           PreviousSlot;                                      // 0x02A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectedSize;                                      // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         UnselectedSize;                                    // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SelectedHorizontalPadding;                         // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InterpSpeed;                                       // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UCustomizationSlotUserWidget* AddCustomizationItem(const struct FPlayerCustomizationItem& Item, TSubclassOf<class UCustomizationSlotUserWidget> SlotClass);
	void UpdateUIImmediately();
	void UpdateUIOverTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationRowUserWidget">();
	}
	static class UCustomizationRowUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationRowUserWidget>();
	}
};
static_assert(alignof(UCustomizationRowUserWidget) == 0x000008, "Wrong alignment on UCustomizationRowUserWidget");
static_assert(sizeof(UCustomizationRowUserWidget) == 0x0002C0, "Wrong size on UCustomizationRowUserWidget");
static_assert(offsetof(UCustomizationRowUserWidget, OnUpdateUIOverTime) == 0x000260, "Member 'UCustomizationRowUserWidget::OnUpdateUIOverTime' has a wrong offset!");
static_assert(offsetof(UCustomizationRowUserWidget, OnUpdateUIImmediately) == 0x000270, "Member 'UCustomizationRowUserWidget::OnUpdateUIImmediately' has a wrong offset!");
static_assert(offsetof(UCustomizationRowUserWidget, OnUpdateOpacityOverTime) == 0x000280, "Member 'UCustomizationRowUserWidget::OnUpdateOpacityOverTime' has a wrong offset!");
static_assert(offsetof(UCustomizationRowUserWidget, CustomizationList) == 0x000290, "Member 'UCustomizationRowUserWidget::CustomizationList' has a wrong offset!");
static_assert(offsetof(UCustomizationRowUserWidget, CustomizationMesh) == 0x000298, "Member 'UCustomizationRowUserWidget::CustomizationMesh' has a wrong offset!");
static_assert(offsetof(UCustomizationRowUserWidget, CurrentSlot) == 0x0002A0, "Member 'UCustomizationRowUserWidget::CurrentSlot' has a wrong offset!");
static_assert(offsetof(UCustomizationRowUserWidget, PreviousSlot) == 0x0002A8, "Member 'UCustomizationRowUserWidget::PreviousSlot' has a wrong offset!");
static_assert(offsetof(UCustomizationRowUserWidget, SelectedSize) == 0x0002B0, "Member 'UCustomizationRowUserWidget::SelectedSize' has a wrong offset!");
static_assert(offsetof(UCustomizationRowUserWidget, UnselectedSize) == 0x0002B4, "Member 'UCustomizationRowUserWidget::UnselectedSize' has a wrong offset!");
static_assert(offsetof(UCustomizationRowUserWidget, SelectedHorizontalPadding) == 0x0002B8, "Member 'UCustomizationRowUserWidget::SelectedHorizontalPadding' has a wrong offset!");
static_assert(offsetof(UCustomizationRowUserWidget, InterpSpeed) == 0x0002BC, "Member 'UCustomizationRowUserWidget::InterpSpeed' has a wrong offset!");

// Class SCT.CustomizationToolTipUserWidget
// 0x0010 (0x0270 - 0x0260)
class UCustomizationToolTipUserWidget : public UUserWidget
{
public:
	class UWidgetSwitcher*                        UnlockTypeSwitcher;                                // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UHorizontalBox*                         EquippedType;                                      // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationToolTipUserWidget">();
	}
	static class UCustomizationToolTipUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationToolTipUserWidget>();
	}
};
static_assert(alignof(UCustomizationToolTipUserWidget) == 0x000008, "Wrong alignment on UCustomizationToolTipUserWidget");
static_assert(sizeof(UCustomizationToolTipUserWidget) == 0x000270, "Wrong size on UCustomizationToolTipUserWidget");
static_assert(offsetof(UCustomizationToolTipUserWidget, UnlockTypeSwitcher) == 0x000260, "Member 'UCustomizationToolTipUserWidget::UnlockTypeSwitcher' has a wrong offset!");
static_assert(offsetof(UCustomizationToolTipUserWidget, EquippedType) == 0x000268, "Member 'UCustomizationToolTipUserWidget::EquippedType' has a wrong offset!");

// Class SCT.ItemCardUserWidget
// 0x0040 (0x05B8 - 0x0578)
class UItemCardUserWidget : public UControllerSelectionStateWidget
{
public:
	int32                                         ListIndex;                                         // 0x0578(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomizationToolTipUserWidget*        TooltipPopup;                                      // 0x0580(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UOverlay*                               CheckBox;                                          // 0x0588(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewItemSelected;                                 // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class FString                                 SelectedName;                                      // 0x05A0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HasTooltip;                                        // 0x05B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B1[0x7];                                      // 0x05B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindToNewItemSelected(class UCustomizationScrollBoxUserWidgetBase* CustomizationScrollBoxBase);
	void SetCheckboxVisibility(ESlateVisibility NewVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemCardUserWidget">();
	}
	static class UItemCardUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemCardUserWidget>();
	}
};
static_assert(alignof(UItemCardUserWidget) == 0x000008, "Wrong alignment on UItemCardUserWidget");
static_assert(sizeof(UItemCardUserWidget) == 0x0005B8, "Wrong size on UItemCardUserWidget");
static_assert(offsetof(UItemCardUserWidget, ListIndex) == 0x000578, "Member 'UItemCardUserWidget::ListIndex' has a wrong offset!");
static_assert(offsetof(UItemCardUserWidget, TooltipPopup) == 0x000580, "Member 'UItemCardUserWidget::TooltipPopup' has a wrong offset!");
static_assert(offsetof(UItemCardUserWidget, CheckBox) == 0x000588, "Member 'UItemCardUserWidget::CheckBox' has a wrong offset!");
static_assert(offsetof(UItemCardUserWidget, OnNewItemSelected) == 0x000590, "Member 'UItemCardUserWidget::OnNewItemSelected' has a wrong offset!");
static_assert(offsetof(UItemCardUserWidget, SelectedName) == 0x0005A0, "Member 'UItemCardUserWidget::SelectedName' has a wrong offset!");
static_assert(offsetof(UItemCardUserWidget, HasTooltip) == 0x0005B0, "Member 'UItemCardUserWidget::HasTooltip' has a wrong offset!");

// Class SCT.CustomizationButtonUserWidget
// 0x0010 (0x05C8 - 0x05B8)
class UCustomizationButtonUserWidget : public UItemCardUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnMaterialSelected;                                // 0x05B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationButtonUserWidget">();
	}
	static class UCustomizationButtonUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationButtonUserWidget>();
	}
};
static_assert(alignof(UCustomizationButtonUserWidget) == 0x000008, "Wrong alignment on UCustomizationButtonUserWidget");
static_assert(sizeof(UCustomizationButtonUserWidget) == 0x0005C8, "Wrong size on UCustomizationButtonUserWidget");
static_assert(offsetof(UCustomizationButtonUserWidget, OnMaterialSelected) == 0x0005B8, "Member 'UCustomizationButtonUserWidget::OnMaterialSelected' has a wrong offset!");

// Class SCT.CustomizationMaterialButtonUserWidget
// 0x0010 (0x05D8 - 0x05C8)
class UCustomizationMaterialButtonUserWidget : public UCustomizationButtonUserWidget
{
public:
	struct FLinearColor                           ThumbnailColor;                                    // 0x05C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BindToUpdateEyeMaterial(class UCustomizationScrollBoxUserWidget* CustomizationScrollBox);
	void BindToUpdateHairColor(class UCustomizationScrollBoxUserWidget* CustomizationScrollBox);
	void BindToUpdateSkinMaterial(class UCustomizationScrollBoxUserWidget* CustomizationScrollBox);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationMaterialButtonUserWidget">();
	}
	static class UCustomizationMaterialButtonUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationMaterialButtonUserWidget>();
	}
};
static_assert(alignof(UCustomizationMaterialButtonUserWidget) == 0x000008, "Wrong alignment on UCustomizationMaterialButtonUserWidget");
static_assert(sizeof(UCustomizationMaterialButtonUserWidget) == 0x0005D8, "Wrong size on UCustomizationMaterialButtonUserWidget");
static_assert(offsetof(UCustomizationMaterialButtonUserWidget, ThumbnailColor) == 0x0005C8, "Member 'UCustomizationMaterialButtonUserWidget::ThumbnailColor' has a wrong offset!");

// Class SCT.BlueprintXboxUserPrivilegeCheckerCallbackProxy
// 0x0038 (0x0068 - 0x0030)
class UBlueprintXboxUserPrivilegeCheckerCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnComplete;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBlueprintXboxUserPrivilegeCheckerCallbackProxy* CheckCommunicationPrivilege(class UObject* WorldContextObject, class APlayerController* InPlayerController, const class FString& InXboxLiveUserID, bool bInForceUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintXboxUserPrivilegeCheckerCallbackProxy">();
	}
	static class UBlueprintXboxUserPrivilegeCheckerCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintXboxUserPrivilegeCheckerCallbackProxy>();
	}
};
static_assert(alignof(UBlueprintXboxUserPrivilegeCheckerCallbackProxy) == 0x000008, "Wrong alignment on UBlueprintXboxUserPrivilegeCheckerCallbackProxy");
static_assert(sizeof(UBlueprintXboxUserPrivilegeCheckerCallbackProxy) == 0x000068, "Wrong size on UBlueprintXboxUserPrivilegeCheckerCallbackProxy");
static_assert(offsetof(UBlueprintXboxUserPrivilegeCheckerCallbackProxy, OnComplete) == 0x000030, "Member 'UBlueprintXboxUserPrivilegeCheckerCallbackProxy::OnComplete' has a wrong offset!");

// Class SCT.CustomizationPresetSlotUserWidget
// 0x0008 (0x05D0 - 0x05C8)
class UCustomizationPresetSlotUserWidget : public UCustomizationButtonUserWidget
{
public:
	class UTexture2D*                             ThumbnailIcon;                                     // 0x05C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BindToUpdatePreset(class UCustomizationScrollBoxUserWidget* CustomizationScrollBox);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationPresetSlotUserWidget">();
	}
	static class UCustomizationPresetSlotUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationPresetSlotUserWidget>();
	}
};
static_assert(alignof(UCustomizationPresetSlotUserWidget) == 0x000008, "Wrong alignment on UCustomizationPresetSlotUserWidget");
static_assert(sizeof(UCustomizationPresetSlotUserWidget) == 0x0005D0, "Wrong size on UCustomizationPresetSlotUserWidget");
static_assert(offsetof(UCustomizationPresetSlotUserWidget, ThumbnailIcon) == 0x0005C8, "Member 'UCustomizationPresetSlotUserWidget::ThumbnailIcon' has a wrong offset!");

// Class SCT.CustomizationSlotUserWidget
// 0x00B0 (0x0310 - 0x0260)
class UCustomizationSlotUserWidget : public UUserWidget
{
public:
	struct FPlayerCustomizationItem               CustomizationOptions;                              // 0x0260(0x00A8)(BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIsUnlocked;                                       // 0x0308(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangePlayerClothing_Skeletal(class UMeshComponent* MeshComponent, int32 PrimaryMaterialIndex, int32 SecondaryMaterialIndex);
	void ChangePlayerClothing_Static(class UMeshComponent* MeshComponent, int32 PrimaryMaterialIndex, int32 SecondaryMaterialIndex);
	void OnUpdateHorizontalPaddingOverTime(float TargetValue, float InterpSpeed);
	void OnUpdateOpacityOverTime(float TargetValue, float InterpSpeed);
	void OnUpdateSizeOverTime(float TargetValue, float InterpSpeed);
	void OnUpdateUIImmediately(float TargetSize, float TargetOpacity, float TargetHorizontalPadding);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CustomizationSlotUserWidget">();
	}
	static class UCustomizationSlotUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCustomizationSlotUserWidget>();
	}
};
static_assert(alignof(UCustomizationSlotUserWidget) == 0x000008, "Wrong alignment on UCustomizationSlotUserWidget");
static_assert(sizeof(UCustomizationSlotUserWidget) == 0x000310, "Wrong size on UCustomizationSlotUserWidget");
static_assert(offsetof(UCustomizationSlotUserWidget, CustomizationOptions) == 0x000260, "Member 'UCustomizationSlotUserWidget::CustomizationOptions' has a wrong offset!");
static_assert(offsetof(UCustomizationSlotUserWidget, bIsUnlocked) == 0x000308, "Member 'UCustomizationSlotUserWidget::bIsUnlocked' has a wrong offset!");

// Class SCT.DeathEffect
// 0x0020 (0x07D8 - 0x07B8)
class UDeathEffect final : public UGameplayEffect
{
public:
	class UTexture2D*                             Icon;                                              // 0x07B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   DisplayName;                                       // 0x07C0(0x0018)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathEffect">();
	}
	static class UDeathEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathEffect>();
	}
};
static_assert(alignof(UDeathEffect) == 0x000008, "Wrong alignment on UDeathEffect");
static_assert(sizeof(UDeathEffect) == 0x0007D8, "Wrong size on UDeathEffect");
static_assert(offsetof(UDeathEffect, Icon) == 0x0007B8, "Member 'UDeathEffect::Icon' has a wrong offset!");
static_assert(offsetof(UDeathEffect, DisplayName) == 0x0007C0, "Member 'UDeathEffect::DisplayName' has a wrong offset!");

// Class SCT.DebugActorComponent
// 0x0008 (0x00B8 - 0x00B0)
class UDebugActorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugActorComponent">();
	}
	static class UDebugActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDebugActorComponent>();
	}
};
static_assert(alignof(UDebugActorComponent) == 0x000008, "Wrong alignment on UDebugActorComponent");
static_assert(sizeof(UDebugActorComponent) == 0x0000B8, "Wrong size on UDebugActorComponent");

// Class SCT.DebugTeleportLocation
// 0x0010 (0x0260 - 0x0250)
class ADebugTeleportLocation final : public APlayerStart
{
public:
	class FString                                 LocationName;                                      // 0x0250(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DebugTeleportLocation">();
	}
	static class ADebugTeleportLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADebugTeleportLocation>();
	}
};
static_assert(alignof(ADebugTeleportLocation) == 0x000008, "Wrong alignment on ADebugTeleportLocation");
static_assert(sizeof(ADebugTeleportLocation) == 0x000260, "Wrong size on ADebugTeleportLocation");
static_assert(offsetof(ADebugTeleportLocation, LocationName) == 0x000250, "Member 'ADebugTeleportLocation::LocationName' has a wrong offset!");

// Class SCT.EquipablePower
// 0x0018 (0x0238 - 0x0220)
class AEquipablePower : public AActor
{
public:
	uint8                                         Pad_220[0x8];                                      // 0x0220(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CharacterSocketAttachment;                         // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Visible;                                           // 0x0230(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DoHide();
	void DoShow();
	void Initialize();
	void K2_OnHide();
	void K2_OnShow();
	void OnEquip();
	void OnInventorySlotAssigned(class UPower* PowerChanged, EInventorySlotID SlotId);
	void OnInventorySlotCleared(class UPower* PowerChanged, EInventorySlotID SlotId);
	void OnRep_Visible();
	void OnUnequip();

	bool IsLocallyControlled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipablePower">();
	}
	static class AEquipablePower* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEquipablePower>();
	}
};
static_assert(alignof(AEquipablePower) == 0x000008, "Wrong alignment on AEquipablePower");
static_assert(sizeof(AEquipablePower) == 0x000238, "Wrong size on AEquipablePower");
static_assert(offsetof(AEquipablePower, CharacterSocketAttachment) == 0x000228, "Member 'AEquipablePower::CharacterSocketAttachment' has a wrong offset!");
static_assert(offsetof(AEquipablePower, Visible) == 0x000230, "Member 'AEquipablePower::Visible' has a wrong offset!");

// Class SCT.FactionInfoInterface
// 0x0000 (0x0028 - 0x0028)
class IFactionInfoInterface final : public IInterface
{
public:
	EPlayerFaction GetFaction() const;
	bool IsPersonoid() const;
	bool IsResident() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FactionInfoInterface">();
	}
	static class IFactionInfoInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFactionInfoInterface>();
	}
};
static_assert(alignof(IFactionInfoInterface) == 0x000008, "Wrong alignment on IFactionInfoInterface");
static_assert(sizeof(IFactionInfoInterface) == 0x000028, "Wrong size on IFactionInfoInterface");

// Class SCT.FCTAccelByteAnalytics
// 0x0000 (0x0028 - 0x0028)
class UFCTAccelByteAnalytics final : public UBlueprintFunctionLibrary
{
public:
	static void CaptureEndOfLevelTelemetry(EMapName Map, int32 PlayersKilledInLevel, bool MatchEnded);
	static void CaptureEndOfMatchTelemetry(EEndConditions EndCondition, const struct FDateTime& StartTime, EWinningFaction WinningFaction);
	static void CaptureFriendlyKillTelemetry(EMapName Map, bool IsResident, bool IsServer);
	static void CaptureItemInteractionTelemetry(const class FString& UserId, const class FString& ItemName, EItemAction ItemAction, EMapName Map, bool IsResident, bool IsServer);
	static void CapturePassengerLogTelemetry(EMapName Map, const class FString& PassengerLogType, bool IsResident, bool IsServer);
	static void CapturePlayerDeathTelemetry(EMapName Map, EFate Fate, const struct FVector& Location, bool IsResident, bool IsServer);
	static void CapturePlayerEndOfMatchTelemetry(const class FString& UserId, EFate Fate, int32 ExperienceEarned, bool IsResident, bool IsServer);
	static void CaptureSkillCheckTelemetry(bool SkillcheckSuccessful, bool PlayerAIsResident, bool PlayerBIsResident, bool IsServer);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteAnalytics">();
	}
	static class UFCTAccelByteAnalytics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteAnalytics>();
	}
};
static_assert(alignof(UFCTAccelByteAnalytics) == 0x000008, "Wrong alignment on UFCTAccelByteAnalytics");
static_assert(sizeof(UFCTAccelByteAnalytics) == 0x000028, "Wrong size on UFCTAccelByteAnalytics");

// Class SCT.FCTAccelByteLinkAccountsCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAccelByteLinkAccountsCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAccelByteLinkAccountsCallbackProxy* ForceLinkHeadlessWithVersusEvilAccount();
	static class UFCTAccelByteLinkAccountsCallbackProxy* LoginAndLinkPlatformAccount(const class FString& Email, const class FString& Password);
	static class UFCTAccelByteLinkAccountsCallbackProxy* LogIntoVersusEvilAccount(const class FString& Email, const class FString& Password);
	static class UFCTAccelByteLinkAccountsCallbackProxy* RegisterAndLinkPlatformAccount(const class FString& Email, const class FString& Password, const class FString& DisplayName, const class FString& Country, const class FString& DateOfBirth);
	static class UFCTAccelByteLinkAccountsCallbackProxy* UnlinkCurrentPlatformFromVersusEvilAccount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteLinkAccountsCallbackProxy">();
	}
	static class UFCTAccelByteLinkAccountsCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteLinkAccountsCallbackProxy>();
	}
};
static_assert(alignof(UFCTAccelByteLinkAccountsCallbackProxy) == 0x000008, "Wrong alignment on UFCTAccelByteLinkAccountsCallbackProxy");
static_assert(sizeof(UFCTAccelByteLinkAccountsCallbackProxy) == 0x000050, "Wrong size on UFCTAccelByteLinkAccountsCallbackProxy");
static_assert(offsetof(UFCTAccelByteLinkAccountsCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAccelByteLinkAccountsCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteLinkAccountsCallbackProxy, OnError) == 0x000040, "Member 'UFCTAccelByteLinkAccountsCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTAccelByteLinkPlatformCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAccelByteLinkPlatformCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAccelByteLinkPlatformCallbackProxy* LinkCurrentPlatform(const class FString& Email, const class FString& Password);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteLinkPlatformCallbackProxy">();
	}
	static class UFCTAccelByteLinkPlatformCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteLinkPlatformCallbackProxy>();
	}
};
static_assert(alignof(UFCTAccelByteLinkPlatformCallbackProxy) == 0x000008, "Wrong alignment on UFCTAccelByteLinkPlatformCallbackProxy");
static_assert(sizeof(UFCTAccelByteLinkPlatformCallbackProxy) == 0x000050, "Wrong size on UFCTAccelByteLinkPlatformCallbackProxy");
static_assert(offsetof(UFCTAccelByteLinkPlatformCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAccelByteLinkPlatformCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteLinkPlatformCallbackProxy, OnError) == 0x000040, "Member 'UFCTAccelByteLinkPlatformCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTAuthLogoutCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAuthLogoutCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAuthLogoutCallbackProxy* Logout();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAuthLogoutCallbackProxy">();
	}
	static class UFCTAuthLogoutCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAuthLogoutCallbackProxy>();
	}
};
static_assert(alignof(UFCTAuthLogoutCallbackProxy) == 0x000008, "Wrong alignment on UFCTAuthLogoutCallbackProxy");
static_assert(sizeof(UFCTAuthLogoutCallbackProxy) == 0x000050, "Wrong size on UFCTAuthLogoutCallbackProxy");
static_assert(offsetof(UFCTAuthLogoutCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAuthLogoutCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAuthLogoutCallbackProxy, OnError) == 0x000040, "Member 'UFCTAuthLogoutCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTAuthUpgradeAccountCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAuthUpgradeAccountCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAuthUpgradeAccountCallbackProxy* UpgradeHeadlessAccount(const class FString& Email, const class FString& Password);
	static class UFCTAuthUpgradeAccountCallbackProxy* UpgradeHeadlessAccountAndVerify(const class FString& Email, const class FString& Password, const class FString& VerificationCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAuthUpgradeAccountCallbackProxy">();
	}
	static class UFCTAuthUpgradeAccountCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAuthUpgradeAccountCallbackProxy>();
	}
};
static_assert(alignof(UFCTAuthUpgradeAccountCallbackProxy) == 0x000008, "Wrong alignment on UFCTAuthUpgradeAccountCallbackProxy");
static_assert(sizeof(UFCTAuthUpgradeAccountCallbackProxy) == 0x000050, "Wrong size on UFCTAuthUpgradeAccountCallbackProxy");
static_assert(offsetof(UFCTAuthUpgradeAccountCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAuthUpgradeAccountCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAuthUpgradeAccountCallbackProxy, OnError) == 0x000040, "Member 'UFCTAuthUpgradeAccountCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTAuthSendVerificationCodeCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAuthSendVerificationCodeCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAuthSendVerificationCodeCallbackProxy* SendVerificationCodeForAccount();
	static class UFCTAuthSendVerificationCodeCallbackProxy* SendVerificationCodeForUpgrade(const class FString& Email);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAuthSendVerificationCodeCallbackProxy">();
	}
	static class UFCTAuthSendVerificationCodeCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAuthSendVerificationCodeCallbackProxy>();
	}
};
static_assert(alignof(UFCTAuthSendVerificationCodeCallbackProxy) == 0x000008, "Wrong alignment on UFCTAuthSendVerificationCodeCallbackProxy");
static_assert(sizeof(UFCTAuthSendVerificationCodeCallbackProxy) == 0x000050, "Wrong size on UFCTAuthSendVerificationCodeCallbackProxy");
static_assert(offsetof(UFCTAuthSendVerificationCodeCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAuthSendVerificationCodeCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAuthSendVerificationCodeCallbackProxy, OnError) == 0x000040, "Member 'UFCTAuthSendVerificationCodeCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTForgotPasswordCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTForgotPasswordCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTForgotPasswordCallbackProxy* ResetPassword(const class FString& VerificationCode, const class FString& Email, const class FString& NewPassword, const class FString& ReEnteredPassword);
	static class UFCTForgotPasswordCallbackProxy* SendResetPasswordRequest(const class FString& Email);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTForgotPasswordCallbackProxy">();
	}
	static class UFCTForgotPasswordCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTForgotPasswordCallbackProxy>();
	}
};
static_assert(alignof(UFCTForgotPasswordCallbackProxy) == 0x000008, "Wrong alignment on UFCTForgotPasswordCallbackProxy");
static_assert(sizeof(UFCTForgotPasswordCallbackProxy) == 0x000050, "Wrong size on UFCTForgotPasswordCallbackProxy");
static_assert(offsetof(UFCTForgotPasswordCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTForgotPasswordCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTForgotPasswordCallbackProxy, OnError) == 0x000040, "Member 'UFCTForgotPasswordCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTAuthVerifyAccountCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAuthVerifyAccountCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAuthVerifyAccountCallbackProxy* VerifyExistingAccount(const class FString& VerificationCode);
	static class UFCTAuthVerifyAccountCallbackProxy* VerifyUpgradedAccount(const class FString& Email, const class FString& Password, const class FString& VerificationCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAuthVerifyAccountCallbackProxy">();
	}
	static class UFCTAuthVerifyAccountCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAuthVerifyAccountCallbackProxy>();
	}
};
static_assert(alignof(UFCTAuthVerifyAccountCallbackProxy) == 0x000008, "Wrong alignment on UFCTAuthVerifyAccountCallbackProxy");
static_assert(sizeof(UFCTAuthVerifyAccountCallbackProxy) == 0x000050, "Wrong size on UFCTAuthVerifyAccountCallbackProxy");
static_assert(offsetof(UFCTAuthVerifyAccountCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAuthVerifyAccountCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAuthVerifyAccountCallbackProxy, OnError) == 0x000040, "Member 'UFCTAuthVerifyAccountCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTQueryLegalEligibilitiesCallbackProxy
// 0x0038 (0x0068 - 0x0030)
class UFCTQueryLegalEligibilitiesCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFCTQueryLegalEligibilitiesCallbackProxy* QueryVersusEvilLegalEligibilities();
	static class UFCTQueryLegalEligibilitiesCallbackProxy* QueryVersusEvilLegalEligibilitiesByCountry(const class FString& CultureCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTQueryLegalEligibilitiesCallbackProxy">();
	}
	static class UFCTQueryLegalEligibilitiesCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTQueryLegalEligibilitiesCallbackProxy>();
	}
};
static_assert(alignof(UFCTQueryLegalEligibilitiesCallbackProxy) == 0x000008, "Wrong alignment on UFCTQueryLegalEligibilitiesCallbackProxy");
static_assert(sizeof(UFCTQueryLegalEligibilitiesCallbackProxy) == 0x000068, "Wrong size on UFCTQueryLegalEligibilitiesCallbackProxy");
static_assert(offsetof(UFCTQueryLegalEligibilitiesCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTQueryLegalEligibilitiesCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTQueryLegalEligibilitiesCallbackProxy, OnError) == 0x000040, "Member 'UFCTQueryLegalEligibilitiesCallbackProxy::OnError' has a wrong offset!");

// Class SCT.UserSettingsGIS
// 0x00A0 (0x00D0 - 0x0030)
class UUserSettingsGIS final : public UGameInstanceSubsystem
{
public:
	TMap<TSubclassOf<class USettingsObject>, class USettingsObject*> LoadedSettings;                                    // 0x0030(0x0050)(NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class USettingsObject>, class USettingsObject*> CachedSettings;                                    // 0x0080(0x0050)(NativeAccessSpecifierPrivate)

public:
	void ClearAll();
	class USettingsObject* GetSetting(const TSubclassOf<class USettingsObject>& ClassType);
	void SaveAll();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserSettingsGIS">();
	}
	static class UUserSettingsGIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserSettingsGIS>();
	}
};
static_assert(alignof(UUserSettingsGIS) == 0x000008, "Wrong alignment on UUserSettingsGIS");
static_assert(sizeof(UUserSettingsGIS) == 0x0000D0, "Wrong size on UUserSettingsGIS");
static_assert(offsetof(UUserSettingsGIS, LoadedSettings) == 0x000030, "Member 'UUserSettingsGIS::LoadedSettings' has a wrong offset!");
static_assert(offsetof(UUserSettingsGIS, CachedSettings) == 0x000080, "Member 'UUserSettingsGIS::CachedSettings' has a wrong offset!");

// Class SCT.FCTAcceptLegalPolicyCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAcceptLegalPolicyCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAcceptLegalPolicyCallbackProxy* AcceptVersusEvilPolict(const class FString& LocalizedVersionId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAcceptLegalPolicyCallbackProxy">();
	}
	static class UFCTAcceptLegalPolicyCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAcceptLegalPolicyCallbackProxy>();
	}
};
static_assert(alignof(UFCTAcceptLegalPolicyCallbackProxy) == 0x000008, "Wrong alignment on UFCTAcceptLegalPolicyCallbackProxy");
static_assert(sizeof(UFCTAcceptLegalPolicyCallbackProxy) == 0x000050, "Wrong size on UFCTAcceptLegalPolicyCallbackProxy");
static_assert(offsetof(UFCTAcceptLegalPolicyCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAcceptLegalPolicyCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAcceptLegalPolicyCallbackProxy, OnError) == 0x000040, "Member 'UFCTAcceptLegalPolicyCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTAccelByteAuthenticationWidget
// 0x0000 (0x0260 - 0x0260)
class UFCTAccelByteAuthenticationWidget : public UUserWidget
{
public:
	bool PasswordIsValid(const class FString& Password, const class FString& ConfirmedPassword, int32* Code);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteAuthenticationWidget">();
	}
	static class UFCTAccelByteAuthenticationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteAuthenticationWidget>();
	}
};
static_assert(alignof(UFCTAccelByteAuthenticationWidget) == 0x000008, "Wrong alignment on UFCTAccelByteAuthenticationWidget");
static_assert(sizeof(UFCTAccelByteAuthenticationWidget) == 0x000260, "Wrong size on UFCTAccelByteAuthenticationWidget");

// Class SCT.AvatarCacheData
// 0x0060 (0x0088 - 0x0028)
class UAvatarCacheData final : public UObject
{
public:
	class FString                                 AccelByteId;                                       // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2DDynamic*                      AvatarTexture;                                     // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AvatarTexturePlatformID;                           // 0x0040(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvatarTextureRequested;                           // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvatarTextureLoaded;                              // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocalUser;                                      // 0x0052(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AvatarUrl;                                         // 0x0058(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastAccessTimeS;                                   // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C[0x1C];                                      // 0x006C(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AvatarCacheData">();
	}
	static class UAvatarCacheData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAvatarCacheData>();
	}
};
static_assert(alignof(UAvatarCacheData) == 0x000008, "Wrong alignment on UAvatarCacheData");
static_assert(sizeof(UAvatarCacheData) == 0x000088, "Wrong size on UAvatarCacheData");
static_assert(offsetof(UAvatarCacheData, AccelByteId) == 0x000028, "Member 'UAvatarCacheData::AccelByteId' has a wrong offset!");
static_assert(offsetof(UAvatarCacheData, AvatarTexture) == 0x000038, "Member 'UAvatarCacheData::AvatarTexture' has a wrong offset!");
static_assert(offsetof(UAvatarCacheData, AvatarTexturePlatformID) == 0x000040, "Member 'UAvatarCacheData::AvatarTexturePlatformID' has a wrong offset!");
static_assert(offsetof(UAvatarCacheData, bAvatarTextureRequested) == 0x000050, "Member 'UAvatarCacheData::bAvatarTextureRequested' has a wrong offset!");
static_assert(offsetof(UAvatarCacheData, bAvatarTextureLoaded) == 0x000051, "Member 'UAvatarCacheData::bAvatarTextureLoaded' has a wrong offset!");
static_assert(offsetof(UAvatarCacheData, bIsLocalUser) == 0x000052, "Member 'UAvatarCacheData::bIsLocalUser' has a wrong offset!");
static_assert(offsetof(UAvatarCacheData, AvatarUrl) == 0x000058, "Member 'UAvatarCacheData::AvatarUrl' has a wrong offset!");
static_assert(offsetof(UAvatarCacheData, LastAccessTimeS) == 0x000068, "Member 'UAvatarCacheData::LastAccessTimeS' has a wrong offset!");

// Class SCT.FCTAccelByteAvatarCacheGIS
// 0x0148 (0x0178 - 0x0030)
class UFCTAccelByteAvatarCacheGIS final : public UGameInstanceSubsystem
{
public:
	TArray<class UAvatarCacheData*>               CachedAvatars;                                     // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x138];                                     // 0x0040(0x0138)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTexture2DDynamic* GetCachedAvatar(const class FString& InAccelByteID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteAvatarCacheGIS">();
	}
	static class UFCTAccelByteAvatarCacheGIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteAvatarCacheGIS>();
	}
};
static_assert(alignof(UFCTAccelByteAvatarCacheGIS) == 0x000008, "Wrong alignment on UFCTAccelByteAvatarCacheGIS");
static_assert(sizeof(UFCTAccelByteAvatarCacheGIS) == 0x000178, "Wrong size on UFCTAccelByteAvatarCacheGIS");
static_assert(offsetof(UFCTAccelByteAvatarCacheGIS, CachedAvatars) == 0x000030, "Member 'UFCTAccelByteAvatarCacheGIS::CachedAvatars' has a wrong offset!");

// Class SCT.AccelByteAvatarCacheCallbackProxy
// 0x0028 (0x0058 - 0x0030)
class UAccelByteAvatarCacheCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnRetrieved;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAccelByteAvatarCacheCallbackProxy* GetCachedAvatarAsync(class UObject* WorldContextObject, const class FString& InAccelByteID);
	static class UAccelByteAvatarCacheCallbackProxy* GetCachedAvatarForPrimaryUserAsync(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AccelByteAvatarCacheCallbackProxy">();
	}
	static class UAccelByteAvatarCacheCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAccelByteAvatarCacheCallbackProxy>();
	}
};
static_assert(alignof(UAccelByteAvatarCacheCallbackProxy) == 0x000008, "Wrong alignment on UAccelByteAvatarCacheCallbackProxy");
static_assert(sizeof(UAccelByteAvatarCacheCallbackProxy) == 0x000058, "Wrong size on UAccelByteAvatarCacheCallbackProxy");
static_assert(offsetof(UAccelByteAvatarCacheCallbackProxy, OnRetrieved) == 0x000030, "Member 'UAccelByteAvatarCacheCallbackProxy::OnRetrieved' has a wrong offset!");

// Class SCT.FCTClaimCampaignEntitlementCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTClaimCampaignEntitlementCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTClaimCampaignEntitlementCallbackProxy* RedeemCode(const class FString& Code);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTClaimCampaignEntitlementCallbackProxy">();
	}
	static class UFCTClaimCampaignEntitlementCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTClaimCampaignEntitlementCallbackProxy>();
	}
};
static_assert(alignof(UFCTClaimCampaignEntitlementCallbackProxy) == 0x000008, "Wrong alignment on UFCTClaimCampaignEntitlementCallbackProxy");
static_assert(sizeof(UFCTClaimCampaignEntitlementCallbackProxy) == 0x000050, "Wrong size on UFCTClaimCampaignEntitlementCallbackProxy");
static_assert(offsetof(UFCTClaimCampaignEntitlementCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTClaimCampaignEntitlementCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTClaimCampaignEntitlementCallbackProxy, OnError) == 0x000040, "Member 'UFCTClaimCampaignEntitlementCallbackProxy::OnError' has a wrong offset!");

// Class SCT.WidgetSCT
// 0x0020 (0x0280 - 0x0260)
class UWidgetSCT : public UUserWidget
{
public:
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EWidgetBehaviour                              DefaultBehaviour;                                  // 0x0278(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetSCT">();
	}
	static class UWidgetSCT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetSCT>();
	}
};
static_assert(alignof(UWidgetSCT) == 0x000008, "Wrong alignment on UWidgetSCT");
static_assert(sizeof(UWidgetSCT) == 0x000280, "Wrong size on UWidgetSCT");
static_assert(offsetof(UWidgetSCT, DefaultBehaviour) == 0x000278, "Member 'UWidgetSCT::DefaultBehaviour' has a wrong offset!");

// Class SCT.SkillcheckWidget
// 0x0038 (0x02B8 - 0x0280)
class USkillcheckWidget : public UWidgetSCT
{
public:
	FMulticastInlineDelegateProperty_             OnSkillcheckEnded;                                 // 0x0280(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSkillcheckSucceded;                              // 0x0290(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSkillcheckFailed;                                // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ASkillcheckManager*                     Manager;                                           // 0x02B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void K2_Initialize();
	void SkillcheckFailed();
	void SkillcheckSucceeded();
	void StartSkillcheck();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillcheckWidget">();
	}
	static class USkillcheckWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillcheckWidget>();
	}
};
static_assert(alignof(USkillcheckWidget) == 0x000008, "Wrong alignment on USkillcheckWidget");
static_assert(sizeof(USkillcheckWidget) == 0x0002B8, "Wrong size on USkillcheckWidget");
static_assert(offsetof(USkillcheckWidget, OnSkillcheckEnded) == 0x000280, "Member 'USkillcheckWidget::OnSkillcheckEnded' has a wrong offset!");
static_assert(offsetof(USkillcheckWidget, OnSkillcheckSucceded) == 0x000290, "Member 'USkillcheckWidget::OnSkillcheckSucceded' has a wrong offset!");
static_assert(offsetof(USkillcheckWidget, OnSkillcheckFailed) == 0x0002A0, "Member 'USkillcheckWidget::OnSkillcheckFailed' has a wrong offset!");
static_assert(offsetof(USkillcheckWidget, Manager) == 0x0002B0, "Member 'USkillcheckWidget::Manager' has a wrong offset!");

// Class SCT.FCTRedeemCodeCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTRedeemCodeCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTRedeemCodeCallbackProxy* RedeemCode(const class FString& Code);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTRedeemCodeCallbackProxy">();
	}
	static class UFCTRedeemCodeCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTRedeemCodeCallbackProxy>();
	}
};
static_assert(alignof(UFCTRedeemCodeCallbackProxy) == 0x000008, "Wrong alignment on UFCTRedeemCodeCallbackProxy");
static_assert(sizeof(UFCTRedeemCodeCallbackProxy) == 0x000050, "Wrong size on UFCTRedeemCodeCallbackProxy");
static_assert(offsetof(UFCTRedeemCodeCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTRedeemCodeCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTRedeemCodeCallbackProxy, OnFail) == 0x000040, "Member 'UFCTRedeemCodeCallbackProxy::OnFail' has a wrong offset!");

// Class SCT.FCTGetWalletCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTGetWalletCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTGetWalletCallbackProxy* GetWallet(EPremiumCurrency Currency);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGetWalletCallbackProxy">();
	}
	static class UFCTGetWalletCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGetWalletCallbackProxy>();
	}
};
static_assert(alignof(UFCTGetWalletCallbackProxy) == 0x000008, "Wrong alignment on UFCTGetWalletCallbackProxy");
static_assert(sizeof(UFCTGetWalletCallbackProxy) == 0x000050, "Wrong size on UFCTGetWalletCallbackProxy");
static_assert(offsetof(UFCTGetWalletCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTGetWalletCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTGetWalletCallbackProxy, OnError) == 0x000040, "Member 'UFCTGetWalletCallbackProxy::OnError' has a wrong offset!");

// Class SCT.XboxAnonymousUserPrivilegeCheckData
// 0x0038 (0x0060 - 0x0028)
class UXboxAnonymousUserPrivilegeCheckData final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XboxAnonymousUserPrivilegeCheckData">();
	}
	static class UXboxAnonymousUserPrivilegeCheckData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXboxAnonymousUserPrivilegeCheckData>();
	}
};
static_assert(alignof(UXboxAnonymousUserPrivilegeCheckData) == 0x000008, "Wrong alignment on UXboxAnonymousUserPrivilegeCheckData");
static_assert(sizeof(UXboxAnonymousUserPrivilegeCheckData) == 0x000060, "Wrong size on UXboxAnonymousUserPrivilegeCheckData");

// Class SCT.FCTQueryEntitlementsCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTQueryEntitlementsCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTQueryEntitlementsCallbackProxy* QueryUserEntitlementByItemID(const class FString& ItemId);
	static class UFCTQueryEntitlementsCallbackProxy* QueryUserEntitlements();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTQueryEntitlementsCallbackProxy">();
	}
	static class UFCTQueryEntitlementsCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTQueryEntitlementsCallbackProxy>();
	}
};
static_assert(alignof(UFCTQueryEntitlementsCallbackProxy) == 0x000008, "Wrong alignment on UFCTQueryEntitlementsCallbackProxy");
static_assert(sizeof(UFCTQueryEntitlementsCallbackProxy) == 0x000050, "Wrong size on UFCTQueryEntitlementsCallbackProxy");
static_assert(offsetof(UFCTQueryEntitlementsCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTQueryEntitlementsCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTQueryEntitlementsCallbackProxy, OnFail) == 0x000040, "Member 'UFCTQueryEntitlementsCallbackProxy::OnFail' has a wrong offset!");

// Class SCT.FCTGetBulkDLCPacksCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTGetBulkDLCPacksCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTGetBulkDLCPacksCallbackProxy* GetBulkDLCPacks(const class FString& CultureCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGetBulkDLCPacksCallbackProxy">();
	}
	static class UFCTGetBulkDLCPacksCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGetBulkDLCPacksCallbackProxy>();
	}
};
static_assert(alignof(UFCTGetBulkDLCPacksCallbackProxy) == 0x000008, "Wrong alignment on UFCTGetBulkDLCPacksCallbackProxy");
static_assert(sizeof(UFCTGetBulkDLCPacksCallbackProxy) == 0x000050, "Wrong size on UFCTGetBulkDLCPacksCallbackProxy");
static_assert(offsetof(UFCTGetBulkDLCPacksCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTGetBulkDLCPacksCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTGetBulkDLCPacksCallbackProxy, OnError) == 0x000040, "Member 'UFCTGetBulkDLCPacksCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTSyncPlatformPurchases
// 0x0028 (0x0058 - 0x0030)
class UFCTSyncPlatformPurchases final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFCTSyncPlatformPurchases* SyncPlatformPurchases(bool bInForceSync);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTSyncPlatformPurchases">();
	}
	static class UFCTSyncPlatformPurchases* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTSyncPlatformPurchases>();
	}
};
static_assert(alignof(UFCTSyncPlatformPurchases) == 0x000008, "Wrong alignment on UFCTSyncPlatformPurchases");
static_assert(sizeof(UFCTSyncPlatformPurchases) == 0x000058, "Wrong size on UFCTSyncPlatformPurchases");
static_assert(offsetof(UFCTSyncPlatformPurchases, OnSuccess) == 0x000030, "Member 'UFCTSyncPlatformPurchases::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTSyncPlatformPurchases, OnFail) == 0x000040, "Member 'UFCTSyncPlatformPurchases::OnFail' has a wrong offset!");

// Class SCT.FCTGetTexturesFromUrlCallbackProxy
// 0x0038 (0x0068 - 0x0030)
class UFCTGetTexturesFromUrlCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FBulkDLCPacksData                      BulkDLCPackData;                                   // 0x0050(0x0010)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFCTGetTexturesFromUrlCallbackProxy* GetDLCTextures(const struct FBulkDLCPacksData& BulkDLCData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGetTexturesFromUrlCallbackProxy">();
	}
	static class UFCTGetTexturesFromUrlCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGetTexturesFromUrlCallbackProxy>();
	}
};
static_assert(alignof(UFCTGetTexturesFromUrlCallbackProxy) == 0x000008, "Wrong alignment on UFCTGetTexturesFromUrlCallbackProxy");
static_assert(sizeof(UFCTGetTexturesFromUrlCallbackProxy) == 0x000068, "Wrong size on UFCTGetTexturesFromUrlCallbackProxy");
static_assert(offsetof(UFCTGetTexturesFromUrlCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTGetTexturesFromUrlCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTGetTexturesFromUrlCallbackProxy, OnError) == 0x000040, "Member 'UFCTGetTexturesFromUrlCallbackProxy::OnError' has a wrong offset!");
static_assert(offsetof(UFCTGetTexturesFromUrlCallbackProxy, BulkDLCPackData) == 0x000050, "Member 'UFCTGetTexturesFromUrlCallbackProxy::BulkDLCPackData' has a wrong offset!");

// Class SCT.FCTGetFriendsListAsyncProxy
// 0x0168 (0x0198 - 0x0030)
class UFCTGetFriendsListAsyncProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FString>                         FriendIds;                                         // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         FriendCount;                                       // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         IncomingCount;                                     // 0x0064(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         OutgoingCount;                                     // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SearchCount;                                       // 0x006C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         RecentlyPlayedWithCount;                           // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x14];                                      // 0x0074(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PresenceCapturePosition;                           // 0x0088(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PresenceCaptureGroupSize;                          // 0x008C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         OutstandingProfileMissingCount;                    // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         OutstandingProfilePresenceCount;                   // 0x0094(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FFCTFriendsList                        OnlineUserList;                                    // 0x0098(0x0028)(NativeAccessSpecifierPrivate)
	struct FFCTFriendsList                        FriendsList;                                       // 0x00C0(0x0028)(NativeAccessSpecifierPrivate)
	struct FFCTFriendsList                        IncomingList;                                      // 0x00E8(0x0028)(NativeAccessSpecifierPrivate)
	struct FFCTFriendsList                        OutgoingList;                                      // 0x0110(0x0028)(NativeAccessSpecifierPrivate)
	struct FFCTFriendsList                        SearchList;                                        // 0x0138(0x0028)(NativeAccessSpecifierPrivate)
	struct FFCTFriendsList                        RecentList;                                        // 0x0160(0x0028)(NativeAccessSpecifierPrivate)
	struct FFCTRecentlyPlayedWithPayload          RecentlyPlayedWithCloudPayload;                    // 0x0188(0x0010)(NativeAccessSpecifierPrivate)

public:
	static class UFCTGetFriendsListAsyncProxy* GetFriendsList();
	static class UFCTGetFriendsListAsyncProxy* GetIncomingList();
	static class UFCTGetFriendsListAsyncProxy* GetOnlineUsersRequest();
	static class UFCTGetFriendsListAsyncProxy* GetOutgoingList();
	static class UFCTGetFriendsListAsyncProxy* GetRecentList();
	static class UFCTGetFriendsListAsyncProxy* SearchForUser(const class FString& Username);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGetFriendsListAsyncProxy">();
	}
	static class UFCTGetFriendsListAsyncProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGetFriendsListAsyncProxy>();
	}
};
static_assert(alignof(UFCTGetFriendsListAsyncProxy) == 0x000008, "Wrong alignment on UFCTGetFriendsListAsyncProxy");
static_assert(sizeof(UFCTGetFriendsListAsyncProxy) == 0x000198, "Wrong size on UFCTGetFriendsListAsyncProxy");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, OnSuccess) == 0x000030, "Member 'UFCTGetFriendsListAsyncProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, OnError) == 0x000040, "Member 'UFCTGetFriendsListAsyncProxy::OnError' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, FriendIds) == 0x000050, "Member 'UFCTGetFriendsListAsyncProxy::FriendIds' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, FriendCount) == 0x000060, "Member 'UFCTGetFriendsListAsyncProxy::FriendCount' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, IncomingCount) == 0x000064, "Member 'UFCTGetFriendsListAsyncProxy::IncomingCount' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, OutgoingCount) == 0x000068, "Member 'UFCTGetFriendsListAsyncProxy::OutgoingCount' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, SearchCount) == 0x00006C, "Member 'UFCTGetFriendsListAsyncProxy::SearchCount' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, RecentlyPlayedWithCount) == 0x000070, "Member 'UFCTGetFriendsListAsyncProxy::RecentlyPlayedWithCount' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, PresenceCapturePosition) == 0x000088, "Member 'UFCTGetFriendsListAsyncProxy::PresenceCapturePosition' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, PresenceCaptureGroupSize) == 0x00008C, "Member 'UFCTGetFriendsListAsyncProxy::PresenceCaptureGroupSize' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, OutstandingProfileMissingCount) == 0x000090, "Member 'UFCTGetFriendsListAsyncProxy::OutstandingProfileMissingCount' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, OutstandingProfilePresenceCount) == 0x000094, "Member 'UFCTGetFriendsListAsyncProxy::OutstandingProfilePresenceCount' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, OnlineUserList) == 0x000098, "Member 'UFCTGetFriendsListAsyncProxy::OnlineUserList' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, FriendsList) == 0x0000C0, "Member 'UFCTGetFriendsListAsyncProxy::FriendsList' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, IncomingList) == 0x0000E8, "Member 'UFCTGetFriendsListAsyncProxy::IncomingList' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, OutgoingList) == 0x000110, "Member 'UFCTGetFriendsListAsyncProxy::OutgoingList' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, SearchList) == 0x000138, "Member 'UFCTGetFriendsListAsyncProxy::SearchList' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, RecentList) == 0x000160, "Member 'UFCTGetFriendsListAsyncProxy::RecentList' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendsListAsyncProxy, RecentlyPlayedWithCloudPayload) == 0x000188, "Member 'UFCTGetFriendsListAsyncProxy::RecentlyPlayedWithCloudPayload' has a wrong offset!");

// Class SCT.FCTGetFriendProfileAsyncProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTGetFriendProfileAsyncProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTGetFriendProfileAsyncProxy* GetFriendProfileById(const class FString& FriendId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGetFriendProfileAsyncProxy">();
	}
	static class UFCTGetFriendProfileAsyncProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGetFriendProfileAsyncProxy>();
	}
};
static_assert(alignof(UFCTGetFriendProfileAsyncProxy) == 0x000008, "Wrong alignment on UFCTGetFriendProfileAsyncProxy");
static_assert(sizeof(UFCTGetFriendProfileAsyncProxy) == 0x000050, "Wrong size on UFCTGetFriendProfileAsyncProxy");
static_assert(offsetof(UFCTGetFriendProfileAsyncProxy, OnSuccess) == 0x000030, "Member 'UFCTGetFriendProfileAsyncProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTGetFriendProfileAsyncProxy, OnError) == 0x000040, "Member 'UFCTGetFriendProfileAsyncProxy::OnError' has a wrong offset!");

// Class SCT.FCTGetRecentlyPlayedWithListAsyncProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTGetRecentlyPlayedWithListAsyncProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTGetRecentlyPlayedWithListAsyncProxy* AddPlayerToRecentlyPlayedWithList(const class FString& UserId);
	static class UFCTGetRecentlyPlayedWithListAsyncProxy* CacheMostRecentlyPlayedWith(class UAccelByteGIS* AccelByteGIS);
	static class UFCTGetRecentlyPlayedWithListAsyncProxy* GetRecentlyPlayedWithList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGetRecentlyPlayedWithListAsyncProxy">();
	}
	static class UFCTGetRecentlyPlayedWithListAsyncProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGetRecentlyPlayedWithListAsyncProxy>();
	}
};
static_assert(alignof(UFCTGetRecentlyPlayedWithListAsyncProxy) == 0x000008, "Wrong alignment on UFCTGetRecentlyPlayedWithListAsyncProxy");
static_assert(sizeof(UFCTGetRecentlyPlayedWithListAsyncProxy) == 0x000050, "Wrong size on UFCTGetRecentlyPlayedWithListAsyncProxy");
static_assert(offsetof(UFCTGetRecentlyPlayedWithListAsyncProxy, OnSuccess) == 0x000030, "Member 'UFCTGetRecentlyPlayedWithListAsyncProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTGetRecentlyPlayedWithListAsyncProxy, OnError) == 0x000040, "Member 'UFCTGetRecentlyPlayedWithListAsyncProxy::OnError' has a wrong offset!");

// Class SCT.FCTFriendRelationshipAsyncProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTFriendRelationshipAsyncProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTFriendRelationshipAsyncProxy* GetFriendRelationshipStatus(const class FString& UserId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTFriendRelationshipAsyncProxy">();
	}
	static class UFCTFriendRelationshipAsyncProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTFriendRelationshipAsyncProxy>();
	}
};
static_assert(alignof(UFCTFriendRelationshipAsyncProxy) == 0x000008, "Wrong alignment on UFCTFriendRelationshipAsyncProxy");
static_assert(sizeof(UFCTFriendRelationshipAsyncProxy) == 0x000050, "Wrong size on UFCTFriendRelationshipAsyncProxy");
static_assert(offsetof(UFCTFriendRelationshipAsyncProxy, OnSuccess) == 0x000030, "Member 'UFCTFriendRelationshipAsyncProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTFriendRelationshipAsyncProxy, OnError) == 0x000040, "Member 'UFCTFriendRelationshipAsyncProxy::OnError' has a wrong offset!");

// Class SCT.FCTFriendManagementAsyncProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTFriendManagementAsyncProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTFriendManagementAsyncProxy* AcceptInviteFriend(const class FString& FriendId);
	static class UFCTFriendManagementAsyncProxy* CancelInviteFriend(const class FString& FriendId);
	static class UFCTFriendManagementAsyncProxy* InviteFriend(const class FString& FriendId);
	static class UFCTFriendManagementAsyncProxy* RejectInviteFriend(const class FString& FriendId);
	static class UFCTFriendManagementAsyncProxy* RemoveFriend(const class FString& FriendId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTFriendManagementAsyncProxy">();
	}
	static class UFCTFriendManagementAsyncProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTFriendManagementAsyncProxy>();
	}
};
static_assert(alignof(UFCTFriendManagementAsyncProxy) == 0x000008, "Wrong alignment on UFCTFriendManagementAsyncProxy");
static_assert(sizeof(UFCTFriendManagementAsyncProxy) == 0x000050, "Wrong size on UFCTFriendManagementAsyncProxy");
static_assert(offsetof(UFCTFriendManagementAsyncProxy, OnSuccess) == 0x000030, "Member 'UFCTFriendManagementAsyncProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTFriendManagementAsyncProxy, OnError) == 0x000040, "Member 'UFCTFriendManagementAsyncProxy::OnError' has a wrong offset!");

// Class SCT.FCTFriendImportByPlatformCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTFriendImportByPlatformCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTFriendImportByPlatformCallbackProxy* ImportFriendsByPlatform();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTFriendImportByPlatformCallbackProxy">();
	}
	static class UFCTFriendImportByPlatformCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTFriendImportByPlatformCallbackProxy>();
	}
};
static_assert(alignof(UFCTFriendImportByPlatformCallbackProxy) == 0x000008, "Wrong alignment on UFCTFriendImportByPlatformCallbackProxy");
static_assert(sizeof(UFCTFriendImportByPlatformCallbackProxy) == 0x000050, "Wrong size on UFCTFriendImportByPlatformCallbackProxy");
static_assert(offsetof(UFCTFriendImportByPlatformCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTFriendImportByPlatformCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTFriendImportByPlatformCallbackProxy, OnError) == 0x000040, "Member 'UFCTFriendImportByPlatformCallbackProxy::OnError' has a wrong offset!");

// Class SCT.UserCardBaseWidget
// 0x0008 (0x0268 - 0x0260)
class UUserCardBaseWidget : public UUserWidget
{
public:
	class UImage*                                 Avatar;                                            // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetupAvatarImage(const class FString& UserId, class UTextBlock* InitialsTextBlock, class UWidgetSwitcher* Switcher);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserCardBaseWidget">();
	}
	static class UUserCardBaseWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserCardBaseWidget>();
	}
};
static_assert(alignof(UUserCardBaseWidget) == 0x000008, "Wrong alignment on UUserCardBaseWidget");
static_assert(sizeof(UUserCardBaseWidget) == 0x000268, "Wrong size on UUserCardBaseWidget");
static_assert(offsetof(UUserCardBaseWidget, Avatar) == 0x000260, "Member 'UUserCardBaseWidget::Avatar' has a wrong offset!");

// Class SCT.FriendCardWidget
// 0x0058 (0x02C0 - 0x0268)
class UFriendCardWidget : public UUserCardBaseWidget
{
public:
	uint8                                         Pad_268[0x8];                                      // 0x0268(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        FriendSwitcher;                                    // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFFCTFriendListType                           ListType;                                          // 0x0278(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DisplayName;                                       // 0x0280(0x0010)(BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlatformName;                                      // 0x0290(0x0010)(BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserId;                                            // 0x02A0(0x0010)(BlueprintVisible, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAvailability                                 OnlineStatus;                                      // 0x02B0(0x0001)(BlueprintVisible, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B1[0x7];                                      // 0x02B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UFriendLobbyWidget*                     ParentWidget;                                      // 0x02B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendCardWidget">();
	}
	static class UFriendCardWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendCardWidget>();
	}
};
static_assert(alignof(UFriendCardWidget) == 0x000008, "Wrong alignment on UFriendCardWidget");
static_assert(sizeof(UFriendCardWidget) == 0x0002C0, "Wrong size on UFriendCardWidget");
static_assert(offsetof(UFriendCardWidget, FriendSwitcher) == 0x000270, "Member 'UFriendCardWidget::FriendSwitcher' has a wrong offset!");
static_assert(offsetof(UFriendCardWidget, ListType) == 0x000278, "Member 'UFriendCardWidget::ListType' has a wrong offset!");
static_assert(offsetof(UFriendCardWidget, DisplayName) == 0x000280, "Member 'UFriendCardWidget::DisplayName' has a wrong offset!");
static_assert(offsetof(UFriendCardWidget, PlatformName) == 0x000290, "Member 'UFriendCardWidget::PlatformName' has a wrong offset!");
static_assert(offsetof(UFriendCardWidget, UserId) == 0x0002A0, "Member 'UFriendCardWidget::UserId' has a wrong offset!");
static_assert(offsetof(UFriendCardWidget, OnlineStatus) == 0x0002B0, "Member 'UFriendCardWidget::OnlineStatus' has a wrong offset!");
static_assert(offsetof(UFriendCardWidget, ParentWidget) == 0x0002B8, "Member 'UFriendCardWidget::ParentWidget' has a wrong offset!");

// Class SCT.FriendConsoleUtility
// 0x0108 (0x0130 - 0x0028)
class UFriendConsoleUtility final : public UObject
{
public:
	uint8                                         Pad_28[0x108];                                     // 0x0028(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendConsoleUtility">();
	}
	static class UFriendConsoleUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendConsoleUtility>();
	}
};
static_assert(alignof(UFriendConsoleUtility) == 0x000008, "Wrong alignment on UFriendConsoleUtility");
static_assert(sizeof(UFriendConsoleUtility) == 0x000130, "Wrong size on UFriendConsoleUtility");

// Class SCT.FCTSessionIDAsyncProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTSessionIDAsyncProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTSessionIDAsyncProxy* GetServerSessionID();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTSessionIDAsyncProxy">();
	}
	static class UFCTSessionIDAsyncProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTSessionIDAsyncProxy>();
	}
};
static_assert(alignof(UFCTSessionIDAsyncProxy) == 0x000008, "Wrong alignment on UFCTSessionIDAsyncProxy");
static_assert(sizeof(UFCTSessionIDAsyncProxy) == 0x000050, "Wrong size on UFCTSessionIDAsyncProxy");
static_assert(offsetof(UFCTSessionIDAsyncProxy, OnSuccess) == 0x000030, "Member 'UFCTSessionIDAsyncProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTSessionIDAsyncProxy, OnError) == 0x000040, "Member 'UFCTSessionIDAsyncProxy::OnError' has a wrong offset!");

// Class SCT.FCTGetLiveMessageCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTGetLiveMessageCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UFCTGetLiveMessageCallbackProxy* GetLiveMessageFromCloudGameRecord();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGetLiveMessageCallbackProxy">();
	}
	static class UFCTGetLiveMessageCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGetLiveMessageCallbackProxy>();
	}
};
static_assert(alignof(UFCTGetLiveMessageCallbackProxy) == 0x000008, "Wrong alignment on UFCTGetLiveMessageCallbackProxy");
static_assert(sizeof(UFCTGetLiveMessageCallbackProxy) == 0x000050, "Wrong size on UFCTGetLiveMessageCallbackProxy");
static_assert(offsetof(UFCTGetLiveMessageCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTGetLiveMessageCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTGetLiveMessageCallbackProxy, OnError) == 0x000040, "Member 'UFCTGetLiveMessageCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTGetAllLeaderboardRankings
// 0x0088 (0x00B8 - 0x0030)
class UFCTGetAllLeaderboardRankings final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FFCTUserLeaderboardsCachedByStats      Payload;                                           // 0x0050(0x0050)(NativeAccessSpecifierPrivate)
	int32                                         TotalListCount;                                    // 0x00A0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         CurrentListsQueried;                               // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FFCTLeaderboardRecordData>      LeaderboardsToProcess;                             // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UFCTGetAllLeaderboardRankings* GetAllLeaderboardRankings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGetAllLeaderboardRankings">();
	}
	static class UFCTGetAllLeaderboardRankings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGetAllLeaderboardRankings>();
	}
};
static_assert(alignof(UFCTGetAllLeaderboardRankings) == 0x000008, "Wrong alignment on UFCTGetAllLeaderboardRankings");
static_assert(sizeof(UFCTGetAllLeaderboardRankings) == 0x0000B8, "Wrong size on UFCTGetAllLeaderboardRankings");
static_assert(offsetof(UFCTGetAllLeaderboardRankings, OnSuccess) == 0x000030, "Member 'UFCTGetAllLeaderboardRankings::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTGetAllLeaderboardRankings, OnError) == 0x000040, "Member 'UFCTGetAllLeaderboardRankings::OnError' has a wrong offset!");
static_assert(offsetof(UFCTGetAllLeaderboardRankings, Payload) == 0x000050, "Member 'UFCTGetAllLeaderboardRankings::Payload' has a wrong offset!");
static_assert(offsetof(UFCTGetAllLeaderboardRankings, TotalListCount) == 0x0000A0, "Member 'UFCTGetAllLeaderboardRankings::TotalListCount' has a wrong offset!");
static_assert(offsetof(UFCTGetAllLeaderboardRankings, CurrentListsQueried) == 0x0000A4, "Member 'UFCTGetAllLeaderboardRankings::CurrentListsQueried' has a wrong offset!");
static_assert(offsetof(UFCTGetAllLeaderboardRankings, LeaderboardsToProcess) == 0x0000A8, "Member 'UFCTGetAllLeaderboardRankings::LeaderboardsToProcess' has a wrong offset!");

// Class SCT.FCTGetUserLeaderboardRanking
// 0x0000 (0x0030 - 0x0030)
class UFCTGetUserLeaderboardRanking final : public UBlueprintAsyncActionBase
{
public:
	static class UFCTGetUserLeaderboardRanking* GetPublicUserLeaderboardRanking(const class FString& UserId, const class FString& Code, EAccelByteLeaderboardTimeFrame TimeFrame);
	static class UFCTGetUserLeaderboardRanking* GetUserLeaderboardRanking(const class FString& Code, EAccelByteLeaderboardTimeFrame TimeFrame);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGetUserLeaderboardRanking">();
	}
	static class UFCTGetUserLeaderboardRanking* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGetUserLeaderboardRanking>();
	}
};
static_assert(alignof(UFCTGetUserLeaderboardRanking) == 0x000008, "Wrong alignment on UFCTGetUserLeaderboardRanking");
static_assert(sizeof(UFCTGetUserLeaderboardRanking) == 0x000030, "Wrong size on UFCTGetUserLeaderboardRanking");

// Class SCT.FCTPartyConnectionCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTPartyConnectionCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UFCTPartyConnectionCallbackProxy* AcceptPartyInvitation(const class FString& PartyId, const class FString& InvitationToken);
	static class UFCTPartyConnectionCallbackProxy* CreateParty();
	static class UFCTPartyConnectionCallbackProxy* LeaveParty();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTPartyConnectionCallbackProxy">();
	}
	static class UFCTPartyConnectionCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTPartyConnectionCallbackProxy>();
	}
};
static_assert(alignof(UFCTPartyConnectionCallbackProxy) == 0x000008, "Wrong alignment on UFCTPartyConnectionCallbackProxy");
static_assert(sizeof(UFCTPartyConnectionCallbackProxy) == 0x000050, "Wrong size on UFCTPartyConnectionCallbackProxy");
static_assert(offsetof(UFCTPartyConnectionCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTPartyConnectionCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTPartyConnectionCallbackProxy, OnFail) == 0x000040, "Member 'UFCTPartyConnectionCallbackProxy::OnFail' has a wrong offset!");

// Class SCT.FCTPartyManagementCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTPartyManagementCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UFCTPartyManagementCallbackProxy* InviteUserToParty(const class FString& PlayerId);
	static class UFCTPartyManagementCallbackProxy* KickUserFromParty(const class FString& PlayerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTPartyManagementCallbackProxy">();
	}
	static class UFCTPartyManagementCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTPartyManagementCallbackProxy>();
	}
};
static_assert(alignof(UFCTPartyManagementCallbackProxy) == 0x000008, "Wrong alignment on UFCTPartyManagementCallbackProxy");
static_assert(sizeof(UFCTPartyManagementCallbackProxy) == 0x000050, "Wrong size on UFCTPartyManagementCallbackProxy");
static_assert(offsetof(UFCTPartyManagementCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTPartyManagementCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTPartyManagementCallbackProxy, OnFail) == 0x000040, "Member 'UFCTPartyManagementCallbackProxy::OnFail' has a wrong offset!");

// Class SCT.FCTPartyInfoCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTPartyInfoCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UFCTPartyInfoCallbackProxy* GetPartyInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTPartyInfoCallbackProxy">();
	}
	static class UFCTPartyInfoCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTPartyInfoCallbackProxy>();
	}
};
static_assert(alignof(UFCTPartyInfoCallbackProxy) == 0x000008, "Wrong alignment on UFCTPartyInfoCallbackProxy");
static_assert(sizeof(UFCTPartyInfoCallbackProxy) == 0x000050, "Wrong size on UFCTPartyInfoCallbackProxy");
static_assert(offsetof(UFCTPartyInfoCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTPartyInfoCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTPartyInfoCallbackProxy, OnFail) == 0x000040, "Member 'UFCTPartyInfoCallbackProxy::OnFail' has a wrong offset!");

// Class SCT.FCTJoinPartyCallbackProxy
// 0x0040 (0x0070 - 0x0030)
class UFCTJoinPartyCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailPartyFull;                                   // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailCrossplayRestricted;                         // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTJoinPartyCallbackProxy* JoinPendingConsoleLaunchMultiplayerSession(class UObject* WorldContextObject);
	static class UFCTJoinPartyCallbackProxy* JoinPendingConsoleSession(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTJoinPartyCallbackProxy">();
	}
	static class UFCTJoinPartyCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTJoinPartyCallbackProxy>();
	}
};
static_assert(alignof(UFCTJoinPartyCallbackProxy) == 0x000008, "Wrong alignment on UFCTJoinPartyCallbackProxy");
static_assert(sizeof(UFCTJoinPartyCallbackProxy) == 0x000070, "Wrong size on UFCTJoinPartyCallbackProxy");
static_assert(offsetof(UFCTJoinPartyCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTJoinPartyCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTJoinPartyCallbackProxy, OnFail) == 0x000040, "Member 'UFCTJoinPartyCallbackProxy::OnFail' has a wrong offset!");
static_assert(offsetof(UFCTJoinPartyCallbackProxy, OnFailPartyFull) == 0x000050, "Member 'UFCTJoinPartyCallbackProxy::OnFailPartyFull' has a wrong offset!");
static_assert(offsetof(UFCTJoinPartyCallbackProxy, OnFailCrossplayRestricted) == 0x000060, "Member 'UFCTJoinPartyCallbackProxy::OnFailCrossplayRestricted' has a wrong offset!");

// Class SCT.FCTAccelByteBlockPlayerCallbackProxy
// 0x0050 (0x0080 - 0x0030)
class UFCTAccelByteBlockPlayerCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResponseSuccess;                                 // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x20];                                      // 0x0060(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFCTAccelByteBlockPlayerCallbackProxy* BlockPlayer(class UObject* WorldContextObject, class APlayerController* PlayerController, const class FString& UserId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteBlockPlayerCallbackProxy">();
	}
	static class UFCTAccelByteBlockPlayerCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteBlockPlayerCallbackProxy>();
	}
};
static_assert(alignof(UFCTAccelByteBlockPlayerCallbackProxy) == 0x000008, "Wrong alignment on UFCTAccelByteBlockPlayerCallbackProxy");
static_assert(sizeof(UFCTAccelByteBlockPlayerCallbackProxy) == 0x000080, "Wrong size on UFCTAccelByteBlockPlayerCallbackProxy");
static_assert(offsetof(UFCTAccelByteBlockPlayerCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAccelByteBlockPlayerCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteBlockPlayerCallbackProxy, OnFailure) == 0x000040, "Member 'UFCTAccelByteBlockPlayerCallbackProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteBlockPlayerCallbackProxy, OnResponseSuccess) == 0x000050, "Member 'UFCTAccelByteBlockPlayerCallbackProxy::OnResponseSuccess' has a wrong offset!");

// Class SCT.FCTAccelByteUnblockPlayerCallbackProxy
// 0x0050 (0x0080 - 0x0030)
class UFCTAccelByteUnblockPlayerCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailure;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnResponseSuccess;                                 // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x20];                                      // 0x0060(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFCTAccelByteUnblockPlayerCallbackProxy* UnblockPlayer(class UObject* WorldContextObject, class APlayerController* PlayerController, const class FString& UserId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteUnblockPlayerCallbackProxy">();
	}
	static class UFCTAccelByteUnblockPlayerCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteUnblockPlayerCallbackProxy>();
	}
};
static_assert(alignof(UFCTAccelByteUnblockPlayerCallbackProxy) == 0x000008, "Wrong alignment on UFCTAccelByteUnblockPlayerCallbackProxy");
static_assert(sizeof(UFCTAccelByteUnblockPlayerCallbackProxy) == 0x000080, "Wrong size on UFCTAccelByteUnblockPlayerCallbackProxy");
static_assert(offsetof(UFCTAccelByteUnblockPlayerCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAccelByteUnblockPlayerCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteUnblockPlayerCallbackProxy, OnFailure) == 0x000040, "Member 'UFCTAccelByteUnblockPlayerCallbackProxy::OnFailure' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteUnblockPlayerCallbackProxy, OnResponseSuccess) == 0x000050, "Member 'UFCTAccelByteUnblockPlayerCallbackProxy::OnResponseSuccess' has a wrong offset!");

// Class SCT.FCTMatchmakingManagementCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTMatchmakingManagementCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UFCTMatchmakingManagementCallbackProxy* CancelMatchmaking();
	static class UFCTMatchmakingManagementCallbackProxy* SendReadyConsent();
	static class UFCTMatchmakingManagementCallbackProxy* StartMatchmaking(const class FString& InGameMode, bool AllowCrossPlatformPlay, const class FString& MatchLanguage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTMatchmakingManagementCallbackProxy">();
	}
	static class UFCTMatchmakingManagementCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTMatchmakingManagementCallbackProxy>();
	}
};
static_assert(alignof(UFCTMatchmakingManagementCallbackProxy) == 0x000008, "Wrong alignment on UFCTMatchmakingManagementCallbackProxy");
static_assert(sizeof(UFCTMatchmakingManagementCallbackProxy) == 0x000050, "Wrong size on UFCTMatchmakingManagementCallbackProxy");
static_assert(offsetof(UFCTMatchmakingManagementCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTMatchmakingManagementCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTMatchmakingManagementCallbackProxy, OnFail) == 0x000040, "Member 'UFCTMatchmakingManagementCallbackProxy::OnFail' has a wrong offset!");

// Class SCT.MatchmakingLobbyWidget
// 0x0000 (0x0260 - 0x0260)
class UMatchmakingLobbyWidget : public UUserWidget
{
public:
	void BindEvents();
	void OnDSNotif(const struct FAccelByteModelsDsNotice& Notification);
	void OnMatchmakingNotif(const struct FAccelByteModelsMatchmakingNotice& Notification);
	void OnReadyConsentNotif(const struct FAccelByteModelsReadyConsentNotice& Notification);
	void OnRematchmakingNotif(const struct FAccelByteModelsRematchmakingNotice& Notification);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingLobbyWidget">();
	}
	static class UMatchmakingLobbyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakingLobbyWidget>();
	}
};
static_assert(alignof(UMatchmakingLobbyWidget) == 0x000008, "Wrong alignment on UMatchmakingLobbyWidget");
static_assert(sizeof(UMatchmakingLobbyWidget) == 0x000260, "Wrong size on UMatchmakingLobbyWidget");

// Class SCT.FriendLobbyWidget
// 0x0178 (0x03D8 - 0x0260)
class UFriendLobbyWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x10];                                     // 0x0260(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFCTFriendsList                        OnlineUserList;                                    // 0x0270(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFCTFriendsList                        OfflineUserList;                                   // 0x0298(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFCTFriendsList                        FriendsList;                                       // 0x02C0(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFCTFriendsList                        IncomingList;                                      // 0x02E8(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFCTFriendsList                        OutgoingList;                                      // 0x0310(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFCTFriendsList                        SearchList;                                        // 0x0338(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FFCTFriendsList                        RecentlyPlayedWithPlayers;                         // 0x0360(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             ShowNotificationDelegate;                          // 0x0388(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EFriendsSortType                              SortMethod;                                        // 0x0398(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFriendCardWidget*>              CachedFriendCardWidgets;                           // 0x03A0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UFriendCardWidget*>              CachedOutgoingCardWidgets;                         // 0x03B0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UFriendCardWidget*>              CachedIncomingCardWidgets;                         // 0x03C0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddToPendingPlatformInfoStack(const class FString& UserId);
	void DequeuePendingPlatformInfoRequest();
	void OnGetUserPlatformInfoResponseComplete(const class FString& UserId, const class FString& PlatformName, const class FString& PlatformId);
	void OnNotifyFriendRemoved(const struct FAccelByteModelsUnfriendNotif& Notification);
	void OnNotifyFriendRequestAccepted(const struct FAccelByteModelsAcceptFriendsNotif& Notification);
	void OnNotifyFriendRequestCancelled(const struct FAccelByteModelsCancelFriendsNotif& Notification);
	void OnNotifyFriendRequestRejected(const struct FAccelByteModelsRejectFriendsNotif& Notification);
	void OnNotifyFriendRequestSent(const struct FAccelByteModelsRequestFriendsNotif& Notification);
	void OnPrivateMessageRecieved(const struct FAccelByteModelsPersonalMessageNotice& Notification);
	void OnUserPresenceUpdated(const struct FAccelByteModelsUsersPresenceNotice& Notification);
	void RefreshFriendList(EFFCTFriendListType FriendListType);
	void SortByAvailability(struct FFCTFriendsList* Online, struct FFCTFriendsList* Offline);
	void SortByAvailabilityAscendingOrder(struct FFCTFriendsList* Online, struct FFCTFriendsList* Offline);
	void SortByAvailabilityDescendingOrder(struct FFCTFriendsList* Online, struct FFCTFriendsList* Offline);
	void SortByOnlineOnly(struct FFCTFriendsList* Online);
	void SortByPlatform(struct FFCTFriendsList* Online, struct FFCTFriendsList* Offline);
	void SortCachedByAvailability(TArray<class UFriendCardWidget*>* Online, TArray<class UFriendCardWidget*>* Offline);
	void SortCachedByAvailabilityAscendingOrder(TArray<class UFriendCardWidget*>* Online, TArray<class UFriendCardWidget*>* Offline);
	void SortCachedByAvailabilityDescendingOrder(TArray<class UFriendCardWidget*>* Online, TArray<class UFriendCardWidget*>* Offline);
	void SortCachedByOnlineOnly(TArray<class UFriendCardWidget*>* Online);
	void SortCachedByPlatform(TArray<class UFriendCardWidget*>* Online, TArray<class UFriendCardWidget*>* Offline);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendLobbyWidget">();
	}
	static class UFriendLobbyWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendLobbyWidget>();
	}
};
static_assert(alignof(UFriendLobbyWidget) == 0x000008, "Wrong alignment on UFriendLobbyWidget");
static_assert(sizeof(UFriendLobbyWidget) == 0x0003D8, "Wrong size on UFriendLobbyWidget");
static_assert(offsetof(UFriendLobbyWidget, OnlineUserList) == 0x000270, "Member 'UFriendLobbyWidget::OnlineUserList' has a wrong offset!");
static_assert(offsetof(UFriendLobbyWidget, OfflineUserList) == 0x000298, "Member 'UFriendLobbyWidget::OfflineUserList' has a wrong offset!");
static_assert(offsetof(UFriendLobbyWidget, FriendsList) == 0x0002C0, "Member 'UFriendLobbyWidget::FriendsList' has a wrong offset!");
static_assert(offsetof(UFriendLobbyWidget, IncomingList) == 0x0002E8, "Member 'UFriendLobbyWidget::IncomingList' has a wrong offset!");
static_assert(offsetof(UFriendLobbyWidget, OutgoingList) == 0x000310, "Member 'UFriendLobbyWidget::OutgoingList' has a wrong offset!");
static_assert(offsetof(UFriendLobbyWidget, SearchList) == 0x000338, "Member 'UFriendLobbyWidget::SearchList' has a wrong offset!");
static_assert(offsetof(UFriendLobbyWidget, RecentlyPlayedWithPlayers) == 0x000360, "Member 'UFriendLobbyWidget::RecentlyPlayedWithPlayers' has a wrong offset!");
static_assert(offsetof(UFriendLobbyWidget, ShowNotificationDelegate) == 0x000388, "Member 'UFriendLobbyWidget::ShowNotificationDelegate' has a wrong offset!");
static_assert(offsetof(UFriendLobbyWidget, SortMethod) == 0x000398, "Member 'UFriendLobbyWidget::SortMethod' has a wrong offset!");
static_assert(offsetof(UFriendLobbyWidget, CachedFriendCardWidgets) == 0x0003A0, "Member 'UFriendLobbyWidget::CachedFriendCardWidgets' has a wrong offset!");
static_assert(offsetof(UFriendLobbyWidget, CachedOutgoingCardWidgets) == 0x0003B0, "Member 'UFriendLobbyWidget::CachedOutgoingCardWidgets' has a wrong offset!");
static_assert(offsetof(UFriendLobbyWidget, CachedIncomingCardWidgets) == 0x0003C0, "Member 'UFriendLobbyWidget::CachedIncomingCardWidgets' has a wrong offset!");

// Class SCT.PartyMemberCardUserWidget
// 0x0000 (0x0268 - 0x0268)
class UPartyMemberCardUserWidget : public UUserCardBaseWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyMemberCardUserWidget">();
	}
	static class UPartyMemberCardUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyMemberCardUserWidget>();
	}
};
static_assert(alignof(UPartyMemberCardUserWidget) == 0x000008, "Wrong alignment on UPartyMemberCardUserWidget");
static_assert(sizeof(UPartyMemberCardUserWidget) == 0x000268, "Wrong size on UPartyMemberCardUserWidget");

// Class SCT.WidgetOrganizer
// 0x0050 (0x0100 - 0x00B0)
class UWidgetOrganizer final : public UActorComponent
{
public:
	TMap<TSoftObjectPtr<class UWidgetSCT>, struct FWidgetOrganizerEntryValue> Widgets;                                           // 0x00B0(0x0050)(NativeAccessSpecifierPrivate)

public:
	void Add(class UWidgetSCT* WidgetInstance, int32 behaviourOverride);
	class UWidgetSCT* CreateWidget(TSubclassOf<class UWidgetSCT> WidgetType, int32 behaviourOverride);
	void OnWidgetRemovedExternally(class UWidgetSCT* Widget);
	void Remove(class UWidgetSCT* Widget, bool RemoveFromParent);

	bool Contains(class UWidgetSCT* Widget) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetOrganizer">();
	}
	static class UWidgetOrganizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetOrganizer>();
	}
};
static_assert(alignof(UWidgetOrganizer) == 0x000008, "Wrong alignment on UWidgetOrganizer");
static_assert(sizeof(UWidgetOrganizer) == 0x000100, "Wrong size on UWidgetOrganizer");
static_assert(offsetof(UWidgetOrganizer, Widgets) == 0x0000B0, "Member 'UWidgetOrganizer::Widgets' has a wrong offset!");

// Class SCT.ConsoleSessionManagement
// 0x0070 (0x0098 - 0x0028)
class UConsoleSessionManagement final : public UObject
{
public:
	uint8                                         Pad_28[0x70];                                      // 0x0028(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ShowConsoleInviteUI();

	void OnCreateSessionComplete(class FName SessionName, bool bWasSuccessful);
	void OnReconnectedToLobby();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ConsoleSessionManagement">();
	}
	static class UConsoleSessionManagement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UConsoleSessionManagement>();
	}
};
static_assert(alignof(UConsoleSessionManagement) == 0x000008, "Wrong alignment on UConsoleSessionManagement");
static_assert(sizeof(UConsoleSessionManagement) == 0x000098, "Wrong size on UConsoleSessionManagement");

// Class SCT.FCTAccelByteLoginWidget
// 0x0000 (0x0260 - 0x0260)
class UFCTAccelByteLoginWidget final : public UUserWidget
{
public:
	void SetConnectionBinds();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteLoginWidget">();
	}
	static class UFCTAccelByteLoginWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteLoginWidget>();
	}
};
static_assert(alignof(UFCTAccelByteLoginWidget) == 0x000008, "Wrong alignment on UFCTAccelByteLoginWidget");
static_assert(sizeof(UFCTAccelByteLoginWidget) == 0x000260, "Wrong size on UFCTAccelByteLoginWidget");

// Class SCT.FCTGetUserPlatformInfoCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTGetUserPlatformInfoCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTGetUserPlatformInfoCallbackProxy* GetUserPlatformInfo(const class FString& UserId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGetUserPlatformInfoCallbackProxy">();
	}
	static class UFCTGetUserPlatformInfoCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGetUserPlatformInfoCallbackProxy>();
	}
};
static_assert(alignof(UFCTGetUserPlatformInfoCallbackProxy) == 0x000008, "Wrong alignment on UFCTGetUserPlatformInfoCallbackProxy");
static_assert(sizeof(UFCTGetUserPlatformInfoCallbackProxy) == 0x000050, "Wrong size on UFCTGetUserPlatformInfoCallbackProxy");
static_assert(offsetof(UFCTGetUserPlatformInfoCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTGetUserPlatformInfoCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTGetUserPlatformInfoCallbackProxy, OnError) == 0x000040, "Member 'UFCTGetUserPlatformInfoCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTPlatformBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UFCTPlatformBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GenerateRandomAccelByteProfileCode();
	static EAccelBytePlatformSync GetAccelBytePlatformSync();
	static void GetPlatformType(EAccelBytePlatformType* OutputExec);
	static class FString GetPlatformUserDisplayName();
	static class FString GetPlatformUserID();
	static class UTexture2D* GetProfileAvatar();
	static void GetSplitDisplayNameAndFriendCode(const class FString& InFullDisplayName, class FString* OutDisplayName, class FString* OutFriendCode);
	static bool IsPlatformDLCInstalled(int32 ID);
	static void OpenStorePage(class UAccelByteGIS* AccelByteGIS, const class FString& Category, const class FString& ProductId, bool AddToCart);
	static void OpenVersusEvilLogin();
	static bool RegistrationPasswordIsValid(const class FString& Password, int32* ErrorCode);
	static bool RegistrationWasViewed();
	static void SetDisplayNameWithoutFriendCodeToTextBlock(class UTextBlock* InText, class FString& OutDisplayName);
	static void SetUserDisplayNameWithFalloffToTextBlock(class UTextBlock* InText, class FString& OutDisplayName, int32 TotalWidth);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTPlatformBlueprintFunctionLibrary">();
	}
	static class UFCTPlatformBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTPlatformBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UFCTPlatformBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UFCTPlatformBlueprintFunctionLibrary");
static_assert(sizeof(UFCTPlatformBlueprintFunctionLibrary) == 0x000028, "Wrong size on UFCTPlatformBlueprintFunctionLibrary");

// Class SCT.FCTAchievementPopUp
// 0x0028 (0x0288 - 0x0260)
class UFCTAchievementPopUp : public UUserWidget
{
public:
	class UOverlay*                               AchievementContainer;                              // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             AchievementName;                                   // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             AchievementDescription;                            // 0x0270(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UImage*                                 AchievementIcon;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFCTAchievement*                        AchievementPayload;                                // 0x0280(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void Init(class UFCTAchievement* Achievement);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAchievementPopUp">();
	}
	static class UFCTAchievementPopUp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAchievementPopUp>();
	}
};
static_assert(alignof(UFCTAchievementPopUp) == 0x000008, "Wrong alignment on UFCTAchievementPopUp");
static_assert(sizeof(UFCTAchievementPopUp) == 0x000288, "Wrong size on UFCTAchievementPopUp");
static_assert(offsetof(UFCTAchievementPopUp, AchievementContainer) == 0x000260, "Member 'UFCTAchievementPopUp::AchievementContainer' has a wrong offset!");
static_assert(offsetof(UFCTAchievementPopUp, AchievementName) == 0x000268, "Member 'UFCTAchievementPopUp::AchievementName' has a wrong offset!");
static_assert(offsetof(UFCTAchievementPopUp, AchievementDescription) == 0x000270, "Member 'UFCTAchievementPopUp::AchievementDescription' has a wrong offset!");
static_assert(offsetof(UFCTAchievementPopUp, AchievementIcon) == 0x000278, "Member 'UFCTAchievementPopUp::AchievementIcon' has a wrong offset!");
static_assert(offsetof(UFCTAchievementPopUp, AchievementPayload) == 0x000280, "Member 'UFCTAchievementPopUp::AchievementPayload' has a wrong offset!");

// Class SCT.FCTStatIncrementCallbackProxy
// 0x0030 (0x0060 - 0x0030)
class UFCTStatIncrementCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x10];                                      // 0x0050(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFCTStatIncrementCallbackProxy* UpdateStatistic(const class FString& StatCode, float IncrementalValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTStatIncrementCallbackProxy">();
	}
	static class UFCTStatIncrementCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTStatIncrementCallbackProxy>();
	}
};
static_assert(alignof(UFCTStatIncrementCallbackProxy) == 0x000008, "Wrong alignment on UFCTStatIncrementCallbackProxy");
static_assert(sizeof(UFCTStatIncrementCallbackProxy) == 0x000060, "Wrong size on UFCTStatIncrementCallbackProxy");
static_assert(offsetof(UFCTStatIncrementCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTStatIncrementCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTStatIncrementCallbackProxy, OnError) == 0x000040, "Member 'UFCTStatIncrementCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTGetStatsCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTGetStatsCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTGetStatsCallbackProxy* GetStatistic(const class FString& StatCode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGetStatsCallbackProxy">();
	}
	static class UFCTGetStatsCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGetStatsCallbackProxy>();
	}
};
static_assert(alignof(UFCTGetStatsCallbackProxy) == 0x000008, "Wrong alignment on UFCTGetStatsCallbackProxy");
static_assert(sizeof(UFCTGetStatsCallbackProxy) == 0x000050, "Wrong size on UFCTGetStatsCallbackProxy");
static_assert(offsetof(UFCTGetStatsCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTGetStatsCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTGetStatsCallbackProxy, OnError) == 0x000040, "Member 'UFCTGetStatsCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTIncrementUnlinkedStatsCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTIncrementUnlinkedStatsCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTIncrementUnlinkedStatsCallbackProxy* IncrementUnlinkedStatistic(const class FString& StatCode, float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTIncrementUnlinkedStatsCallbackProxy">();
	}
	static class UFCTIncrementUnlinkedStatsCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTIncrementUnlinkedStatsCallbackProxy>();
	}
};
static_assert(alignof(UFCTIncrementUnlinkedStatsCallbackProxy) == 0x000008, "Wrong alignment on UFCTIncrementUnlinkedStatsCallbackProxy");
static_assert(sizeof(UFCTIncrementUnlinkedStatsCallbackProxy) == 0x000050, "Wrong size on UFCTIncrementUnlinkedStatsCallbackProxy");
static_assert(offsetof(UFCTIncrementUnlinkedStatsCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTIncrementUnlinkedStatsCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTIncrementUnlinkedStatsCallbackProxy, OnError) == 0x000040, "Member 'UFCTIncrementUnlinkedStatsCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTAchievementListCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAchievementListCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAchievementListCallbackProxy* GetRecentlyUnlockedUserAchievements(int32 Count);
	static class UFCTAchievementListCallbackProxy* GetUserAchievements(class UAccelByteGIS* AccelByteGIS);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAchievementListCallbackProxy">();
	}
	static class UFCTAchievementListCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAchievementListCallbackProxy>();
	}
};
static_assert(alignof(UFCTAchievementListCallbackProxy) == 0x000008, "Wrong alignment on UFCTAchievementListCallbackProxy");
static_assert(sizeof(UFCTAchievementListCallbackProxy) == 0x000050, "Wrong size on UFCTAchievementListCallbackProxy");
static_assert(offsetof(UFCTAchievementListCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAchievementListCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAchievementListCallbackProxy, OnError) == 0x000040, "Member 'UFCTAchievementListCallbackProxy::OnError' has a wrong offset!");

// Class SCT.BulkUserDataCallbackProxy
// 0x0038 (0x0068 - 0x0030)
class UBulkUserDataCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FSimpleUserData>                UsersInfo;                                         // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBulkUserDataCallbackProxy* GetBulkUsersData(const TArray<class FString>& UserIds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BulkUserDataCallbackProxy">();
	}
	static class UBulkUserDataCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBulkUserDataCallbackProxy>();
	}
};
static_assert(alignof(UBulkUserDataCallbackProxy) == 0x000008, "Wrong alignment on UBulkUserDataCallbackProxy");
static_assert(sizeof(UBulkUserDataCallbackProxy) == 0x000068, "Wrong size on UBulkUserDataCallbackProxy");
static_assert(offsetof(UBulkUserDataCallbackProxy, OnSuccess) == 0x000030, "Member 'UBulkUserDataCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UBulkUserDataCallbackProxy, OnError) == 0x000040, "Member 'UBulkUserDataCallbackProxy::OnError' has a wrong offset!");
static_assert(offsetof(UBulkUserDataCallbackProxy, UsersInfo) == 0x000050, "Member 'UBulkUserDataCallbackProxy::UsersInfo' has a wrong offset!");

// Class SCT.FCTAchievementUnlockCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAchievementUnlockCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             Success;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAchievementUnlockCallbackProxy* UnlockAchievement(const class FString& Code);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAchievementUnlockCallbackProxy">();
	}
	static class UFCTAchievementUnlockCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAchievementUnlockCallbackProxy>();
	}
};
static_assert(alignof(UFCTAchievementUnlockCallbackProxy) == 0x000008, "Wrong alignment on UFCTAchievementUnlockCallbackProxy");
static_assert(sizeof(UFCTAchievementUnlockCallbackProxy) == 0x000050, "Wrong size on UFCTAchievementUnlockCallbackProxy");
static_assert(offsetof(UFCTAchievementUnlockCallbackProxy, Success) == 0x000030, "Member 'UFCTAchievementUnlockCallbackProxy::Success' has a wrong offset!");
static_assert(offsetof(UFCTAchievementUnlockCallbackProxy, OnError) == 0x000040, "Member 'UFCTAchievementUnlockCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTGetTrophyRecordCallbackProxy
// 0x0048 (0x0078 - 0x0030)
class UFCTGetTrophyRecordCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnRecordFound;                                     // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDefault;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x18];                                      // 0x0060(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFCTGetTrophyRecordCallbackProxy* GetTrophyCustomizationRecord();

	void GetUserSelectedTrophies(struct FCloudTrophyInfo* TrophyRecord);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGetTrophyRecordCallbackProxy">();
	}
	static class UFCTGetTrophyRecordCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGetTrophyRecordCallbackProxy>();
	}
};
static_assert(alignof(UFCTGetTrophyRecordCallbackProxy) == 0x000008, "Wrong alignment on UFCTGetTrophyRecordCallbackProxy");
static_assert(sizeof(UFCTGetTrophyRecordCallbackProxy) == 0x000078, "Wrong size on UFCTGetTrophyRecordCallbackProxy");
static_assert(offsetof(UFCTGetTrophyRecordCallbackProxy, OnRecordFound) == 0x000030, "Member 'UFCTGetTrophyRecordCallbackProxy::OnRecordFound' has a wrong offset!");
static_assert(offsetof(UFCTGetTrophyRecordCallbackProxy, OnDefault) == 0x000040, "Member 'UFCTGetTrophyRecordCallbackProxy::OnDefault' has a wrong offset!");
static_assert(offsetof(UFCTGetTrophyRecordCallbackProxy, OnError) == 0x000050, "Member 'UFCTGetTrophyRecordCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTSetTrophyRecordCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTSetTrophyRecordCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTSetTrophyRecordCallbackProxy* SetTrophyCustomizationRecord(const TArray<struct FCloudTrophy>& SelectedTrophies);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTSetTrophyRecordCallbackProxy">();
	}
	static class UFCTSetTrophyRecordCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTSetTrophyRecordCallbackProxy>();
	}
};
static_assert(alignof(UFCTSetTrophyRecordCallbackProxy) == 0x000008, "Wrong alignment on UFCTSetTrophyRecordCallbackProxy");
static_assert(sizeof(UFCTSetTrophyRecordCallbackProxy) == 0x000050, "Wrong size on UFCTSetTrophyRecordCallbackProxy");
static_assert(offsetof(UFCTSetTrophyRecordCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTSetTrophyRecordCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTSetTrophyRecordCallbackProxy, OnError) == 0x000040, "Member 'UFCTSetTrophyRecordCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTGameRecordStatisticsBlueprintLibrary
// 0x0000 (0x0028 - 0x0028)
class UFCTGameRecordStatisticsBlueprintLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void ClientIncrementGlobalStatistic(EGlobalClientStatistics Statistic);
	static void ServerIncrementGlobalStatistic(EGlobalServerStatistics Statistic);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTGameRecordStatisticsBlueprintLibrary">();
	}
	static class UFCTGameRecordStatisticsBlueprintLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTGameRecordStatisticsBlueprintLibrary>();
	}
};
static_assert(alignof(UFCTGameRecordStatisticsBlueprintLibrary) == 0x000008, "Wrong alignment on UFCTGameRecordStatisticsBlueprintLibrary");
static_assert(sizeof(UFCTGameRecordStatisticsBlueprintLibrary) == 0x000028, "Wrong size on UFCTGameRecordStatisticsBlueprintLibrary");

// Class SCT.BlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy
// 0x0028 (0x0058 - 0x0030)
class UBlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnComplete;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x18];                                      // 0x0040(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy* CheckAnonymousCommunicationPrivilege(class UObject* WorldContextObject, class APlayerController* InPlayerController, bool bInIsFriend, bool bInForceUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy">();
	}
	static class UBlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy>();
	}
};
static_assert(alignof(UBlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy) == 0x000008, "Wrong alignment on UBlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy");
static_assert(sizeof(UBlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy) == 0x000058, "Wrong size on UBlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy");
static_assert(offsetof(UBlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy, OnComplete) == 0x000030, "Member 'UBlueprintXboxAnonymousUserPrivilegeCheckerCallbackProxy::OnComplete' has a wrong offset!");

// Class SCT.FCTAchievementPopUpQueueWidget
// 0x0000 (0x0260 - 0x0260)
class UFCTAchievementPopUpQueueWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAchievementPopUpQueueWidget">();
	}
	static class UFCTAchievementPopUpQueueWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAchievementPopUpQueueWidget>();
	}
};
static_assert(alignof(UFCTAchievementPopUpQueueWidget) == 0x000008, "Wrong alignment on UFCTAchievementPopUpQueueWidget");
static_assert(sizeof(UFCTAchievementPopUpQueueWidget) == 0x000260, "Wrong size on UFCTAchievementPopUpQueueWidget");

// Class SCT.FCTAccelByteGetUserUtils
// 0x0020 (0x0050 - 0x0030)
class UFCTAccelByteGetUserUtils final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UFCTAccelByteGetUserUtils* GetUserInfo(const class FString& UserId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteGetUserUtils">();
	}
	static class UFCTAccelByteGetUserUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteGetUserUtils>();
	}
};
static_assert(alignof(UFCTAccelByteGetUserUtils) == 0x000008, "Wrong alignment on UFCTAccelByteGetUserUtils");
static_assert(sizeof(UFCTAccelByteGetUserUtils) == 0x000050, "Wrong size on UFCTAccelByteGetUserUtils");
static_assert(offsetof(UFCTAccelByteGetUserUtils, OnSuccess) == 0x000030, "Member 'UFCTAccelByteGetUserUtils::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteGetUserUtils, OnFail) == 0x000040, "Member 'UFCTAccelByteGetUserUtils::OnFail' has a wrong offset!");

// Class SCT.FCTAccelByteKarmaStat
// 0x0028 (0x0058 - 0x0030)
class UFCTAccelByteKarmaStat final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         KarmaToAdd;                                        // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFCTAccelByteKarmaStat* AddToCurrentKarma(int32 Amount);
	static class UFCTAccelByteKarmaStat* GetCurrentKarma();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteKarmaStat">();
	}
	static class UFCTAccelByteKarmaStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteKarmaStat>();
	}
};
static_assert(alignof(UFCTAccelByteKarmaStat) == 0x000008, "Wrong alignment on UFCTAccelByteKarmaStat");
static_assert(sizeof(UFCTAccelByteKarmaStat) == 0x000058, "Wrong size on UFCTAccelByteKarmaStat");
static_assert(offsetof(UFCTAccelByteKarmaStat, OnSuccess) == 0x000030, "Member 'UFCTAccelByteKarmaStat::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteKarmaStat, OnError) == 0x000040, "Member 'UFCTAccelByteKarmaStat::OnError' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteKarmaStat, KarmaToAdd) == 0x000050, "Member 'UFCTAccelByteKarmaStat::KarmaToAdd' has a wrong offset!");

// Class SCT.FCTAccountMigrationCallbackProxy
// 0x0318 (0x0348 - 0x0030)
class UFCTAccountMigrationCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCloudSavesSuccess;                               // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAchievementsSuccess;                             // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStatsSuccess;                                    // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEntitlementsSuccess;                             // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFCTUserAccountMergerPayload           MergePayload;                                      // 0x0098(0x02A0)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_338[0x10];                                     // 0x0338(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFCTAccountMigrationCallbackProxy* GetCurrentAccountInformation();
	static class UFCTAccountMigrationCallbackProxy* MigrateToNewAccount(const struct FFCTUserAccountMergerPayload& MergePayload_0);

	void MergeAchievementsToNewAccount();
	void MergeBulkFriendsToNewAccount();
	void MergeEntitlementsToNewAccount();
	void MergeStatsToNewAccount();
	void QueryAchievementsFromCurrentAccount();
	void QueryBulkFriendsFromCurrentAccount();
	void QueryEntitlementsFromCurrentAccount();
	void QueryStatsFromCurrentAccount();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccountMigrationCallbackProxy">();
	}
	static class UFCTAccountMigrationCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccountMigrationCallbackProxy>();
	}
};
static_assert(alignof(UFCTAccountMigrationCallbackProxy) == 0x000008, "Wrong alignment on UFCTAccountMigrationCallbackProxy");
static_assert(sizeof(UFCTAccountMigrationCallbackProxy) == 0x000348, "Wrong size on UFCTAccountMigrationCallbackProxy");
static_assert(offsetof(UFCTAccountMigrationCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAccountMigrationCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccountMigrationCallbackProxy, OnError) == 0x000040, "Member 'UFCTAccountMigrationCallbackProxy::OnError' has a wrong offset!");
static_assert(offsetof(UFCTAccountMigrationCallbackProxy, OnCloudSavesSuccess) == 0x000050, "Member 'UFCTAccountMigrationCallbackProxy::OnCloudSavesSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccountMigrationCallbackProxy, OnAchievementsSuccess) == 0x000060, "Member 'UFCTAccountMigrationCallbackProxy::OnAchievementsSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccountMigrationCallbackProxy, OnStatsSuccess) == 0x000070, "Member 'UFCTAccountMigrationCallbackProxy::OnStatsSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccountMigrationCallbackProxy, OnEntitlementsSuccess) == 0x000080, "Member 'UFCTAccountMigrationCallbackProxy::OnEntitlementsSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccountMigrationCallbackProxy, MergePayload) == 0x000098, "Member 'UFCTAccountMigrationCallbackProxy::MergePayload' has a wrong offset!");

// Class SCT.CloudDataCallbackProxy
// 0x0030 (0x0060 - 0x0030)
class UCloudDataCallbackProxy : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_30[0x20];                                      // 0x0030(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudDataCallbackProxy">();
	}
	static class UCloudDataCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudDataCallbackProxy>();
	}
};
static_assert(alignof(UCloudDataCallbackProxy) == 0x000008, "Wrong alignment on UCloudDataCallbackProxy");
static_assert(sizeof(UCloudDataCallbackProxy) == 0x000060, "Wrong size on UCloudDataCallbackProxy");
static_assert(offsetof(UCloudDataCallbackProxy, OnError) == 0x000050, "Member 'UCloudDataCallbackProxy::OnError' has a wrong offset!");

// Class SCT.SetCloudDataCallbackProxy
// 0x0020 (0x0080 - 0x0060)
class USetCloudDataCallbackProxy : public UCloudDataCallbackProxy
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetCloudDataCallbackProxy">();
	}
	static class USetCloudDataCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetCloudDataCallbackProxy>();
	}
};
static_assert(alignof(USetCloudDataCallbackProxy) == 0x000008, "Wrong alignment on USetCloudDataCallbackProxy");
static_assert(sizeof(USetCloudDataCallbackProxy) == 0x000080, "Wrong size on USetCloudDataCallbackProxy");
static_assert(offsetof(USetCloudDataCallbackProxy, OnSuccess) == 0x000060, "Member 'USetCloudDataCallbackProxy::OnSuccess' has a wrong offset!");

// Class SCT.SetCloudIntDataCallbackProxy
// 0x0008 (0x0088 - 0x0080)
class USetCloudIntDataCallbackProxy final : public USetCloudDataCallbackProxy
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USetCloudIntDataCallbackProxy* SetCloudRecordValue(EUserRecordType UserRecord, const class FString& FieldName, const int32 AddValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetCloudIntDataCallbackProxy">();
	}
	static class USetCloudIntDataCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetCloudIntDataCallbackProxy>();
	}
};
static_assert(alignof(USetCloudIntDataCallbackProxy) == 0x000008, "Wrong alignment on USetCloudIntDataCallbackProxy");
static_assert(sizeof(USetCloudIntDataCallbackProxy) == 0x000088, "Wrong size on USetCloudIntDataCallbackProxy");

// Class SCT.FCTAccelByteSearchUserUtils
// 0x0020 (0x0050 - 0x0030)
class UFCTAccelByteSearchUserUtils final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnFail;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UFCTAccelByteSearchUserUtils* SearchUsers(const class FString& Query);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteSearchUserUtils">();
	}
	static class UFCTAccelByteSearchUserUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteSearchUserUtils>();
	}
};
static_assert(alignof(UFCTAccelByteSearchUserUtils) == 0x000008, "Wrong alignment on UFCTAccelByteSearchUserUtils");
static_assert(sizeof(UFCTAccelByteSearchUserUtils) == 0x000050, "Wrong size on UFCTAccelByteSearchUserUtils");
static_assert(offsetof(UFCTAccelByteSearchUserUtils, OnSuccess) == 0x000030, "Member 'UFCTAccelByteSearchUserUtils::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteSearchUserUtils, OnFail) == 0x000040, "Member 'UFCTAccelByteSearchUserUtils::OnFail' has a wrong offset!");

// Class SCT.FCTAccelByteCloudPublicProfileCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAccelByteCloudPublicProfileCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAccelByteCloudPublicProfileCallbackProxy* GetCloudPublicProfile();
	static class UFCTAccelByteCloudPublicProfileCallbackProxy* GetUserCloudPublicProfile(const class FString& UserId);
	static class UFCTAccelByteCloudPublicProfileCallbackProxy* SetCloudPublicProfile(int32 AddedExperience);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteCloudPublicProfileCallbackProxy">();
	}
	static class UFCTAccelByteCloudPublicProfileCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteCloudPublicProfileCallbackProxy>();
	}
};
static_assert(alignof(UFCTAccelByteCloudPublicProfileCallbackProxy) == 0x000008, "Wrong alignment on UFCTAccelByteCloudPublicProfileCallbackProxy");
static_assert(sizeof(UFCTAccelByteCloudPublicProfileCallbackProxy) == 0x000050, "Wrong size on UFCTAccelByteCloudPublicProfileCallbackProxy");
static_assert(offsetof(UFCTAccelByteCloudPublicProfileCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAccelByteCloudPublicProfileCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteCloudPublicProfileCallbackProxy, OnError) == 0x000040, "Member 'UFCTAccelByteCloudPublicProfileCallbackProxy::OnError' has a wrong offset!");

// Class SCT.ServiceMessageHandler
// 0x0020 (0x0050 - 0x0030)
class UServiceMessageHandler final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UServiceMessageHandler* GetServiceMessagesFromGameRecord();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServiceMessageHandler">();
	}
	static class UServiceMessageHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServiceMessageHandler>();
	}
};
static_assert(alignof(UServiceMessageHandler) == 0x000008, "Wrong alignment on UServiceMessageHandler");
static_assert(sizeof(UServiceMessageHandler) == 0x000050, "Wrong size on UServiceMessageHandler");
static_assert(offsetof(UServiceMessageHandler, OnSuccess) == 0x000030, "Member 'UServiceMessageHandler::OnSuccess' has a wrong offset!");
static_assert(offsetof(UServiceMessageHandler, OnError) == 0x000040, "Member 'UServiceMessageHandler::OnError' has a wrong offset!");

// Class SCT.FCTAccelByteCustomizationPayloadCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAccelByteCustomizationPayloadCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAccelByteCustomizationPayloadCallbackProxy* GetUserCustomizationPayload();
	static class UFCTAccelByteCustomizationPayloadCallbackProxy* SetUserCustomizationPayload(const struct FFCTCloudCustomizationGender& Male, const struct FFCTCloudCustomizationGender& Female, const struct FFCTCloudCustomizationVruumba& Vruumba, bool MaleSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteCustomizationPayloadCallbackProxy">();
	}
	static class UFCTAccelByteCustomizationPayloadCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteCustomizationPayloadCallbackProxy>();
	}
};
static_assert(alignof(UFCTAccelByteCustomizationPayloadCallbackProxy) == 0x000008, "Wrong alignment on UFCTAccelByteCustomizationPayloadCallbackProxy");
static_assert(sizeof(UFCTAccelByteCustomizationPayloadCallbackProxy) == 0x000050, "Wrong size on UFCTAccelByteCustomizationPayloadCallbackProxy");
static_assert(offsetof(UFCTAccelByteCustomizationPayloadCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAccelByteCustomizationPayloadCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteCustomizationPayloadCallbackProxy, OnError) == 0x000040, "Member 'UFCTAccelByteCustomizationPayloadCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTAccelByteCustomizationSettingsCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAccelByteCustomizationSettingsCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAccelByteCustomizationSettingsCallbackProxy* GetCustomizationSettingsByUserId(const class FString& UserId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteCustomizationSettingsCallbackProxy">();
	}
	static class UFCTAccelByteCustomizationSettingsCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteCustomizationSettingsCallbackProxy>();
	}
};
static_assert(alignof(UFCTAccelByteCustomizationSettingsCallbackProxy) == 0x000008, "Wrong alignment on UFCTAccelByteCustomizationSettingsCallbackProxy");
static_assert(sizeof(UFCTAccelByteCustomizationSettingsCallbackProxy) == 0x000050, "Wrong size on UFCTAccelByteCustomizationSettingsCallbackProxy");
static_assert(offsetof(UFCTAccelByteCustomizationSettingsCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAccelByteCustomizationSettingsCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteCustomizationSettingsCallbackProxy, OnError) == 0x000040, "Member 'UFCTAccelByteCustomizationSettingsCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTAccelByteVruumbaCustomizationSettingsCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy* GetVruumbaCustomizationSettingsByUserId(const class FString& UserId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteVruumbaCustomizationSettingsCallbackProxy">();
	}
	static class UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy>();
	}
};
static_assert(alignof(UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy) == 0x000008, "Wrong alignment on UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy");
static_assert(sizeof(UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy) == 0x000050, "Wrong size on UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy");
static_assert(offsetof(UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy, OnError) == 0x000040, "Member 'UFCTAccelByteVruumbaCustomizationSettingsCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTAccelByteVirtualPurchasesCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAccelByteVirtualPurchasesCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAccelByteVirtualPurchasesCallbackProxy* GetInGamePurchasingPayload();
	static class UFCTAccelByteVirtualPurchasesCallbackProxy* PurchaseItemWithFirstClassTokens(const class FString& Name_0, int32 Cost);
	static class UFCTAccelByteVirtualPurchasesCallbackProxy* UpdateFirstClassTokenWallet(int32 AddedCurrency);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteVirtualPurchasesCallbackProxy">();
	}
	static class UFCTAccelByteVirtualPurchasesCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteVirtualPurchasesCallbackProxy>();
	}
};
static_assert(alignof(UFCTAccelByteVirtualPurchasesCallbackProxy) == 0x000008, "Wrong alignment on UFCTAccelByteVirtualPurchasesCallbackProxy");
static_assert(sizeof(UFCTAccelByteVirtualPurchasesCallbackProxy) == 0x000050, "Wrong size on UFCTAccelByteVirtualPurchasesCallbackProxy");
static_assert(offsetof(UFCTAccelByteVirtualPurchasesCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAccelByteVirtualPurchasesCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAccelByteVirtualPurchasesCallbackProxy, OnError) == 0x000040, "Member 'UFCTAccelByteVirtualPurchasesCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTCloudEmotesCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTCloudEmotesCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTCloudEmotesCallbackProxy* GetEmotesFromCloud();
	static class UFCTCloudEmotesCallbackProxy* SetEmotesToCloud(const TArray<class FString>& Names);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTCloudEmotesCallbackProxy">();
	}
	static class UFCTCloudEmotesCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTCloudEmotesCallbackProxy>();
	}
};
static_assert(alignof(UFCTCloudEmotesCallbackProxy) == 0x000008, "Wrong alignment on UFCTCloudEmotesCallbackProxy");
static_assert(sizeof(UFCTCloudEmotesCallbackProxy) == 0x000050, "Wrong size on UFCTCloudEmotesCallbackProxy");
static_assert(offsetof(UFCTCloudEmotesCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTCloudEmotesCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTCloudEmotesCallbackProxy, OnError) == 0x000040, "Member 'UFCTCloudEmotesCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTAccelByteUtilities
// 0x0000 (0x0028 - 0x0028)
class UFCTAccelByteUtilities final : public UBlueprintFunctionLibrary
{
public:
	static class FString ConvertToAlphaNumeric(const class FString& Input);
	static bool DoesItemHaveUniqueSku(const struct FAccelByteModelsEntitlementInfo& ABEntitlementInfo, const class FString& FCTSku);
	static bool IsEntitlementFoundInLocalData(const struct FAccelByteModelsEntitlementInfo& ABEntitlementInfo, const class FString& FCTSku);
	static bool IsItemEqual(const struct FAccelByteModelsEntitlementInfo& ABEntitlementInfo, const class FString& FCTSku);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAccelByteUtilities">();
	}
	static class UFCTAccelByteUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAccelByteUtilities>();
	}
};
static_assert(alignof(UFCTAccelByteUtilities) == 0x000008, "Wrong alignment on UFCTAccelByteUtilities");
static_assert(sizeof(UFCTAccelByteUtilities) == 0x000028, "Wrong size on UFCTAccelByteUtilities");

// Class SCT.FCTSettings
// 0x0478 (0x04A0 - 0x0028)
class UFCTSettings final : public UObject
{
public:
	int32                                         ProjectChangelist;                                 // 0x0028(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GlobalCooldownDuration;                            // 0x002C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OxygenGrantedPostTravel;                           // 0x0030(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UFCTAchievementPopUp>       PopUpClass;                                        // 0x0038(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              ScoreDataTable;                                    // 0x0040(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AAfterlifeCharacter>        DeadCharacterType;                                 // 0x0068(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAgendaGenericEvent>     OnAnyVoteChanged;                                  // 0x0070(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FKey>                           ContextUIOrder;                                    // 0x0098(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TSubclassOf<class USCTLoadingScreenWidget>    LoadingScreenWidgetType;                           // 0x00A8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              FallbackLoadingScreen;                             // 0x00B0(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UProgressBarWidget>         DefaultProgressBar;                                // 0x00D8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USkillcheckWidget>          DefaultInfiniteSkillcheck;                         // 0x00E0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class USkillcheckWidget>          DefaultWaveSkillcheck;                             // 0x00E8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   PlayerIdentificationColors;                        // 0x00F0(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class USettingsObject>>    PlayerSettings;                                    // 0x0100(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<struct FSoftObjectPath, TSoftObjectPtr<class UTexture2D>> LoadingScreens;                                    // 0x0110(0x0050)(Edit, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UAchievementObject>> AchivementObjects;                                 // 0x0160(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class ULocalizedProjectSettingsObject> Localized;                                         // 0x0170(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeadTutorialCharacterDuration;                     // 0x0178(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAgendasAssigned;                                // 0x017C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinAgendasAssigned;                                // 0x0180(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UAgendaObject>>      Agendas;                                           // 0x0188(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        BackfillLevel;                                     // 0x0198(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        StartingLevel;                                     // 0x01B0(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FSoftObjectPath, float>           IntermediateLevels;                                // 0x01C8(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	float                                         LevelVotingPostSelectionCountdown;                 // 0x0218(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LevelVotingTimeoutDuration;                        // 0x021C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LevelVoteOptionsCount;                             // 0x0220(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x7];                                      // 0x0221(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        ShowdownLevel;                                     // 0x0228(0x0018)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPlayerStateEvent>          OnPlayerJoinedEvent;                               // 0x0240(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPlayerStateEvent>          OnPlayerLeftEvent;                                 // 0x0248(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCharacterSCTEvent>         OnCharacterGrantedEvent;                           // 0x0250(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           PushToTalkPressed;                                 // 0x0258(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAkAudioEvent>           PushToTalkReleased;                                // 0x0280(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCustomGameSettings                    DefaultCustomGameSettings;                         // 0x02A8(0x0034)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CustomGameMinimumPlayerCount;                      // 0x02DC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            UsingPowerEffect;                                  // 0x02E0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            SilenceEffect;                                     // 0x02E8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            DownedEffect;                                      // 0x02F0(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            TransitioningEffect;                               // 0x02F8(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            ImmovableEffect;                                   // 0x0300(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            LockCameraEffect;                                  // 0x0308(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UInputKeyOverrides>      KeyStringOverrides;                                // 0x0310(0x0028)(Edit, Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            ImmunityEffect;                                    // 0x0338(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, TSubclassOf<class UPower>> GivePowerTypes;                                    // 0x0340(0x0050)(Edit, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FString, TSubclassOf<class AActor>> SpawnableItems;                                    // 0x0390(0x0050)(Edit, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TMap<class FString, struct FSoftObjectPath>   OpenLevelLookup;                                   // 0x03E0(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UPower>>             CheatPowers;                                       // 0x0430(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class UGameplayEffect>            SetOxygenEffect;                                   // 0x0440(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EAgendaObjectState, struct FSlateColor>  AgendaProgressionColors;                           // 0x0448(0x0050)(Edit, Config, NativeAccessSpecifierPublic)
	bool                                          bEnableGamepadRebinding;                           // 0x0498(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_499[0x7];                                      // 0x0499(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static int32 GetCustomGameMinimumPlayerCount();
	static struct FCustomGameSettings GetDefaultCustomGameSettings();
	static bool GetIsGamepadRebindingEnabled();
	static TArray<TSubclassOf<class USettingsObject>> GetUserSettingsObjects();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTSettings">();
	}
	static class UFCTSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTSettings>();
	}
};
static_assert(alignof(UFCTSettings) == 0x000008, "Wrong alignment on UFCTSettings");
static_assert(sizeof(UFCTSettings) == 0x0004A0, "Wrong size on UFCTSettings");
static_assert(offsetof(UFCTSettings, ProjectChangelist) == 0x000028, "Member 'UFCTSettings::ProjectChangelist' has a wrong offset!");
static_assert(offsetof(UFCTSettings, GlobalCooldownDuration) == 0x00002C, "Member 'UFCTSettings::GlobalCooldownDuration' has a wrong offset!");
static_assert(offsetof(UFCTSettings, OxygenGrantedPostTravel) == 0x000030, "Member 'UFCTSettings::OxygenGrantedPostTravel' has a wrong offset!");
static_assert(offsetof(UFCTSettings, PopUpClass) == 0x000038, "Member 'UFCTSettings::PopUpClass' has a wrong offset!");
static_assert(offsetof(UFCTSettings, ScoreDataTable) == 0x000040, "Member 'UFCTSettings::ScoreDataTable' has a wrong offset!");
static_assert(offsetof(UFCTSettings, DeadCharacterType) == 0x000068, "Member 'UFCTSettings::DeadCharacterType' has a wrong offset!");
static_assert(offsetof(UFCTSettings, OnAnyVoteChanged) == 0x000070, "Member 'UFCTSettings::OnAnyVoteChanged' has a wrong offset!");
static_assert(offsetof(UFCTSettings, ContextUIOrder) == 0x000098, "Member 'UFCTSettings::ContextUIOrder' has a wrong offset!");
static_assert(offsetof(UFCTSettings, LoadingScreenWidgetType) == 0x0000A8, "Member 'UFCTSettings::LoadingScreenWidgetType' has a wrong offset!");
static_assert(offsetof(UFCTSettings, FallbackLoadingScreen) == 0x0000B0, "Member 'UFCTSettings::FallbackLoadingScreen' has a wrong offset!");
static_assert(offsetof(UFCTSettings, DefaultProgressBar) == 0x0000D8, "Member 'UFCTSettings::DefaultProgressBar' has a wrong offset!");
static_assert(offsetof(UFCTSettings, DefaultInfiniteSkillcheck) == 0x0000E0, "Member 'UFCTSettings::DefaultInfiniteSkillcheck' has a wrong offset!");
static_assert(offsetof(UFCTSettings, DefaultWaveSkillcheck) == 0x0000E8, "Member 'UFCTSettings::DefaultWaveSkillcheck' has a wrong offset!");
static_assert(offsetof(UFCTSettings, PlayerIdentificationColors) == 0x0000F0, "Member 'UFCTSettings::PlayerIdentificationColors' has a wrong offset!");
static_assert(offsetof(UFCTSettings, PlayerSettings) == 0x000100, "Member 'UFCTSettings::PlayerSettings' has a wrong offset!");
static_assert(offsetof(UFCTSettings, LoadingScreens) == 0x000110, "Member 'UFCTSettings::LoadingScreens' has a wrong offset!");
static_assert(offsetof(UFCTSettings, AchivementObjects) == 0x000160, "Member 'UFCTSettings::AchivementObjects' has a wrong offset!");
static_assert(offsetof(UFCTSettings, Localized) == 0x000170, "Member 'UFCTSettings::Localized' has a wrong offset!");
static_assert(offsetof(UFCTSettings, DeadTutorialCharacterDuration) == 0x000178, "Member 'UFCTSettings::DeadTutorialCharacterDuration' has a wrong offset!");
static_assert(offsetof(UFCTSettings, MaxAgendasAssigned) == 0x00017C, "Member 'UFCTSettings::MaxAgendasAssigned' has a wrong offset!");
static_assert(offsetof(UFCTSettings, MinAgendasAssigned) == 0x000180, "Member 'UFCTSettings::MinAgendasAssigned' has a wrong offset!");
static_assert(offsetof(UFCTSettings, Agendas) == 0x000188, "Member 'UFCTSettings::Agendas' has a wrong offset!");
static_assert(offsetof(UFCTSettings, BackfillLevel) == 0x000198, "Member 'UFCTSettings::BackfillLevel' has a wrong offset!");
static_assert(offsetof(UFCTSettings, StartingLevel) == 0x0001B0, "Member 'UFCTSettings::StartingLevel' has a wrong offset!");
static_assert(offsetof(UFCTSettings, IntermediateLevels) == 0x0001C8, "Member 'UFCTSettings::IntermediateLevels' has a wrong offset!");
static_assert(offsetof(UFCTSettings, LevelVotingPostSelectionCountdown) == 0x000218, "Member 'UFCTSettings::LevelVotingPostSelectionCountdown' has a wrong offset!");
static_assert(offsetof(UFCTSettings, LevelVotingTimeoutDuration) == 0x00021C, "Member 'UFCTSettings::LevelVotingTimeoutDuration' has a wrong offset!");
static_assert(offsetof(UFCTSettings, LevelVoteOptionsCount) == 0x000220, "Member 'UFCTSettings::LevelVoteOptionsCount' has a wrong offset!");
static_assert(offsetof(UFCTSettings, ShowdownLevel) == 0x000228, "Member 'UFCTSettings::ShowdownLevel' has a wrong offset!");
static_assert(offsetof(UFCTSettings, OnPlayerJoinedEvent) == 0x000240, "Member 'UFCTSettings::OnPlayerJoinedEvent' has a wrong offset!");
static_assert(offsetof(UFCTSettings, OnPlayerLeftEvent) == 0x000248, "Member 'UFCTSettings::OnPlayerLeftEvent' has a wrong offset!");
static_assert(offsetof(UFCTSettings, OnCharacterGrantedEvent) == 0x000250, "Member 'UFCTSettings::OnCharacterGrantedEvent' has a wrong offset!");
static_assert(offsetof(UFCTSettings, PushToTalkPressed) == 0x000258, "Member 'UFCTSettings::PushToTalkPressed' has a wrong offset!");
static_assert(offsetof(UFCTSettings, PushToTalkReleased) == 0x000280, "Member 'UFCTSettings::PushToTalkReleased' has a wrong offset!");
static_assert(offsetof(UFCTSettings, DefaultCustomGameSettings) == 0x0002A8, "Member 'UFCTSettings::DefaultCustomGameSettings' has a wrong offset!");
static_assert(offsetof(UFCTSettings, CustomGameMinimumPlayerCount) == 0x0002DC, "Member 'UFCTSettings::CustomGameMinimumPlayerCount' has a wrong offset!");
static_assert(offsetof(UFCTSettings, UsingPowerEffect) == 0x0002E0, "Member 'UFCTSettings::UsingPowerEffect' has a wrong offset!");
static_assert(offsetof(UFCTSettings, SilenceEffect) == 0x0002E8, "Member 'UFCTSettings::SilenceEffect' has a wrong offset!");
static_assert(offsetof(UFCTSettings, DownedEffect) == 0x0002F0, "Member 'UFCTSettings::DownedEffect' has a wrong offset!");
static_assert(offsetof(UFCTSettings, TransitioningEffect) == 0x0002F8, "Member 'UFCTSettings::TransitioningEffect' has a wrong offset!");
static_assert(offsetof(UFCTSettings, ImmovableEffect) == 0x000300, "Member 'UFCTSettings::ImmovableEffect' has a wrong offset!");
static_assert(offsetof(UFCTSettings, LockCameraEffect) == 0x000308, "Member 'UFCTSettings::LockCameraEffect' has a wrong offset!");
static_assert(offsetof(UFCTSettings, KeyStringOverrides) == 0x000310, "Member 'UFCTSettings::KeyStringOverrides' has a wrong offset!");
static_assert(offsetof(UFCTSettings, ImmunityEffect) == 0x000338, "Member 'UFCTSettings::ImmunityEffect' has a wrong offset!");
static_assert(offsetof(UFCTSettings, GivePowerTypes) == 0x000340, "Member 'UFCTSettings::GivePowerTypes' has a wrong offset!");
static_assert(offsetof(UFCTSettings, SpawnableItems) == 0x000390, "Member 'UFCTSettings::SpawnableItems' has a wrong offset!");
static_assert(offsetof(UFCTSettings, OpenLevelLookup) == 0x0003E0, "Member 'UFCTSettings::OpenLevelLookup' has a wrong offset!");
static_assert(offsetof(UFCTSettings, CheatPowers) == 0x000430, "Member 'UFCTSettings::CheatPowers' has a wrong offset!");
static_assert(offsetof(UFCTSettings, SetOxygenEffect) == 0x000440, "Member 'UFCTSettings::SetOxygenEffect' has a wrong offset!");
static_assert(offsetof(UFCTSettings, AgendaProgressionColors) == 0x000448, "Member 'UFCTSettings::AgendaProgressionColors' has a wrong offset!");
static_assert(offsetof(UFCTSettings, bEnableGamepadRebinding) == 0x000498, "Member 'UFCTSettings::bEnableGamepadRebinding' has a wrong offset!");

// Class SCT.FCTUserReportUtilitiesLibrary
// 0x0000 (0x0028 - 0x0028)
class UFCTUserReportUtilitiesLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TMap<class FString, class FString> GetMostRelevantUserBanData(bool* OutHasActiveBan, const TArray<struct FFCTUserBan>& Bans);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTUserReportUtilitiesLibrary">();
	}
	static class UFCTUserReportUtilitiesLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTUserReportUtilitiesLibrary>();
	}
};
static_assert(alignof(UFCTUserReportUtilitiesLibrary) == 0x000008, "Wrong alignment on UFCTUserReportUtilitiesLibrary");
static_assert(sizeof(UFCTUserReportUtilitiesLibrary) == 0x000028, "Wrong size on UFCTUserReportUtilitiesLibrary");

// Class SCT.SubMenuSelectionButtonUserWidget
// 0x0028 (0x0288 - 0x0260)
class USubMenuSelectionButtonUserWidget : public UUserWidget
{
public:
	class UButton*                                GamepadButton;                                     // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextBlock*                             TitleText;                                         // 0x0268(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void()>                             OnButtonPressed;                                   // 0x0274(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPressed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubMenuSelectionButtonUserWidget">();
	}
	static class USubMenuSelectionButtonUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubMenuSelectionButtonUserWidget>();
	}
};
static_assert(alignof(USubMenuSelectionButtonUserWidget) == 0x000008, "Wrong alignment on USubMenuSelectionButtonUserWidget");
static_assert(sizeof(USubMenuSelectionButtonUserWidget) == 0x000288, "Wrong size on USubMenuSelectionButtonUserWidget");
static_assert(offsetof(USubMenuSelectionButtonUserWidget, GamepadButton) == 0x000260, "Member 'USubMenuSelectionButtonUserWidget::GamepadButton' has a wrong offset!");
static_assert(offsetof(USubMenuSelectionButtonUserWidget, TitleText) == 0x000268, "Member 'USubMenuSelectionButtonUserWidget::TitleText' has a wrong offset!");
static_assert(offsetof(USubMenuSelectionButtonUserWidget, Height) == 0x000270, "Member 'USubMenuSelectionButtonUserWidget::Height' has a wrong offset!");
static_assert(offsetof(USubMenuSelectionButtonUserWidget, OnButtonPressed) == 0x000274, "Member 'USubMenuSelectionButtonUserWidget::OnButtonPressed' has a wrong offset!");

// Class SCT.SendUserReportCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class USendUserReportCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class USendUserReportCallbackProxy* ReportUser(const class FString& UserId, const class FString& DisplayName, const class FString& Reportedby_userid, const class FString& Reason, const class FString& Description, const class FString& SessionID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SendUserReportCallbackProxy">();
	}
	static class USendUserReportCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USendUserReportCallbackProxy>();
	}
};
static_assert(alignof(USendUserReportCallbackProxy) == 0x000008, "Wrong alignment on USendUserReportCallbackProxy");
static_assert(sizeof(USendUserReportCallbackProxy) == 0x000050, "Wrong size on USendUserReportCallbackProxy");
static_assert(offsetof(USendUserReportCallbackProxy, OnSuccess) == 0x000030, "Member 'USendUserReportCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(USendUserReportCallbackProxy, OnError) == 0x000040, "Member 'USendUserReportCallbackProxy::OnError' has a wrong offset!");

// Class SCT.GetUserBansCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UGetUserBansCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UGetUserBansCallbackProxy* GetUserBans();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetUserBansCallbackProxy">();
	}
	static class UGetUserBansCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetUserBansCallbackProxy>();
	}
};
static_assert(alignof(UGetUserBansCallbackProxy) == 0x000008, "Wrong alignment on UGetUserBansCallbackProxy");
static_assert(sizeof(UGetUserBansCallbackProxy) == 0x000050, "Wrong size on UGetUserBansCallbackProxy");
static_assert(offsetof(UGetUserBansCallbackProxy, OnSuccess) == 0x000030, "Member 'UGetUserBansCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UGetUserBansCallbackProxy, OnError) == 0x000040, "Member 'UGetUserBansCallbackProxy::OnError' has a wrong offset!");

// Class SCT.GetUserBanByIdCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UGetUserBanByIdCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UGetUserBanByIdCallbackProxy* GetUserBanByBanId(const class FString& BanId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetUserBanByIdCallbackProxy">();
	}
	static class UGetUserBanByIdCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetUserBanByIdCallbackProxy>();
	}
};
static_assert(alignof(UGetUserBanByIdCallbackProxy) == 0x000008, "Wrong alignment on UGetUserBanByIdCallbackProxy");
static_assert(sizeof(UGetUserBanByIdCallbackProxy) == 0x000050, "Wrong size on UGetUserBanByIdCallbackProxy");
static_assert(offsetof(UGetUserBanByIdCallbackProxy, OnSuccess) == 0x000030, "Member 'UGetUserBanByIdCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UGetUserBanByIdCallbackProxy, OnError) == 0x000040, "Member 'UGetUserBanByIdCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTUserSettings
// 0x0048 (0x0070 - 0x0028)
class UFCTUserSettings final : public UObject
{
public:
	bool                                          bDisableAirlock;                                   // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableIntroSequence;                             // 0x0029(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableAbilityAutoRelease;                        // 0x002A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableTransitionToGame;                          // 0x002B(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutomaticallyEnableImmunityFromDeathTimers;       // 0x002C(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class ACharacterSCT>              CharacterTypeOverride;                             // 0x0030(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UseDebugSteamIDs;                                  // 0x0038(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableEndConditions;                             // 0x0039(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCustomUserSettings;                         // 0x003A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x1];                                       // 0x003B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomGameSettings                    CustomUserSettings;                                // 0x003C(0x0034)(Edit, Config, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTUserSettings">();
	}
	static class UFCTUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTUserSettings>();
	}
};
static_assert(alignof(UFCTUserSettings) == 0x000008, "Wrong alignment on UFCTUserSettings");
static_assert(sizeof(UFCTUserSettings) == 0x000070, "Wrong size on UFCTUserSettings");
static_assert(offsetof(UFCTUserSettings, bDisableAirlock) == 0x000028, "Member 'UFCTUserSettings::bDisableAirlock' has a wrong offset!");
static_assert(offsetof(UFCTUserSettings, bDisableIntroSequence) == 0x000029, "Member 'UFCTUserSettings::bDisableIntroSequence' has a wrong offset!");
static_assert(offsetof(UFCTUserSettings, bDisableAbilityAutoRelease) == 0x00002A, "Member 'UFCTUserSettings::bDisableAbilityAutoRelease' has a wrong offset!");
static_assert(offsetof(UFCTUserSettings, bDisableTransitionToGame) == 0x00002B, "Member 'UFCTUserSettings::bDisableTransitionToGame' has a wrong offset!");
static_assert(offsetof(UFCTUserSettings, bAutomaticallyEnableImmunityFromDeathTimers) == 0x00002C, "Member 'UFCTUserSettings::bAutomaticallyEnableImmunityFromDeathTimers' has a wrong offset!");
static_assert(offsetof(UFCTUserSettings, CharacterTypeOverride) == 0x000030, "Member 'UFCTUserSettings::CharacterTypeOverride' has a wrong offset!");
static_assert(offsetof(UFCTUserSettings, UseDebugSteamIDs) == 0x000038, "Member 'UFCTUserSettings::UseDebugSteamIDs' has a wrong offset!");
static_assert(offsetof(UFCTUserSettings, bDisableEndConditions) == 0x000039, "Member 'UFCTUserSettings::bDisableEndConditions' has a wrong offset!");
static_assert(offsetof(UFCTUserSettings, bEnableCustomUserSettings) == 0x00003A, "Member 'UFCTUserSettings::bEnableCustomUserSettings' has a wrong offset!");
static_assert(offsetof(UFCTUserSettings, CustomUserSettings) == 0x00003C, "Member 'UFCTUserSettings::CustomUserSettings' has a wrong offset!");

// Class SCT.FinishedLevelChangeEvent
// 0x0000 (0x0040 - 0x0040)
class UFinishedLevelChangeEvent final : public UGlobalEventVoid
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FinishedLevelChangeEvent">();
	}
	static class UFinishedLevelChangeEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFinishedLevelChangeEvent>();
	}
};
static_assert(alignof(UFinishedLevelChangeEvent) == 0x000008, "Wrong alignment on UFinishedLevelChangeEvent");
static_assert(sizeof(UFinishedLevelChangeEvent) == 0x000040, "Wrong size on UFinishedLevelChangeEvent");

// Class SCT.FireExtinguisher
// 0x0008 (0x0448 - 0x0440)
class UFireExtinguisher : public UItem
{
public:
	float                                         CurrentAmmo;                                       // 0x0440(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCurrentAmmo(float NewAmmo);

	float GetCurrentAmmo() const;
	float GetMaximumAmmo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireExtinguisher">();
	}
	static class UFireExtinguisher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireExtinguisher>();
	}
};
static_assert(alignof(UFireExtinguisher) == 0x000008, "Wrong alignment on UFireExtinguisher");
static_assert(sizeof(UFireExtinguisher) == 0x000448, "Wrong size on UFireExtinguisher");
static_assert(offsetof(UFireExtinguisher, CurrentAmmo) == 0x000440, "Member 'UFireExtinguisher::CurrentAmmo' has a wrong offset!");

// Class SCT.FireExtinguisherData
// 0x0008 (0x0110 - 0x0108)
class UFireExtinguisherData final : public UItemData
{
public:
	float                                         MaxAmmo;                                           // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FireExtinguisherData">();
	}
	static class UFireExtinguisherData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFireExtinguisherData>();
	}
};
static_assert(alignof(UFireExtinguisherData) == 0x000008, "Wrong alignment on UFireExtinguisherData");
static_assert(sizeof(UFireExtinguisherData) == 0x000110, "Wrong size on UFireExtinguisherData");
static_assert(offsetof(UFireExtinguisherData, MaxAmmo) == 0x000108, "Member 'UFireExtinguisherData::MaxAmmo' has a wrong offset!");

// Class SCT.ForceInteractionCheat
// 0x0000 (0x0440 - 0x0440)
class UForceInteractionCheat : public UContextSkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceInteractionCheat">();
	}
	static class UForceInteractionCheat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceInteractionCheat>();
	}
};
static_assert(alignof(UForceInteractionCheat) == 0x000008, "Wrong alignment on UForceInteractionCheat");
static_assert(sizeof(UForceInteractionCheat) == 0x000440, "Wrong size on UForceInteractionCheat");

// Class SCT.TransitionDataEntry
// 0x0000 (0x0030 - 0x0030)
class UTransitionDataEntry final : public UPrimaryDataAsset
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransitionDataEntry">();
	}
	static class UTransitionDataEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTransitionDataEntry>();
	}
};
static_assert(alignof(UTransitionDataEntry) == 0x000008, "Wrong alignment on UTransitionDataEntry");
static_assert(sizeof(UTransitionDataEntry) == 0x000030, "Wrong size on UTransitionDataEntry");

// Class SCT.ForceKillCheat
// 0x0000 (0x0440 - 0x0440)
class UForceKillCheat : public UContextSkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ForceKillCheat">();
	}
	static class UForceKillCheat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UForceKillCheat>();
	}
};
static_assert(alignof(UForceKillCheat) == 0x000008, "Wrong alignment on UForceKillCheat");
static_assert(sizeof(UForceKillCheat) == 0x000440, "Wrong size on UForceKillCheat");

// Class SCT.GameHasEndedGlobalEvent
// 0x0000 (0x0040 - 0x0040)
class UGameHasEndedGlobalEvent final : public UGlobalEventVoid
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameHasEndedGlobalEvent">();
	}
	static class UGameHasEndedGlobalEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameHasEndedGlobalEvent>();
	}
};
static_assert(alignof(UGameHasEndedGlobalEvent) == 0x000008, "Wrong alignment on UGameHasEndedGlobalEvent");
static_assert(sizeof(UGameHasEndedGlobalEvent) == 0x000040, "Wrong size on UGameHasEndedGlobalEvent");

// Class SCT.SteamFriendsLobbyUserWidget
// 0x0000 (0x0260 - 0x0260)
class USteamFriendsLobbyUserWidget final : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamFriendsLobbyUserWidget">();
	}
	static class USteamFriendsLobbyUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamFriendsLobbyUserWidget>();
	}
};
static_assert(alignof(USteamFriendsLobbyUserWidget) == 0x000008, "Wrong alignment on USteamFriendsLobbyUserWidget");
static_assert(sizeof(USteamFriendsLobbyUserWidget) == 0x000260, "Wrong size on USteamFriendsLobbyUserWidget");

// Class SCT.GameplayAbilitySCT
// 0x0000 (0x03B0 - 0x03B0)
class UGameplayAbilitySCT final : public UGameplayAbility
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbilitySCT">();
	}
	static class UGameplayAbilitySCT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbilitySCT>();
	}
};
static_assert(alignof(UGameplayAbilitySCT) == 0x000008, "Wrong alignment on UGameplayAbilitySCT");
static_assert(sizeof(UGameplayAbilitySCT) == 0x0003B0, "Wrong size on UGameplayAbilitySCT");

// Class SCT.NextLevelExpCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UNextLevelExpCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UNextLevelExpCallbackProxy* RequestNextLevelExpRequired();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NextLevelExpCallbackProxy">();
	}
	static class UNextLevelExpCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNextLevelExpCallbackProxy>();
	}
};
static_assert(alignof(UNextLevelExpCallbackProxy) == 0x000008, "Wrong alignment on UNextLevelExpCallbackProxy");
static_assert(sizeof(UNextLevelExpCallbackProxy) == 0x000050, "Wrong size on UNextLevelExpCallbackProxy");
static_assert(offsetof(UNextLevelExpCallbackProxy, OnSuccess) == 0x000030, "Member 'UNextLevelExpCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UNextLevelExpCallbackProxy, OnError) == 0x000040, "Member 'UNextLevelExpCallbackProxy::OnError' has a wrong offset!");

// Class SCT.Syringe
// 0x0000 (0x0440 - 0x0440)
class USyringe final : public UItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Syringe">();
	}
	static class USyringe* GetDefaultObj()
	{
		return GetDefaultObjImpl<USyringe>();
	}
};
static_assert(alignof(USyringe) == 0x000008, "Wrong alignment on USyringe");
static_assert(sizeof(USyringe) == 0x000440, "Wrong size on USyringe");

// Class SCT.GamesightGIS
// 0x0010 (0x0040 - 0x0030)
class UGamesightGIS final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GameLaunch();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GamesightGIS">();
	}
	static class UGamesightGIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGamesightGIS>();
	}
};
static_assert(alignof(UGamesightGIS) == 0x000008, "Wrong alignment on UGamesightGIS");
static_assert(sizeof(UGamesightGIS) == 0x000040, "Wrong size on UGamesightGIS");

// Class SCT.GenericInteractionSkill
// 0x0000 (0x0440 - 0x0440)
class UGenericInteractionSkill : public UContextSkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GenericInteractionSkill">();
	}
	static class UGenericInteractionSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGenericInteractionSkill>();
	}
};
static_assert(alignof(UGenericInteractionSkill) == 0x000008, "Wrong alignment on UGenericInteractionSkill");
static_assert(sizeof(UGenericInteractionSkill) == 0x000440, "Wrong size on UGenericInteractionSkill");

// Class SCT.GlobalEventBool
// 0x0010 (0x0040 - 0x0030)
class UGlobalEventBool : public UGlobalEvent
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Broadcast(bool Value) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalEventBool">();
	}
	static class UGlobalEventBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalEventBool>();
	}
};
static_assert(alignof(UGlobalEventBool) == 0x000008, "Wrong alignment on UGlobalEventBool");
static_assert(sizeof(UGlobalEventBool) == 0x000040, "Wrong size on UGlobalEventBool");
static_assert(offsetof(UGlobalEventBool, Event) == 0x000030, "Member 'UGlobalEventBool::Event' has a wrong offset!");

// Class SCT.GlobalEventFloat
// 0x0010 (0x0040 - 0x0030)
class UGlobalEventFloat : public UGlobalEvent
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Broadcast(float Value) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalEventFloat">();
	}
	static class UGlobalEventFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalEventFloat>();
	}
};
static_assert(alignof(UGlobalEventFloat) == 0x000008, "Wrong alignment on UGlobalEventFloat");
static_assert(sizeof(UGlobalEventFloat) == 0x000040, "Wrong size on UGlobalEventFloat");
static_assert(offsetof(UGlobalEventFloat, Event) == 0x000030, "Member 'UGlobalEventFloat::Event' has a wrong offset!");

// Class SCT.GlobalEventLinearColor
// 0x0010 (0x0040 - 0x0030)
class UGlobalEventLinearColor final : public UGlobalEvent
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Broadcast(const struct FLinearColor& Value) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalEventLinearColor">();
	}
	static class UGlobalEventLinearColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalEventLinearColor>();
	}
};
static_assert(alignof(UGlobalEventLinearColor) == 0x000008, "Wrong alignment on UGlobalEventLinearColor");
static_assert(sizeof(UGlobalEventLinearColor) == 0x000040, "Wrong size on UGlobalEventLinearColor");
static_assert(offsetof(UGlobalEventLinearColor, Event) == 0x000030, "Member 'UGlobalEventLinearColor::Event' has a wrong offset!");

// Class SCT.GlobalObjectContainer
// 0x0050 (0x0078 - 0x0028)
class UGlobalObjectContainer final : public UObject
{
public:
	TMap<TSubclassOf<class UObject>, class UObject*> GlobalObjects;                                     // 0x0028(0x0050)(Transient, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalObjectContainer">();
	}
	static class UGlobalObjectContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalObjectContainer>();
	}
};
static_assert(alignof(UGlobalObjectContainer) == 0x000008, "Wrong alignment on UGlobalObjectContainer");
static_assert(sizeof(UGlobalObjectContainer) == 0x000078, "Wrong size on UGlobalObjectContainer");
static_assert(offsetof(UGlobalObjectContainer, GlobalObjects) == 0x000028, "Member 'UGlobalObjectContainer::GlobalObjects' has a wrong offset!");

// Class SCT.GlobalVariableLinearColor
// 0x0010 (0x0038 - 0x0028)
class UGlobalVariableLinearColor final : public UObject
{
public:
	struct FLinearColor                           Value;                                             // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GlobalVariableLinearColor">();
	}
	static class UGlobalVariableLinearColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGlobalVariableLinearColor>();
	}
};
static_assert(alignof(UGlobalVariableLinearColor) == 0x000008, "Wrong alignment on UGlobalVariableLinearColor");
static_assert(sizeof(UGlobalVariableLinearColor) == 0x000038, "Wrong size on UGlobalVariableLinearColor");
static_assert(offsetof(UGlobalVariableLinearColor, Value) == 0x000028, "Member 'UGlobalVariableLinearColor::Value' has a wrong offset!");

// Class SCT.HealthAttributeSet
// 0x0020 (0x0050 - 0x0030)
class UHealthAttributeSet final : public UAttributeSet
{
public:
	struct FGameplayAttributeData                 Health;                                            // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealth;                                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_Health();
	void OnRep_MaxHealth();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthAttributeSet">();
	}
	static class UHealthAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthAttributeSet>();
	}
};
static_assert(alignof(UHealthAttributeSet) == 0x000008, "Wrong alignment on UHealthAttributeSet");
static_assert(sizeof(UHealthAttributeSet) == 0x000050, "Wrong size on UHealthAttributeSet");
static_assert(offsetof(UHealthAttributeSet, Health) == 0x000030, "Member 'UHealthAttributeSet::Health' has a wrong offset!");
static_assert(offsetof(UHealthAttributeSet, MaxHealth) == 0x000040, "Member 'UHealthAttributeSet::MaxHealth' has a wrong offset!");

// Class SCT.HumanoidCharacter
// 0x0070 (0x0600 - 0x0590)
class AHumanoidCharacter : public ACharacterSCT
{
public:
	bool                                          bIsPersonoid;                                      // 0x0590(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_591[0x7];                                      // 0x0591(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UWetnessAttributeSet*                   WetnessAttributeSet;                               // 0x0598(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UPower>>             PersonoidOnlyStartupPowers;                        // 0x05A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UPower>>             ResidentOnlyStartupPowers;                         // 0x05B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UCharacterOxygenStateManager*           OxygenStateManager;                                // 0x05C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDestiny;                                         // 0x05C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsAlive;                                          // 0x05D8(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D9[0x3];                                      // 0x05D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UIWheelDisableRotationDuration;                    // 0x05DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E0[0x8];                                      // 0x05E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UGameplayEffect>            PersonoidGE;                                       // 0x05E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UGameplayEffect>            ResidentGE;                                        // 0x05F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x8];                                      // 0x05F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClosePuzzleMenu();
	void K2_InitializePersonoid();
	void K2_InitializeResident();
	void K2_OnDestiny(const struct FDestiny& Destiny);
	void K2_OnWetnessChanged(float Wetness);
	void Kill(const struct FDestiny& Destiny);
	void OnWetnessChanged(float Wetness);
	void OpenPuzzleMenu();
	void ToggleCrouch();
	void ToggleThumbVoteMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HumanoidCharacter">();
	}
	static class AHumanoidCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHumanoidCharacter>();
	}
};
static_assert(alignof(AHumanoidCharacter) == 0x000010, "Wrong alignment on AHumanoidCharacter");
static_assert(sizeof(AHumanoidCharacter) == 0x000600, "Wrong size on AHumanoidCharacter");
static_assert(offsetof(AHumanoidCharacter, bIsPersonoid) == 0x000590, "Member 'AHumanoidCharacter::bIsPersonoid' has a wrong offset!");
static_assert(offsetof(AHumanoidCharacter, WetnessAttributeSet) == 0x000598, "Member 'AHumanoidCharacter::WetnessAttributeSet' has a wrong offset!");
static_assert(offsetof(AHumanoidCharacter, PersonoidOnlyStartupPowers) == 0x0005A0, "Member 'AHumanoidCharacter::PersonoidOnlyStartupPowers' has a wrong offset!");
static_assert(offsetof(AHumanoidCharacter, ResidentOnlyStartupPowers) == 0x0005B0, "Member 'AHumanoidCharacter::ResidentOnlyStartupPowers' has a wrong offset!");
static_assert(offsetof(AHumanoidCharacter, OxygenStateManager) == 0x0005C0, "Member 'AHumanoidCharacter::OxygenStateManager' has a wrong offset!");
static_assert(offsetof(AHumanoidCharacter, OnDestiny) == 0x0005C8, "Member 'AHumanoidCharacter::OnDestiny' has a wrong offset!");
static_assert(offsetof(AHumanoidCharacter, bIsAlive) == 0x0005D8, "Member 'AHumanoidCharacter::bIsAlive' has a wrong offset!");
static_assert(offsetof(AHumanoidCharacter, UIWheelDisableRotationDuration) == 0x0005DC, "Member 'AHumanoidCharacter::UIWheelDisableRotationDuration' has a wrong offset!");
static_assert(offsetof(AHumanoidCharacter, PersonoidGE) == 0x0005E8, "Member 'AHumanoidCharacter::PersonoidGE' has a wrong offset!");
static_assert(offsetof(AHumanoidCharacter, ResidentGE) == 0x0005F0, "Member 'AHumanoidCharacter::ResidentGE' has a wrong offset!");

// Class SCT.IdentificationColorGlobalEvent
// 0x0010 (0x0040 - 0x0030)
class UIdentificationColorGlobalEvent final : public UGlobalEvent
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Broadcast(class APlayerState* PlayerState, const struct FLinearColor& Value) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IdentificationColorGlobalEvent">();
	}
	static class UIdentificationColorGlobalEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIdentificationColorGlobalEvent>();
	}
};
static_assert(alignof(UIdentificationColorGlobalEvent) == 0x000008, "Wrong alignment on UIdentificationColorGlobalEvent");
static_assert(sizeof(UIdentificationColorGlobalEvent) == 0x000040, "Wrong size on UIdentificationColorGlobalEvent");
static_assert(offsetof(UIdentificationColorGlobalEvent, Event) == 0x000030, "Member 'UIdentificationColorGlobalEvent::Event' has a wrong offset!");

// Class SCT.IdentificationColorGlobalVariable
// 0x0050 (0x0078 - 0x0028)
class UIdentificationColorGlobalVariable final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetColor(class APlayerState* PlayerState, const struct FLinearColor& Color);

	struct FLinearColor GetColor(class APlayerState* PlayerState) const;
	struct FLinearColor GetColorFromID(int32 PlayerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IdentificationColorGlobalVariable">();
	}
	static class UIdentificationColorGlobalVariable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIdentificationColorGlobalVariable>();
	}
};
static_assert(alignof(UIdentificationColorGlobalVariable) == 0x000008, "Wrong alignment on UIdentificationColorGlobalVariable");
static_assert(sizeof(UIdentificationColorGlobalVariable) == 0x000078, "Wrong size on UIdentificationColorGlobalVariable");

// Class SCT.FCTCheckConsoleBansCallbackProxy
// 0x0090 (0x00C0 - 0x0030)
class UFCTCheckConsoleBansCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnAllowed;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlocked;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x60];                                      // 0x0060(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFCTCheckConsoleBansCallbackProxy* CheckConsoleBans(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTCheckConsoleBansCallbackProxy">();
	}
	static class UFCTCheckConsoleBansCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTCheckConsoleBansCallbackProxy>();
	}
};
static_assert(alignof(UFCTCheckConsoleBansCallbackProxy) == 0x000008, "Wrong alignment on UFCTCheckConsoleBansCallbackProxy");
static_assert(sizeof(UFCTCheckConsoleBansCallbackProxy) == 0x0000C0, "Wrong size on UFCTCheckConsoleBansCallbackProxy");
static_assert(offsetof(UFCTCheckConsoleBansCallbackProxy, OnAllowed) == 0x000030, "Member 'UFCTCheckConsoleBansCallbackProxy::OnAllowed' has a wrong offset!");
static_assert(offsetof(UFCTCheckConsoleBansCallbackProxy, OnBlocked) == 0x000040, "Member 'UFCTCheckConsoleBansCallbackProxy::OnBlocked' has a wrong offset!");
static_assert(offsetof(UFCTCheckConsoleBansCallbackProxy, OnError) == 0x000050, "Member 'UFCTCheckConsoleBansCallbackProxy::OnError' has a wrong offset!");

// Class SCT.RichTextInlineFormatDecorator
// 0x0000 (0x0028 - 0x0028)
class URichTextInlineFormatDecorator final : public URichTextBlockDecorator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextInlineFormatDecorator">();
	}
	static class URichTextInlineFormatDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextInlineFormatDecorator>();
	}
};
static_assert(alignof(URichTextInlineFormatDecorator) == 0x000008, "Wrong alignment on URichTextInlineFormatDecorator");
static_assert(sizeof(URichTextInlineFormatDecorator) == 0x000028, "Wrong size on URichTextInlineFormatDecorator");

// Class SCT.InputKeyOverrides
// 0x0050 (0x0080 - 0x0030)
class UInputKeyOverrides final : public UPrimaryDataAsset
{
public:
	TMap<struct FKey, class FText>                Overrides;                                         // 0x0030(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputKeyOverrides">();
	}
	static class UInputKeyOverrides* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputKeyOverrides>();
	}
};
static_assert(alignof(UInputKeyOverrides) == 0x000008, "Wrong alignment on UInputKeyOverrides");
static_assert(sizeof(UInputKeyOverrides) == 0x000080, "Wrong size on UInputKeyOverrides");
static_assert(offsetof(UInputKeyOverrides, Overrides) == 0x000030, "Member 'UInputKeyOverrides::Overrides' has a wrong offset!");

// Class SCT.InputSettingsSubComponent
// 0x0008 (0x0030 - 0x0028)
class UInputSettingsSubComponent : public UObject
{
public:
	class UUserInputSettings*                     InputSettings;                                     // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputSettingsSubComponent">();
	}
	static class UInputSettingsSubComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputSettingsSubComponent>();
	}
};
static_assert(alignof(UInputSettingsSubComponent) == 0x000008, "Wrong alignment on UInputSettingsSubComponent");
static_assert(sizeof(UInputSettingsSubComponent) == 0x000030, "Wrong size on UInputSettingsSubComponent");
static_assert(offsetof(UInputSettingsSubComponent, InputSettings) == 0x000028, "Member 'UInputSettingsSubComponent::InputSettings' has a wrong offset!");

// Class SCT.InputSettingsActionSubComponent
// 0x0000 (0x0030 - 0x0030)
class UInputSettingsActionSubComponent final : public UInputSettingsSubComponent
{
public:
	void SetGamepadAction(const class FName& SettingsName, const struct FInputChord& Chord);
	void SetKeyboardAction(const class FName& SettingsName, const struct FInputChord& Chord);

	struct FInputActionKeyMapping GetGamepadAction(const class FName& SettingsName) const;
	struct FInputActionKeyMapping GetKeyboardAction(const class FName& SettingsName) const;
	TArray<struct FInputInformation> GetRebindableActions() const;
	bool IsKeyBound(const class FName& Name_0, const struct FInputChord& Key) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputSettingsActionSubComponent">();
	}
	static class UInputSettingsActionSubComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputSettingsActionSubComponent>();
	}
};
static_assert(alignof(UInputSettingsActionSubComponent) == 0x000008, "Wrong alignment on UInputSettingsActionSubComponent");
static_assert(sizeof(UInputSettingsActionSubComponent) == 0x000030, "Wrong size on UInputSettingsActionSubComponent");

// Class SCT.SetCloudStringDataCallbackProxy
// 0x0010 (0x0090 - 0x0080)
class USetCloudStringDataCallbackProxy final : public USetCloudDataCallbackProxy
{
public:
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USetCloudStringDataCallbackProxy* SetCloudRecordValue(EUserRecordType UserRecord, const class FString& FieldName, const class FString& NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetCloudStringDataCallbackProxy">();
	}
	static class USetCloudStringDataCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetCloudStringDataCallbackProxy>();
	}
};
static_assert(alignof(USetCloudStringDataCallbackProxy) == 0x000008, "Wrong alignment on USetCloudStringDataCallbackProxy");
static_assert(sizeof(USetCloudStringDataCallbackProxy) == 0x000090, "Wrong size on USetCloudStringDataCallbackProxy");

// Class SCT.InputSettingsAxesSubComponent
// 0x0000 (0x0030 - 0x0030)
class UInputSettingsAxesSubComponent final : public UInputSettingsSubComponent
{
public:
	struct FInputInformationAxis GetInformation(const class FName& SettingsName);
	TArray<class FName> GetRebindableAxesKeys();
	void SetKeyboardAxis(const class FName& SettingsName, const struct FInputChord& Chord);

	struct FInputAxisKeyMapping GetKeyboardAxis(const class FName& SettingsName) const;
	bool IsKeyBound(const class FName& Name_0, const struct FInputChord& Key) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputSettingsAxesSubComponent">();
	}
	static class UInputSettingsAxesSubComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputSettingsAxesSubComponent>();
	}
};
static_assert(alignof(UInputSettingsAxesSubComponent) == 0x000008, "Wrong alignment on UInputSettingsAxesSubComponent");
static_assert(sizeof(UInputSettingsAxesSubComponent) == 0x000030, "Wrong size on UInputSettingsAxesSubComponent");

// Class SCT.InputSettingsToggleSubComponent
// 0x0000 (0x0030 - 0x0030)
class UInputSettingsToggleSubComponent final : public UInputSettingsSubComponent
{
public:
	TArray<class FName> GetRebindableToggleKeys();
	void SetToggle(const class FName& SettingsName, bool Value);

	struct FInputInformationToggle GetInformation(const class FName& SettingsName) const;
	bool GetToggle(const class FName& SettingsName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InputSettingsToggleSubComponent">();
	}
	static class UInputSettingsToggleSubComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInputSettingsToggleSubComponent>();
	}
};
static_assert(alignof(UInputSettingsToggleSubComponent) == 0x000008, "Wrong alignment on UInputSettingsToggleSubComponent");
static_assert(sizeof(UInputSettingsToggleSubComponent) == 0x000030, "Wrong size on UInputSettingsToggleSubComponent");

// Class SCT.SkillcheckController
// 0x0020 (0x00D0 - 0x00B0)
class USkillcheckController final : public UActorComponent
{
public:
	TSubclassOf<class UUserWidget>                WaitingForOtherPlayersWidgetType;                  // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkillcheckWidget*                      WidgetInstance;                                    // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            WaitingWidgetInstance;                             // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInteractionSkillcheckExtension*        Interaction;                                       // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ClientCancelSkillcheck();
	void ClientCreateSkillcheck(TSubclassOf<class USkillcheckWidget> WidgetType);
	void ClientCreateWaitForOthersWidget();
	void OnSkillcheckEnded();
	void ServerRegister(class ASkillcheckManager* Manager);
	void ServerUnregister(class ASkillcheckManager* Manager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillcheckController">();
	}
	static class USkillcheckController* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillcheckController>();
	}
};
static_assert(alignof(USkillcheckController) == 0x000008, "Wrong alignment on USkillcheckController");
static_assert(sizeof(USkillcheckController) == 0x0000D0, "Wrong size on USkillcheckController");
static_assert(offsetof(USkillcheckController, WaitingForOtherPlayersWidgetType) == 0x0000B0, "Member 'USkillcheckController::WaitingForOtherPlayersWidgetType' has a wrong offset!");
static_assert(offsetof(USkillcheckController, WidgetInstance) == 0x0000B8, "Member 'USkillcheckController::WidgetInstance' has a wrong offset!");
static_assert(offsetof(USkillcheckController, WaitingWidgetInstance) == 0x0000C0, "Member 'USkillcheckController::WaitingWidgetInstance' has a wrong offset!");
static_assert(offsetof(USkillcheckController, Interaction) == 0x0000C8, "Member 'USkillcheckController::Interaction' has a wrong offset!");

// Class SCT.InteractionComponentCosmeticBase
// 0x0010 (0x00C0 - 0x00B0)
class UInteractionComponentCosmeticBase : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x8];                                       // 0x00B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInteractionComponent*                  InteractionComponent;                              // 0x00B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UInteractionComponent* GetInteractionComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionComponentCosmeticBase">();
	}
	static class UInteractionComponentCosmeticBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionComponentCosmeticBase>();
	}
};
static_assert(alignof(UInteractionComponentCosmeticBase) == 0x000008, "Wrong alignment on UInteractionComponentCosmeticBase");
static_assert(sizeof(UInteractionComponentCosmeticBase) == 0x0000C0, "Wrong size on UInteractionComponentCosmeticBase");
static_assert(offsetof(UInteractionComponentCosmeticBase, InteractionComponent) == 0x0000B8, "Member 'UInteractionComponentCosmeticBase::InteractionComponent' has a wrong offset!");

// Class SCT.InteractionCoopDispatcher
// 0x0008 (0x00C8 - 0x00C0)
class UInteractionCoopDispatcher final : public UInteractionComponentCosmeticBase
{
public:
	class UInteractionCoopReceiver*               Receiver;                                          // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddReceiver(class UInteractionCoopReceiver* Receiver_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionCoopDispatcher">();
	}
	static class UInteractionCoopDispatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionCoopDispatcher>();
	}
};
static_assert(alignof(UInteractionCoopDispatcher) == 0x000008, "Wrong alignment on UInteractionCoopDispatcher");
static_assert(sizeof(UInteractionCoopDispatcher) == 0x0000C8, "Wrong size on UInteractionCoopDispatcher");
static_assert(offsetof(UInteractionCoopDispatcher, Receiver) == 0x0000C0, "Member 'UInteractionCoopDispatcher::Receiver' has a wrong offset!");

// Class SCT.XboxUserPrivilegeCheckTargetUserData
// 0x0030 (0x0058 - 0x0028)
class UXboxUserPrivilegeCheckTargetUserData final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XboxUserPrivilegeCheckTargetUserData">();
	}
	static class UXboxUserPrivilegeCheckTargetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXboxUserPrivilegeCheckTargetUserData>();
	}
};
static_assert(alignof(UXboxUserPrivilegeCheckTargetUserData) == 0x000008, "Wrong alignment on UXboxUserPrivilegeCheckTargetUserData");
static_assert(sizeof(UXboxUserPrivilegeCheckTargetUserData) == 0x000058, "Wrong size on UXboxUserPrivilegeCheckTargetUserData");

// Class SCT.InteractionCoopReceiver
// 0x0088 (0x0148 - 0x00C0)
class UInteractionCoopReceiver final : public UInteractionComponentCosmeticBase
{
public:
	FMulticastInlineDelegateProperty_             OnStateChanged;                                    // 0x00C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDispatcherRegistered;                            // 0x00D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDispatcherUnregistered;                          // 0x00E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EInteractionCoopReceiverState                 State;                                             // 0x00F0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UInteractionCoopDispatcher*, EDispatcherState> Dispatchers;                                       // 0x00F8(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void K2_DispatcherRegistered(const class UInteractionCoopDispatcher* Dispatcher);
	void K2_DispatcherUnregistered(const class UInteractionCoopDispatcher* Dispatcher);
	void K2_OnRep_State();
	void OnRep_State();
	bool TrySetState(EInteractionCoopReceiverState NewState);

	bool K2_CanChangeState(EInteractionCoopReceiverState RequestedNewState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionCoopReceiver">();
	}
	static class UInteractionCoopReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionCoopReceiver>();
	}
};
static_assert(alignof(UInteractionCoopReceiver) == 0x000008, "Wrong alignment on UInteractionCoopReceiver");
static_assert(sizeof(UInteractionCoopReceiver) == 0x000148, "Wrong size on UInteractionCoopReceiver");
static_assert(offsetof(UInteractionCoopReceiver, OnStateChanged) == 0x0000C0, "Member 'UInteractionCoopReceiver::OnStateChanged' has a wrong offset!");
static_assert(offsetof(UInteractionCoopReceiver, OnDispatcherRegistered) == 0x0000D0, "Member 'UInteractionCoopReceiver::OnDispatcherRegistered' has a wrong offset!");
static_assert(offsetof(UInteractionCoopReceiver, OnDispatcherUnregistered) == 0x0000E0, "Member 'UInteractionCoopReceiver::OnDispatcherUnregistered' has a wrong offset!");
static_assert(offsetof(UInteractionCoopReceiver, State) == 0x0000F0, "Member 'UInteractionCoopReceiver::State' has a wrong offset!");
static_assert(offsetof(UInteractionCoopReceiver, Dispatchers) == 0x0000F8, "Member 'UInteractionCoopReceiver::Dispatchers' has a wrong offset!");

// Class SCT.InteractionProgressBarCreator
// 0x0038 (0x00F8 - 0x00C0)
class UInteractionProgressBarCreator final : public UInteractionComponentCosmeticBase
{
public:
	TSubclassOf<class UProgressBarWidget>         ProgressBarTypeOverride;                           // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   Description;                                       // 0x00C8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPrivate)
	float                                         Duration;                                          // 0x00E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UProgressBarWidget*                     ProgressBarInstance;                               // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           EndTimerHandle;                                    // 0x00F0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionProgressBarCreator">();
	}
	static class UInteractionProgressBarCreator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionProgressBarCreator>();
	}
};
static_assert(alignof(UInteractionProgressBarCreator) == 0x000008, "Wrong alignment on UInteractionProgressBarCreator");
static_assert(sizeof(UInteractionProgressBarCreator) == 0x0000F8, "Wrong size on UInteractionProgressBarCreator");
static_assert(offsetof(UInteractionProgressBarCreator, ProgressBarTypeOverride) == 0x0000C0, "Member 'UInteractionProgressBarCreator::ProgressBarTypeOverride' has a wrong offset!");
static_assert(offsetof(UInteractionProgressBarCreator, Description) == 0x0000C8, "Member 'UInteractionProgressBarCreator::Description' has a wrong offset!");
static_assert(offsetof(UInteractionProgressBarCreator, Duration) == 0x0000E0, "Member 'UInteractionProgressBarCreator::Duration' has a wrong offset!");
static_assert(offsetof(UInteractionProgressBarCreator, ProgressBarInstance) == 0x0000E8, "Member 'UInteractionProgressBarCreator::ProgressBarInstance' has a wrong offset!");
static_assert(offsetof(UInteractionProgressBarCreator, EndTimerHandle) == 0x0000F0, "Member 'UInteractionProgressBarCreator::EndTimerHandle' has a wrong offset!");

// Class SCT.InteractionSkillcheckExtension
// 0x0010 (0x00D0 - 0x00C0)
class UInteractionSkillcheckExtension final : public UInteractionComponentCosmeticBase
{
public:
	class ASkillcheckManager*                     Manager;                                           // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetManager(class ASkillcheckManager* Manager_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionSkillcheckExtension">();
	}
	static class UInteractionSkillcheckExtension* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInteractionSkillcheckExtension>();
	}
};
static_assert(alignof(UInteractionSkillcheckExtension) == 0x000008, "Wrong alignment on UInteractionSkillcheckExtension");
static_assert(sizeof(UInteractionSkillcheckExtension) == 0x0000D0, "Wrong size on UInteractionSkillcheckExtension");
static_assert(offsetof(UInteractionSkillcheckExtension, Manager) == 0x0000C0, "Member 'UInteractionSkillcheckExtension::Manager' has a wrong offset!");

// Class SCT.InteractionSubComponentInterface
// 0x0000 (0x0028 - 0x0028)
class IInteractionSubComponentInterface final : public IInterface
{
public:
	void Ended(const struct FInteractionPayload& Payload, bool WasCancelled);
	void SetInteractionOwner(class UInteractionComponent* Component);
	void Started(const struct FInteractionPayload& Payload);
	void Succeeded();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InteractionSubComponentInterface">();
	}
	static class IInteractionSubComponentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IInteractionSubComponentInterface>();
	}
};
static_assert(alignof(IInteractionSubComponentInterface) == 0x000008, "Wrong alignment on IInteractionSubComponentInterface");
static_assert(sizeof(IInteractionSubComponentInterface) == 0x000028, "Wrong size on IInteractionSubComponentInterface");

// Class SCT.Inventory
// 0x0088 (0x0138 - 0x00B0)
class UInventory final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnPowerRemoved;                                    // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInventoryChanged;                                // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStackChanged;                                    // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSlotAssigned;                                    // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSlotCleared;                                     // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNewPowerAdded;                                   // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAgendaControllerPowerEvent*            OnPowerAdded;                                      // 0x0110(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCachedItemSlotData>            CachedItemSlots;                                   // 0x0118(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignToSlot(class UPower* Power, EInventorySlotID SlotId);
	void CallOnInventoryChanged(const struct FGameplayAbilitySpec& Spec);
	void CallOnSlotAssigned(class UPower* PowerChanged, EInventorySlotID SlotId);
	void CallOnSlotCleared(class UPower* PowerChanged, EInventorySlotID SlotId);
	void ClearSlot(EInventorySlotID SlotId);
	void ClientOnInventoryChanged();
	void ClientOnSlotAssigned(class UPower* PowerChanged, EInventorySlotID SlotId);
	void ClientOnSlotCleared(class UPower* PowerChanged, EInventorySlotID SlotId);
	void DropAllPowers();
	bool DropPowerType(TSubclassOf<class UPower> PowerType, const struct FVector& WorldPosition);
	bool DropSwapableIfPossible(TSubclassOf<class UPower> PowerType, const struct FVector& PickupPosition, bool TrueIfNone);
	TSubclassOf<class UPower> GetCachedItem(EInventorySlotID SlotId);
	void OnAbilityGranted(class UPower* Power);
	void OnAbilityRemoved(struct FGameplayAbilitySpec* AbilitySpec);
	void OnRep_CachedItemSlots();
	bool RemovePower(class UPower* Power);
	bool RemovePowerAll(class UPower* Power);
	bool RemovePowerStacks(class UPower* Power, int32 StacksToRemove);
	bool RemovePowerType(TSubclassOf<class UPower> PowerType);
	bool RemovePowerTypeAll(TSubclassOf<class UPower> PowerType);
	bool RemovePowerTypeStacks(TSubclassOf<class UPower> PowerType, int32 StacksToRemove);
	bool TryAddPower(TSubclassOf<class UPower> PowerType, int32 StacksToAdd, const struct FPowerRuntimeData& RuntimeData, int32 InputID);
	bool TrySwapPower(TSubclassOf<class UPower> PowerType, int32 StacksToAdd, const struct FVector& PickupPosition, const struct FPowerRuntimeData& RuntimeData);

	bool CanAddPower(TSubclassOf<class UPower> PowerType, int32 Stacks) const;
	bool CanPickupUniqueItem(TSubclassOf<class UPower> Power) const;
	bool ContainsPower(const class UPower* Power) const;
	bool ContainsPowerType(TSubclassOf<class UPower> PowerType) const;
	TArray<struct FItemDetails> GetAllItems() const;
	TArray<struct FPowerDetails> GetAllPowers() const;
	TArray<struct FSkillDetails> GetAllSkills() const;
	int32 GetCount() const;
	bool HasCachedItem(EInventorySlotID SlotId) const;
	bool HasUniqueItem() const;
	bool IsUniqueItem(TSubclassOf<class UPower> Power) const;
	class UPower* TryGetPowerFromType(const TSubclassOf<class UPower> PowerType) const;
	class UPower* TryGetPowerInSlot(EInventorySlotID SlotId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Inventory">();
	}
	static class UInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventory>();
	}
};
static_assert(alignof(UInventory) == 0x000008, "Wrong alignment on UInventory");
static_assert(sizeof(UInventory) == 0x000138, "Wrong size on UInventory");
static_assert(offsetof(UInventory, OnPowerRemoved) == 0x0000B0, "Member 'UInventory::OnPowerRemoved' has a wrong offset!");
static_assert(offsetof(UInventory, OnInventoryChanged) == 0x0000C0, "Member 'UInventory::OnInventoryChanged' has a wrong offset!");
static_assert(offsetof(UInventory, OnStackChanged) == 0x0000D0, "Member 'UInventory::OnStackChanged' has a wrong offset!");
static_assert(offsetof(UInventory, OnSlotAssigned) == 0x0000E0, "Member 'UInventory::OnSlotAssigned' has a wrong offset!");
static_assert(offsetof(UInventory, OnSlotCleared) == 0x0000F0, "Member 'UInventory::OnSlotCleared' has a wrong offset!");
static_assert(offsetof(UInventory, OnNewPowerAdded) == 0x000100, "Member 'UInventory::OnNewPowerAdded' has a wrong offset!");
static_assert(offsetof(UInventory, OnPowerAdded) == 0x000110, "Member 'UInventory::OnPowerAdded' has a wrong offset!");
static_assert(offsetof(UInventory, CachedItemSlots) == 0x000118, "Member 'UInventory::CachedItemSlots' has a wrong offset!");

// Class SCT.Keycard
// 0x0000 (0x0440 - 0x0440)
class UKeycard final : public UItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Keycard">();
	}
	static class UKeycard* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeycard>();
	}
};
static_assert(alignof(UKeycard) == 0x000008, "Wrong alignment on UKeycard");
static_assert(sizeof(UKeycard) == 0x000440, "Wrong size on UKeycard");

// Class SCT.SymbolPuzzleComponent
// 0x0020 (0x00D0 - 0x00B0)
class USymbolPuzzleComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnSymbolSelected;                                  // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUserQuit;                                        // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AssignSeed(int32 Seed);
	void OnWidgetSymbolSelected(int32 Index_0);
	void ServerSelectedSymbol(int32 Index_0);
	void ServerUserQuit();
	void ToggleUI(bool Toggle);

	class USymbolPuzzleWidget* GetPuzzleWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SymbolPuzzleComponent">();
	}
	static class USymbolPuzzleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USymbolPuzzleComponent>();
	}
};
static_assert(alignof(USymbolPuzzleComponent) == 0x000008, "Wrong alignment on USymbolPuzzleComponent");
static_assert(sizeof(USymbolPuzzleComponent) == 0x0000D0, "Wrong size on USymbolPuzzleComponent");
static_assert(offsetof(USymbolPuzzleComponent, OnSymbolSelected) == 0x0000B0, "Member 'USymbolPuzzleComponent::OnSymbolSelected' has a wrong offset!");
static_assert(offsetof(USymbolPuzzleComponent, OnUserQuit) == 0x0000C0, "Member 'USymbolPuzzleComponent::OnUserQuit' has a wrong offset!");

// Class SCT.KeycardData
// 0x0000 (0x0108 - 0x0108)
class UKeycardData final : public UItemData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KeycardData">();
	}
	static class UKeycardData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKeycardData>();
	}
};
static_assert(alignof(UKeycardData) == 0x000008, "Wrong alignment on UKeycardData");
static_assert(sizeof(UKeycardData) == 0x000108, "Wrong size on UKeycardData");

// Class SCT.KillCalculationBase
// 0x0008 (0x0048 - 0x0040)
class UKillCalculationBase : public UGameplayEffectExecutionCalculation
{
public:
	EFate                                         Fate;                                              // 0x0040(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillCalculationBase">();
	}
	static class UKillCalculationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillCalculationBase>();
	}
};
static_assert(alignof(UKillCalculationBase) == 0x000008, "Wrong alignment on UKillCalculationBase");
static_assert(sizeof(UKillCalculationBase) == 0x000048, "Wrong size on UKillCalculationBase");
static_assert(offsetof(UKillCalculationBase, Fate) == 0x000040, "Member 'UKillCalculationBase::Fate' has a wrong offset!");

// Class SCT.LevelChangeHandlerInterface
// 0x0000 (0x0028 - 0x0028)
class ILevelChangeHandlerInterface final : public IInterface
{
public:
	void K2_PostLevelChange();
	void K2_PreLevelChange();
	void PostLevelChange();
	void PreLevelChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelChangeHandlerInterface">();
	}
	static class ILevelChangeHandlerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILevelChangeHandlerInterface>();
	}
};
static_assert(alignof(ILevelChangeHandlerInterface) == 0x000008, "Wrong alignment on ILevelChangeHandlerInterface");
static_assert(sizeof(ILevelChangeHandlerInterface) == 0x000028, "Wrong size on ILevelChangeHandlerInterface");

// Class SCT.LevelVoteComponent
// 0x00F0 (0x01A0 - 0x00B0)
class ULevelVoteComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnLevelSelectionChanged;                           // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLevelSelectedCountDownStarted;                   // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLevelVotesUpdated;                               // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimeoutTimeUpdated;                              // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FSelectedLevelData                     SelectedLevel;                                     // 0x00F0(0x0058)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	TArray<uint8>                                 VoteOptions;                                       // 0x0148(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<uint8>                                 TotalVotes;                                        // 0x0158(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	float                                         VoteTimeoutTime;                                   // 0x0168(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 CachedTotalVotes;                                  // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	SCT::EVoteState                               State;                                             // 0x0180(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_184[0x4];                                      // 0x0184(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 VotedPlayers;                                      // 0x0188(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           TimeoutHandle;                                     // 0x0198(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_SelectedLevel();
	void OnRep_TotalVoted();
	void OnRep_VoteOptions();
	void OnRep_VoteTimeoutTime();
	void OnVoteTimeout();
	void StartVotingProcess();
	void VoteOnLevel(int32 LevelIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelVoteComponent">();
	}
	static class ULevelVoteComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelVoteComponent>();
	}
};
static_assert(alignof(ULevelVoteComponent) == 0x000008, "Wrong alignment on ULevelVoteComponent");
static_assert(sizeof(ULevelVoteComponent) == 0x0001A0, "Wrong size on ULevelVoteComponent");
static_assert(offsetof(ULevelVoteComponent, OnLevelSelectionChanged) == 0x0000B0, "Member 'ULevelVoteComponent::OnLevelSelectionChanged' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, OnLevelSelectedCountDownStarted) == 0x0000C0, "Member 'ULevelVoteComponent::OnLevelSelectedCountDownStarted' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, OnLevelVotesUpdated) == 0x0000D0, "Member 'ULevelVoteComponent::OnLevelVotesUpdated' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, OnTimeoutTimeUpdated) == 0x0000E0, "Member 'ULevelVoteComponent::OnTimeoutTimeUpdated' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, SelectedLevel) == 0x0000F0, "Member 'ULevelVoteComponent::SelectedLevel' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, VoteOptions) == 0x000148, "Member 'ULevelVoteComponent::VoteOptions' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, TotalVotes) == 0x000158, "Member 'ULevelVoteComponent::TotalVotes' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, VoteTimeoutTime) == 0x000168, "Member 'ULevelVoteComponent::VoteTimeoutTime' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, CachedTotalVotes) == 0x000170, "Member 'ULevelVoteComponent::CachedTotalVotes' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, State) == 0x000180, "Member 'ULevelVoteComponent::State' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, VotedPlayers) == 0x000188, "Member 'ULevelVoteComponent::VotedPlayers' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, TimeoutHandle) == 0x000198, "Member 'ULevelVoteComponent::TimeoutHandle' has a wrong offset!");

// Class SCT.XboxGameSessionControllerGIS
// 0x0140 (0x0170 - 0x0030)
class UXboxGameSessionControllerGIS final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x140];                                     // 0x0030(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClientCreateGameSessionReservation(class APlayerController* PlayerController, const class FString& GameSessionID, const struct FMatchEndData& MatchEndData);
	void ClientCreateNewGameSession(class APlayerController* PlayerController);
	void ClientFinishGameSession(class APlayerController* PlayerController, const class FString& GameSessionID);
	bool ClientHasGameSession();
	void ClientJoinGameSession(class APlayerController* PlayerController, const class FString& GameSessionID);
	void ClientLeaveGameSession(class APlayerController* PlayerController);
	void ClientReceiveServerClientStateData(const struct FXboxGameSessionControllerClientStateData& XboxGameSessionControllerClientStateData);
	void ClientResetGameSession();
	void DoGameSessionFinishes();
	void DoJoinClients();
	void DoJoins();
	void DoRequestNewGameSession();
	void DoReservations();
	void DoReserveClients();
	void DoUpdateGameStateClientStates();
	void RunClientCommand(class APlayerController* PlayerController, EXboxGameSessionClientCommand ClientCommand, const struct FXboxGameSessionCommandData& CommandData);
	void ServerBeginGameSession();
	void ServerClientJoinGameSession(class APlayerController* PlayerController);
	void ServerEndGameSession(const struct FMatchEndData& MatchEndData);
	void ServerProcessCommandResult(class APlayerController* PlayerController, EXboxGameSessionServerCommandResult CommandResult, const struct FXboxGameSessionCommandData& CommandData);
	void ServerRemoveClient(class APlayerController* PlayerController);
	void ServerStartNewGameSession();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XboxGameSessionControllerGIS">();
	}
	static class UXboxGameSessionControllerGIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXboxGameSessionControllerGIS>();
	}
};
static_assert(alignof(UXboxGameSessionControllerGIS) == 0x000008, "Wrong alignment on UXboxGameSessionControllerGIS");
static_assert(sizeof(UXboxGameSessionControllerGIS) == 0x000170, "Wrong size on UXboxGameSessionControllerGIS");

// Class SCT.LocalizedProjectSettingsObject
// 0x00C0 (0x00E8 - 0x0028)
class ULocalizedProjectSettingsObject : public UObject
{
public:
	TArray<struct FInputInformation>              InputSettingsActions;                              // 0x0028(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FInputInformationAxis> InputSettingsAxes;                                 // 0x0038(0x0050)(Edit, NativeAccessSpecifierPublic)
	TMap<class FName, struct FInputInformationToggle> InputSettingsToggles;                              // 0x0088(0x0050)(Edit, NativeAccessSpecifierPublic)
	TArray<struct FLevelVoteData>                 IntermediateLevelsVoteData;                        // 0x00D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalizedProjectSettingsObject">();
	}
	static class ULocalizedProjectSettingsObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalizedProjectSettingsObject>();
	}
};
static_assert(alignof(ULocalizedProjectSettingsObject) == 0x000008, "Wrong alignment on ULocalizedProjectSettingsObject");
static_assert(sizeof(ULocalizedProjectSettingsObject) == 0x0000E8, "Wrong size on ULocalizedProjectSettingsObject");
static_assert(offsetof(ULocalizedProjectSettingsObject, InputSettingsActions) == 0x000028, "Member 'ULocalizedProjectSettingsObject::InputSettingsActions' has a wrong offset!");
static_assert(offsetof(ULocalizedProjectSettingsObject, InputSettingsAxes) == 0x000038, "Member 'ULocalizedProjectSettingsObject::InputSettingsAxes' has a wrong offset!");
static_assert(offsetof(ULocalizedProjectSettingsObject, InputSettingsToggles) == 0x000088, "Member 'ULocalizedProjectSettingsObject::InputSettingsToggles' has a wrong offset!");
static_assert(offsetof(ULocalizedProjectSettingsObject, IntermediateLevelsVoteData) == 0x0000D8, "Member 'ULocalizedProjectSettingsObject::IntermediateLevelsVoteData' has a wrong offset!");

// Class SCT.MatchmakerLanguageData
// 0x0058 (0x0088 - 0x0030)
class UMatchmakerLanguageData final : public UPrimaryDataAsset
{
public:
	TMap<class FString, struct FMatchmakerLanguageDatum> MatchmakerLanguages;                               // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetKeyAt(int32 Index_0);
	int32 GetKeyIndex(const class FString& Key);
	void PopuplateComboBoxString(class UComboBoxString* InComboBoxString);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakerLanguageData">();
	}
	static class UMatchmakerLanguageData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakerLanguageData>();
	}
};
static_assert(alignof(UMatchmakerLanguageData) == 0x000008, "Wrong alignment on UMatchmakerLanguageData");
static_assert(sizeof(UMatchmakerLanguageData) == 0x000088, "Wrong size on UMatchmakerLanguageData");
static_assert(offsetof(UMatchmakerLanguageData, MatchmakerLanguages) == 0x000030, "Member 'UMatchmakerLanguageData::MatchmakerLanguages' has a wrong offset!");

// Class SCT.MatchStartedInterface
// 0x0000 (0x0028 - 0x0028)
class IMatchStartedInterface final : public IInterface
{
public:
	void OnMatchHasStarted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchStartedInterface">();
	}
	static class IMatchStartedInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMatchStartedInterface>();
	}
};
static_assert(alignof(IMatchStartedInterface) == 0x000008, "Wrong alignment on IMatchStartedInterface");
static_assert(sizeof(IMatchStartedInterface) == 0x000028, "Wrong size on IMatchStartedInterface");

// Class SCT.MaterialCustomizationRowWidget
// 0x0010 (0x0270 - 0x0260)
class UMaterialCustomizationRowWidget : public UUserWidget
{
public:
	class UScrollBox*                             OptionsList;                                       // 0x0260(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCustomizationOptionUserWidget> OptionSlotClass;                                   // 0x0268(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool GenerateOptions(const TArray<class UMaterialInstance*>& InOptions, class UPrimitiveComponent* InClothingPrimitive, int32 InMeshMaterialIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialCustomizationRowWidget">();
	}
	static class UMaterialCustomizationRowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialCustomizationRowWidget>();
	}
};
static_assert(alignof(UMaterialCustomizationRowWidget) == 0x000008, "Wrong alignment on UMaterialCustomizationRowWidget");
static_assert(sizeof(UMaterialCustomizationRowWidget) == 0x000270, "Wrong size on UMaterialCustomizationRowWidget");
static_assert(offsetof(UMaterialCustomizationRowWidget, OptionsList) == 0x000260, "Member 'UMaterialCustomizationRowWidget::OptionsList' has a wrong offset!");
static_assert(offsetof(UMaterialCustomizationRowWidget, OptionSlotClass) == 0x000268, "Member 'UMaterialCustomizationRowWidget::OptionSlotClass' has a wrong offset!");

// Class SCT.Modal
// 0x0250 (0x0300 - 0x00B0)
class UModal final : public UActorComponent
{
public:
	uint8                                         Pad_B0[0x120];                                     // 0x00B0(0x0120)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UWidgetSCT>                 MasterWidget;                                      // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetSCT>                 InGameMenuWidget;                                  // 0x01D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetSCT>                 AirlockWidget;                                     // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetSCT>                 SkillcheckWidget;                                  // 0x01E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetSCT>                 PuzzleWidget;                                      // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetSCT>                 ItemWheelWidget;                                   // 0x01F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetSCT>                 CharacterWidget;                                   // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetSCT>                 ThumbVoteWidget;                                   // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetSCT>                 SpectatorHUDWidget;                                // 0x0210(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetSCT>                 EmergencyMeetingWidget;                            // 0x0218(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetSCT>                 EmoteWheelWidget;                                  // 0x0220(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetSCT>                 PlayerListWidget;                                  // 0x0228(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UWidgetSCT>                 MapVotingWidget;                                   // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            InGameMenuPtr;                                     // 0x0238(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            AirlockPtr;                                        // 0x0240(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            SkillCheckPtr;                                     // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            PuzzleWidgetPtr;                                   // 0x0250(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ItemWheelPtr;                                      // 0x0258(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            CharacterPtr;                                      // 0x0260(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            ThumbVoteWidgetPtr;                                // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            SpectatorHUDWidgetPtr;                             // 0x0270(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            EmergencyMeetingWidgetPtr;                         // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            EmoteWheelWidgegtPtr;                              // 0x0280(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            PlayerListWidgetPtr;                               // 0x0288(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            MapVotingWidgetPtr;                                // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_298[0x68];                                     // 0x0298(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EscapeAMenu();

	bool IsAirlockMenuVisible() const;
	bool IsCharacterMenuVisible() const;
	bool IsEmergencyMeetingVisible() const;
	bool IsEmoteWheelVisible() const;
	bool IsInGameMenuVisible() const;
	bool IsItemWheelVisible() const;
	bool IsMapVotingVisible() const;
	bool IsPlayerListVisible() const;
	bool IsPuzzleMenuVisible() const;
	bool IsSkillCheckMenuVisible() const;
	bool IsSpectatorHUDMenuVisible() const;
	bool IsThumbVoteMenuVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Modal">();
	}
	static class UModal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UModal>();
	}
};
static_assert(alignof(UModal) == 0x000008, "Wrong alignment on UModal");
static_assert(sizeof(UModal) == 0x000300, "Wrong size on UModal");
static_assert(offsetof(UModal, MasterWidget) == 0x0001D0, "Member 'UModal::MasterWidget' has a wrong offset!");
static_assert(offsetof(UModal, InGameMenuWidget) == 0x0001D8, "Member 'UModal::InGameMenuWidget' has a wrong offset!");
static_assert(offsetof(UModal, AirlockWidget) == 0x0001E0, "Member 'UModal::AirlockWidget' has a wrong offset!");
static_assert(offsetof(UModal, SkillcheckWidget) == 0x0001E8, "Member 'UModal::SkillcheckWidget' has a wrong offset!");
static_assert(offsetof(UModal, PuzzleWidget) == 0x0001F0, "Member 'UModal::PuzzleWidget' has a wrong offset!");
static_assert(offsetof(UModal, ItemWheelWidget) == 0x0001F8, "Member 'UModal::ItemWheelWidget' has a wrong offset!");
static_assert(offsetof(UModal, CharacterWidget) == 0x000200, "Member 'UModal::CharacterWidget' has a wrong offset!");
static_assert(offsetof(UModal, ThumbVoteWidget) == 0x000208, "Member 'UModal::ThumbVoteWidget' has a wrong offset!");
static_assert(offsetof(UModal, SpectatorHUDWidget) == 0x000210, "Member 'UModal::SpectatorHUDWidget' has a wrong offset!");
static_assert(offsetof(UModal, EmergencyMeetingWidget) == 0x000218, "Member 'UModal::EmergencyMeetingWidget' has a wrong offset!");
static_assert(offsetof(UModal, EmoteWheelWidget) == 0x000220, "Member 'UModal::EmoteWheelWidget' has a wrong offset!");
static_assert(offsetof(UModal, PlayerListWidget) == 0x000228, "Member 'UModal::PlayerListWidget' has a wrong offset!");
static_assert(offsetof(UModal, MapVotingWidget) == 0x000230, "Member 'UModal::MapVotingWidget' has a wrong offset!");
static_assert(offsetof(UModal, InGameMenuPtr) == 0x000238, "Member 'UModal::InGameMenuPtr' has a wrong offset!");
static_assert(offsetof(UModal, AirlockPtr) == 0x000240, "Member 'UModal::AirlockPtr' has a wrong offset!");
static_assert(offsetof(UModal, SkillCheckPtr) == 0x000248, "Member 'UModal::SkillCheckPtr' has a wrong offset!");
static_assert(offsetof(UModal, PuzzleWidgetPtr) == 0x000250, "Member 'UModal::PuzzleWidgetPtr' has a wrong offset!");
static_assert(offsetof(UModal, ItemWheelPtr) == 0x000258, "Member 'UModal::ItemWheelPtr' has a wrong offset!");
static_assert(offsetof(UModal, CharacterPtr) == 0x000260, "Member 'UModal::CharacterPtr' has a wrong offset!");
static_assert(offsetof(UModal, ThumbVoteWidgetPtr) == 0x000268, "Member 'UModal::ThumbVoteWidgetPtr' has a wrong offset!");
static_assert(offsetof(UModal, SpectatorHUDWidgetPtr) == 0x000270, "Member 'UModal::SpectatorHUDWidgetPtr' has a wrong offset!");
static_assert(offsetof(UModal, EmergencyMeetingWidgetPtr) == 0x000278, "Member 'UModal::EmergencyMeetingWidgetPtr' has a wrong offset!");
static_assert(offsetof(UModal, EmoteWheelWidgegtPtr) == 0x000280, "Member 'UModal::EmoteWheelWidgegtPtr' has a wrong offset!");
static_assert(offsetof(UModal, PlayerListWidgetPtr) == 0x000288, "Member 'UModal::PlayerListWidgetPtr' has a wrong offset!");
static_assert(offsetof(UModal, MapVotingWidgetPtr) == 0x000290, "Member 'UModal::MapVotingWidgetPtr' has a wrong offset!");

// Class SCT.MoveAttributeSet
// 0x0020 (0x0050 - 0x0030)
class UMoveAttributeSet final : public UAttributeSet
{
public:
	FMulticastInlineDelegateProperty_             OnMovementSpeedChanged;                            // 0x0030(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MoveSpeed;                                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_MoveSpeed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MoveAttributeSet">();
	}
	static class UMoveAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMoveAttributeSet>();
	}
};
static_assert(alignof(UMoveAttributeSet) == 0x000008, "Wrong alignment on UMoveAttributeSet");
static_assert(sizeof(UMoveAttributeSet) == 0x000050, "Wrong size on UMoveAttributeSet");
static_assert(offsetof(UMoveAttributeSet, OnMovementSpeedChanged) == 0x000030, "Member 'UMoveAttributeSet::OnMovementSpeedChanged' has a wrong offset!");
static_assert(offsetof(UMoveAttributeSet, MoveSpeed) == 0x000040, "Member 'UMoveAttributeSet::MoveSpeed' has a wrong offset!");

// Class SCT.OxygenAttributeSet
// 0x0040 (0x0070 - 0x0030)
class UOxygenAttributeSet final : public UAttributeSet
{
public:
	FMulticastInlineDelegateProperty_             OnOxygenChanged;                                   // 0x0030(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEmpty;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Oxygen;                                            // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxOxygen;                                         // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_MaxOxygen();
	void OnRep_Oxygen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OxygenAttributeSet">();
	}
	static class UOxygenAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOxygenAttributeSet>();
	}
};
static_assert(alignof(UOxygenAttributeSet) == 0x000008, "Wrong alignment on UOxygenAttributeSet");
static_assert(sizeof(UOxygenAttributeSet) == 0x000070, "Wrong size on UOxygenAttributeSet");
static_assert(offsetof(UOxygenAttributeSet, OnOxygenChanged) == 0x000030, "Member 'UOxygenAttributeSet::OnOxygenChanged' has a wrong offset!");
static_assert(offsetof(UOxygenAttributeSet, OnEmpty) == 0x000040, "Member 'UOxygenAttributeSet::OnEmpty' has a wrong offset!");
static_assert(offsetof(UOxygenAttributeSet, Oxygen) == 0x000050, "Member 'UOxygenAttributeSet::Oxygen' has a wrong offset!");
static_assert(offsetof(UOxygenAttributeSet, MaxOxygen) == 0x000060, "Member 'UOxygenAttributeSet::MaxOxygen' has a wrong offset!");

// Class SCT.OxygenChangedEvent
// 0x0000 (0x0040 - 0x0040)
class UOxygenChangedEvent final : public UGlobalEventFloat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OxygenChangedEvent">();
	}
	static class UOxygenChangedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOxygenChangedEvent>();
	}
};
static_assert(alignof(UOxygenChangedEvent) == 0x000008, "Wrong alignment on UOxygenChangedEvent");
static_assert(sizeof(UOxygenChangedEvent) == 0x000040, "Wrong size on UOxygenChangedEvent");

// Class SCT.OxygenPotion
// 0x0000 (0x0440 - 0x0440)
class UOxygenPotion final : public UItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OxygenPotion">();
	}
	static class UOxygenPotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOxygenPotion>();
	}
};
static_assert(alignof(UOxygenPotion) == 0x000008, "Wrong alignment on UOxygenPotion");
static_assert(sizeof(UOxygenPotion) == 0x000440, "Wrong size on UOxygenPotion");

// Class SCT.OxygenPotionData
// 0x0008 (0x0110 - 0x0108)
class UOxygenPotionData final : public UItemData
{
public:
	float                                         AmountOfOxygenToAdd;                               // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OxygenPotionData">();
	}
	static class UOxygenPotionData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOxygenPotionData>();
	}
};
static_assert(alignof(UOxygenPotionData) == 0x000008, "Wrong alignment on UOxygenPotionData");
static_assert(sizeof(UOxygenPotionData) == 0x000110, "Wrong size on UOxygenPotionData");
static_assert(offsetof(UOxygenPotionData, AmountOfOxygenToAdd) == 0x000108, "Member 'UOxygenPotionData::AmountOfOxygenToAdd' has a wrong offset!");

// Class SCT.PartyListInterface
// 0x0000 (0x0028 - 0x0028)
class IPartyListInterface final : public IInterface
{
public:
	TArray<class FString> GetDebugPartyMembers();
	bool IsDebugMode();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyListInterface">();
	}
	static class IPartyListInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPartyListInterface>();
	}
};
static_assert(alignof(IPartyListInterface) == 0x000008, "Wrong alignment on IPartyListInterface");
static_assert(sizeof(IPartyListInterface) == 0x000028, "Wrong size on IPartyListInterface");

// Class SCT.PassengerLog
// 0x0000 (0x0440 - 0x0440)
class UPassengerLog final : public UItem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PassengerLog">();
	}
	static class UPassengerLog* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassengerLog>();
	}
};
static_assert(alignof(UPassengerLog) == 0x000008, "Wrong alignment on UPassengerLog");
static_assert(sizeof(UPassengerLog) == 0x000440, "Wrong size on UPassengerLog");

// Class SCT.PassengerLogData
// 0x0000 (0x0108 - 0x0108)
class UPassengerLogData final : public UItemData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PassengerLogData">();
	}
	static class UPassengerLogData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassengerLogData>();
	}
};
static_assert(alignof(UPassengerLogData) == 0x000008, "Wrong alignment on UPassengerLogData");
static_assert(sizeof(UPassengerLogData) == 0x000108, "Wrong size on UPassengerLogData");

// Class SCT.PassengerLogGenerator
// 0x0010 (0x0038 - 0x0028)
class UPassengerLogGenerator final : public UObject
{
public:
	uint8                                         Pad_28[0x10];                                      // 0x0028(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanSpawn();
	class FText GetDescriptionText();
	struct FPassengerLogInformation GetInformation();
	void Initialize();
	void LogShit(const class FString& Msg);
	void Sabotage(const struct FInteractionPayload& Payload);
	void SetTargets(const TArray<int32>& Targets);

	class UObject* GetContextObject() const;
	class UPassengerLogGIS* GetPassengerLogGIS() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PassengerLogGenerator">();
	}
	static class UPassengerLogGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassengerLogGenerator>();
	}
};
static_assert(alignof(UPassengerLogGenerator) == 0x000008, "Wrong alignment on UPassengerLogGenerator");
static_assert(sizeof(UPassengerLogGenerator) == 0x000038, "Wrong size on UPassengerLogGenerator");

// Class SCT.PassengerLogGIS
// 0x0000 (0x0030 - 0x0030)
class UPassengerLogGIS final : public UGameInstanceSubsystem
{
public:
	int32 GetRandom(const TArray<int32>& bannedPlayers);
	int32 GetRandomPersonoid(const TArray<int32>& bannedPlayers);
	TArray<int32> GetRandomPlayers(int32 Personoids, int32 Residents);
	int32 GetRandomResident(const TArray<int32>& bannedPlayers);

	TArray<int32> GetAll() const;
	TArray<int32> GetAllFromFaction(EPlayerFaction Faction) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PassengerLogGIS">();
	}
	static class UPassengerLogGIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPassengerLogGIS>();
	}
};
static_assert(alignof(UPassengerLogGIS) == 0x000008, "Wrong alignment on UPassengerLogGIS");
static_assert(sizeof(UPassengerLogGIS) == 0x000030, "Wrong size on UPassengerLogGIS");

// Class SCT.PersonoidChatAbility
// 0x0000 (0x0440 - 0x0440)
class UPersonoidChatAbility : public USkill
{
public:
	void DisablePersonoidChannel();
	void EnablePersonoidChannel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonoidChatAbility">();
	}
	static class UPersonoidChatAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonoidChatAbility>();
	}
};
static_assert(alignof(UPersonoidChatAbility) == 0x000008, "Wrong alignment on UPersonoidChatAbility");
static_assert(sizeof(UPersonoidChatAbility) == 0x000440, "Wrong size on UPersonoidChatAbility");

// Class SCT.PersonoidInformationComponent
// 0x0020 (0x00D0 - 0x00B0)
class UPersonoidInformationComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnUpdated;                                         // 0x00B0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FPersonoidInformationPlayerData> PlayerInformation;                                 // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)

public:
	static bool HaveAllPersonoidsReplicated(class UObject* WorldContextObject);
	static int32 ReplicatedPersonoidsInformationNum(class UObject* WorldContextObject);

	EPlayerFaction GetFaction(int32 PlayerId);
	void OnRep_PlayerInformation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PersonoidInformationComponent">();
	}
	static class UPersonoidInformationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPersonoidInformationComponent>();
	}
};
static_assert(alignof(UPersonoidInformationComponent) == 0x000008, "Wrong alignment on UPersonoidInformationComponent");
static_assert(sizeof(UPersonoidInformationComponent) == 0x0000D0, "Wrong size on UPersonoidInformationComponent");
static_assert(offsetof(UPersonoidInformationComponent, OnUpdated) == 0x0000B0, "Member 'UPersonoidInformationComponent::OnUpdated' has a wrong offset!");
static_assert(offsetof(UPersonoidInformationComponent, PlayerInformation) == 0x0000C0, "Member 'UPersonoidInformationComponent::PlayerInformation' has a wrong offset!");

// Class SCT.PlayerHapticsComponent
// 0x0070 (0x0120 - 0x00B0)
class UPlayerHapticsComponent final : public UActorComponent
{
public:
	class APlayerController*                      PlayerController;                                  // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundSubmix*                           PadTactileMix;                                     // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USoundSubmix*                           PadAudioMix;                                       // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x58];                                      // 0x00C8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(const class APlayerController* InPlayerController, const class USoundSubmix* InPadTactileMix, const class USoundSubmix* InPadAudioMix);
	void PauseHapticsEffects();
	void ResetKeyHaptics(class FName ActionName);
	void ResistKeyPress(class FName ActionName, float PressRangeStart, float PressRangeEnd, float Strength);
	void ResumeHapticsEffects();
	void RumbleKey(class FName ActionName, float PressRangeStart, float Frequency, float Amplitude);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerHapticsComponent">();
	}
	static class UPlayerHapticsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerHapticsComponent>();
	}
};
static_assert(alignof(UPlayerHapticsComponent) == 0x000008, "Wrong alignment on UPlayerHapticsComponent");
static_assert(sizeof(UPlayerHapticsComponent) == 0x000120, "Wrong size on UPlayerHapticsComponent");
static_assert(offsetof(UPlayerHapticsComponent, PlayerController) == 0x0000B0, "Member 'UPlayerHapticsComponent::PlayerController' has a wrong offset!");
static_assert(offsetof(UPlayerHapticsComponent, PadTactileMix) == 0x0000B8, "Member 'UPlayerHapticsComponent::PadTactileMix' has a wrong offset!");
static_assert(offsetof(UPlayerHapticsComponent, PadAudioMix) == 0x0000C0, "Member 'UPlayerHapticsComponent::PadAudioMix' has a wrong offset!");

// Class SCT.BooleanContainer
// 0x0008 (0x0030 - 0x0028)
class UBooleanContainer final : public UObject
{
public:
	bool                                          Value;                                             // 0x0028(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BooleanContainer">();
	}
	static class UBooleanContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBooleanContainer>();
	}
};
static_assert(alignof(UBooleanContainer) == 0x000008, "Wrong alignment on UBooleanContainer");
static_assert(sizeof(UBooleanContainer) == 0x000030, "Wrong size on UBooleanContainer");
static_assert(offsetof(UBooleanContainer, Value) == 0x000028, "Member 'UBooleanContainer::Value' has a wrong offset!");

// Class SCT.FloatingPointContainer
// 0x0008 (0x0030 - 0x0028)
class UFloatingPointContainer final : public UObject
{
public:
	float                                         Value;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FloatingPointContainer">();
	}
	static class UFloatingPointContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFloatingPointContainer>();
	}
};
static_assert(alignof(UFloatingPointContainer) == 0x000008, "Wrong alignment on UFloatingPointContainer");
static_assert(sizeof(UFloatingPointContainer) == 0x000030, "Wrong size on UFloatingPointContainer");
static_assert(offsetof(UFloatingPointContainer, Value) == 0x000028, "Member 'UFloatingPointContainer::Value' has a wrong offset!");

// Class SCT.IntegerContainer
// 0x0008 (0x0030 - 0x0028)
class UIntegerContainer final : public UObject
{
public:
	int32                                         Value;                                             // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IntegerContainer">();
	}
	static class UIntegerContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIntegerContainer>();
	}
};
static_assert(alignof(UIntegerContainer) == 0x000008, "Wrong alignment on UIntegerContainer");
static_assert(sizeof(UIntegerContainer) == 0x000030, "Wrong size on UIntegerContainer");
static_assert(offsetof(UIntegerContainer, Value) == 0x000028, "Member 'UIntegerContainer::Value' has a wrong offset!");

// Class SCT.PlayerInfoGIS
// 0x0120 (0x0150 - 0x0030)
class alignas(0x10) UPlayerInfoGIS final : public UGameInstanceSubsystem
{
public:
	int32                                         NumPersonoids;                                     // 0x0030(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FPlayerData>               AllPlayerData;                                     // 0x0038(0x0050)(NativeAccessSpecifierPublic)
	TMap<class UTransitionDataEntry*, class UObject*> GlobalUserDefinedData;                             // 0x0088(0x0050)(NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0x78];                                      // 0x00D8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddCollaborationScore(int32 PlayerId, int32 Score);
	void AddDeceptionScore(int32 PlayerId, int32 Score);
	void AddDeductionScore(int32 PlayerId, int32 Score);
	void AddEndScenarioScore(int32 PlayerId, int32 Score);
	void AddProgressionScore(int32 PlayerId, int32 Score);
	void AddSabotageScore(int32 PlayerId, int32 Score);
	void AddScoreEntry(int32 PlayerId, class FName RowName);
	void AddTotalPersonoidScore(int32 PlayerId, int32 Score);
	void AddTotalResidentScore(int32 PlayerId, int32 Score);
	class UAgendaObject* GetAgenda(int32 PlayerId);
	TArray<struct FPlayerData> GetAllPlayerData();
	class UClass* GetCharacterVariant(int32 PlayerId);
	TArray<int32> GetDownvotedPlayers(int32 TargetPlayer);
	EFate GetFate(const class APawn* Pawn);
	class UClass* GetHumanoidVariant(int32 PlayerId);
	struct FScore GetScore(int32 PlayerId);
	TArray<int32> GetUpvotedPlayers(int32 TargetPlayer);
	void Kill(int32 PlayerId, const struct FDestiny& Destiny);
	void KillWithFate(int32 PlayerId, EFate Fate);
	void RemoveGlobalData(const class UTransitionDataEntry* Key);
	void RemovePlayerData(const class UTransitionDataEntry* Key, int32 PlayerId);
	void SaveGlobalBool(const class UTransitionDataEntry* Entry, bool Value);
	void SaveGlobalFloat(const class UTransitionDataEntry* Entry, float Value);
	void SaveGlobalInt(const class UTransitionDataEntry* Entry, int32 Value);
	void SaveGlobalObject(const class UTransitionDataEntry* Entry, class UObject* Value);
	void SavePlayerBool(const class UTransitionDataEntry* Entry, int32 PlayerId, bool Value);
	void SavePlayerFloat(const class UTransitionDataEntry* Entry, int32 PlayerId, float Value);
	void SavePlayerInt(const class UTransitionDataEntry* Entry, int32 PlayerId, int32 Value);
	void SavePlayerObject(const class UTransitionDataEntry* Entry, int32 PlayerId, class UObject* Value);

	bool ContainsGlobalData(const class UTransitionDataEntry* Key) const;
	bool ContainsPlayerData(const class UTransitionDataEntry* Key, int32 PlayerId) const;
	bool LoadGlobalBool(const class UTransitionDataEntry* Key, bool* Value) const;
	bool LoadGlobalFloat(const class UTransitionDataEntry* Key, float* Value) const;
	bool LoadGlobalInt(const class UTransitionDataEntry* Key, int32* Value) const;
	bool LoadGlobalObject(const class UTransitionDataEntry* Key, class UObject** Value) const;
	bool LoadPlayerBool(const class UTransitionDataEntry* Key, int32 PlayerId, bool* Value) const;
	bool LoadPlayerFloat(const class UTransitionDataEntry* Key, int32 PlayerId, float* Value) const;
	bool LoadPlayerInt(const class UTransitionDataEntry* Key, int32 PlayerId, int32* Value) const;
	bool LoadPlayerObject(const class UTransitionDataEntry* Key, int32 PlayerId, class UObject** Value) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerInfoGIS">();
	}
	static class UPlayerInfoGIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerInfoGIS>();
	}
};
static_assert(alignof(UPlayerInfoGIS) == 0x000010, "Wrong alignment on UPlayerInfoGIS");
static_assert(sizeof(UPlayerInfoGIS) == 0x000150, "Wrong size on UPlayerInfoGIS");
static_assert(offsetof(UPlayerInfoGIS, NumPersonoids) == 0x000030, "Member 'UPlayerInfoGIS::NumPersonoids' has a wrong offset!");
static_assert(offsetof(UPlayerInfoGIS, AllPlayerData) == 0x000038, "Member 'UPlayerInfoGIS::AllPlayerData' has a wrong offset!");
static_assert(offsetof(UPlayerInfoGIS, GlobalUserDefinedData) == 0x000088, "Member 'UPlayerInfoGIS::GlobalUserDefinedData' has a wrong offset!");

// Class SCT.PlayerListWidget
// 0x0000 (0x0280 - 0x0280)
class UPlayerListWidget : public UWidgetSCT
{
public:
	void PlayerStateAdded(class ASCTPlayerState* PlayerState);
	void PlayerStateRemoved(class ASCTPlayerState* PlayerState);
	void PostLevelChange();
	void PreLevelChange();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerListWidget">();
	}
	static class UPlayerListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerListWidget>();
	}
};
static_assert(alignof(UPlayerListWidget) == 0x000008, "Wrong alignment on UPlayerListWidget");
static_assert(sizeof(UPlayerListWidget) == 0x000280, "Wrong size on UPlayerListWidget");

// Class SCT.PlayerProfileUserWidget
// 0x0000 (0x0260 - 0x0260)
class UPlayerProfileUserWidget final : public UUserWidget
{
public:
	void FindLevelFromExperience(const int32 CurrentExperience, const TArray<int32>& LevelRequirements, int32* OutLevel, float* OutPercentToNextLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerProfileUserWidget">();
	}
	static class UPlayerProfileUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerProfileUserWidget>();
	}
};
static_assert(alignof(UPlayerProfileUserWidget) == 0x000008, "Wrong alignment on UPlayerProfileUserWidget");
static_assert(sizeof(UPlayerProfileUserWidget) == 0x000260, "Wrong size on UPlayerProfileUserWidget");

// Class SCT.PlayerStateEvent
// 0x0010 (0x0040 - 0x0030)
class UPlayerStateEvent : public UGlobalEvent
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Broadcast(class ASCTPlayerState* PlayerState) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateEvent">();
	}
	static class UPlayerStateEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateEvent>();
	}
};
static_assert(alignof(UPlayerStateEvent) == 0x000008, "Wrong alignment on UPlayerStateEvent");
static_assert(sizeof(UPlayerStateEvent) == 0x000040, "Wrong size on UPlayerStateEvent");
static_assert(offsetof(UPlayerStateEvent, Event) == 0x000030, "Member 'UPlayerStateEvent::Event' has a wrong offset!");

// Class SCT.PlayerStateReplicatedEvent
// 0x0000 (0x0028 - 0x0028)
class UPlayerStateReplicatedEvent final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateReplicatedEvent">();
	}
	static class UPlayerStateReplicatedEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateReplicatedEvent>();
	}
};
static_assert(alignof(UPlayerStateReplicatedEvent) == 0x000008, "Wrong alignment on UPlayerStateReplicatedEvent");
static_assert(sizeof(UPlayerStateReplicatedEvent) == 0x000028, "Wrong size on UPlayerStateReplicatedEvent");

// Class SCT.PowerChannel
// 0x0058 (0x0080 - 0x0028)
class UPowerChannel final : public UContextChannel
{
public:
	FMulticastInlineDelegateProperty_             HighestPrioritySet;                                // 0x0028(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             HighestPriorityRemoved;                            // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x28];                                      // 0x0048(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UPower>>          AllPowers;                                         // 0x0070(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerChannel">();
	}
	static class UPowerChannel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPowerChannel>();
	}
};
static_assert(alignof(UPowerChannel) == 0x000008, "Wrong alignment on UPowerChannel");
static_assert(sizeof(UPowerChannel) == 0x000080, "Wrong size on UPowerChannel");
static_assert(offsetof(UPowerChannel, HighestPrioritySet) == 0x000028, "Member 'UPowerChannel::HighestPrioritySet' has a wrong offset!");
static_assert(offsetof(UPowerChannel, HighestPriorityRemoved) == 0x000038, "Member 'UPowerChannel::HighestPriorityRemoved' has a wrong offset!");
static_assert(offsetof(UPowerChannel, AllPowers) == 0x000070, "Member 'UPowerChannel::AllPowers' has a wrong offset!");

// Class SCT.PowerRuntimeDataCacher
// 0x0000 (0x0028 - 0x0028)
class IPowerRuntimeDataCacher final : public IInterface
{
public:
	void CacheRuntimeData(const struct FPowerRuntimeData& RuntimeData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PowerRuntimeDataCacher">();
	}
	static class IPowerRuntimeDataCacher* GetDefaultObj()
	{
		return GetDefaultObjImpl<IPowerRuntimeDataCacher>();
	}
};
static_assert(alignof(IPowerRuntimeDataCacher) == 0x000008, "Wrong alignment on IPowerRuntimeDataCacher");
static_assert(sizeof(IPowerRuntimeDataCacher) == 0x000028, "Wrong size on IPowerRuntimeDataCacher");

// Class SCT.PrimaryInteractionSkill
// 0x0000 (0x0440 - 0x0440)
class UPrimaryInteractionSkill : public UGenericInteractionSkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PrimaryInteractionSkill">();
	}
	static class UPrimaryInteractionSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPrimaryInteractionSkill>();
	}
};
static_assert(alignof(UPrimaryInteractionSkill) == 0x000008, "Wrong alignment on UPrimaryInteractionSkill");
static_assert(sizeof(UPrimaryInteractionSkill) == 0x000440, "Wrong size on UPrimaryInteractionSkill");

// Class SCT.ProgressBarWidget
// 0x0030 (0x02B0 - 0x0280)
class UProgressBarWidget : public UWidgetSCT
{
public:
	FMulticastInlineDelegateProperty_             OnChangeState;                                     // 0x0280(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStartProgress;                                   // 0x0290(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndProgress;                                     // 0x02A0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProgressBarWidget">();
	}
	static class UProgressBarWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProgressBarWidget>();
	}
};
static_assert(alignof(UProgressBarWidget) == 0x000008, "Wrong alignment on UProgressBarWidget");
static_assert(sizeof(UProgressBarWidget) == 0x0002B0, "Wrong size on UProgressBarWidget");
static_assert(offsetof(UProgressBarWidget, OnChangeState) == 0x000280, "Member 'UProgressBarWidget::OnChangeState' has a wrong offset!");
static_assert(offsetof(UProgressBarWidget, OnStartProgress) == 0x000290, "Member 'UProgressBarWidget::OnStartProgress' has a wrong offset!");
static_assert(offsetof(UProgressBarWidget, OnEndProgress) == 0x0002A0, "Member 'UProgressBarWidget::OnEndProgress' has a wrong offset!");

// Class SCT.PS5GameStatsGIS
// 0x0000 (0x0030 - 0x0030)
class UPS5GameStatsGIS final : public UGameInstanceSubsystem
{
public:
	void AddStat(class APlayerController* InPlayerController, class FName InStatName);
	void AddStatByPlayerID(int32 InPlayerID, class FName InStatName);
	void RunClientCommand(class APlayerController* InPlayerController, EPS5GameStatsClientCommand InClientCommand, const struct FPS5GameStatsCommandData& InCommandData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS5GameStatsGIS">();
	}
	static class UPS5GameStatsGIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS5GameStatsGIS>();
	}
};
static_assert(alignof(UPS5GameStatsGIS) == 0x000008, "Wrong alignment on UPS5GameStatsGIS");
static_assert(sizeof(UPS5GameStatsGIS) == 0x000030, "Wrong size on UPS5GameStatsGIS");

// Class SCT.PS5MatchControllerGIS
// 0x0168 (0x0198 - 0x0030)
class UPS5MatchControllerGIS final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x168];                                     // 0x0030(0x0168)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CancelMatches(class APlayerController* PlayerController);
	void ClientCreateNewMatch(class APlayerController* PlayerController);
	void ClientFinishMatch(class APlayerController* PlayerController, const class FString& MatchID);
	bool ClientHasMatch();
	void ClientJoinMatch(class APlayerController* PlayerController, const class FString& MatchID);
	void ClientLeaveMatch(class APlayerController* PlayerController);
	void ClientReceiveServerClientStateData(const struct FPS5MatchControllerClientStateData& PS5MatchControllerClientStateData);
	void ClientReportMatchEnd(class APlayerController* PlayerController, const class FString& MatchID, const struct FMatchEndData& MatchEndData);
	void ClientResetActivity(class APlayerController* PlayerController);
	void ClientSaveMatch(class APlayerController* PlayerController, const class FString& MatchID);
	void ClientShowReviewMatchDialog(class APlayerController* PlayerController);
	void ClientUpdateClientStates(class APlayerController* PlayerController, const class FString& MatchID, const struct FMatchEndData& MatchData);
	void ClientUpdateDetailsEndMatch(class APlayerController* PlayerController, const class FString& MatchID, const struct FMatchEndData& MatchEndData);
	void ClientUpdateInitialMatchDetails(class APlayerController* PlayerController, const class FString& MatchID);
	void ClientUpdateStatusStartMatch(class APlayerController* PlayerController, const class FString& MatchID);
	void DoJoinClients();
	void DoJoins();
	void DoMatchFinishes();
	void DoRequestInitialUpdateDetails();
	void DoRequestMatchEndReport();
	void DoRequestNewMatch();
	void DoUpdateClientStates();
	void DoUpdateDetailsEndMatch();
	void DoUpdateGameStateClientStates();
	void DoUpdateStatusStartMatch();
	void LoadData(class UObject* Context);
	void RunClientCommand(class APlayerController* PlayerController, EPS5MatchClientCommand ClientCommand, const struct FPS5MatchCommandData& CommandData);
	void ServerBeginMatch();
	void ServerClientJoinMatch(class APlayerController* PlayerController);
	void ServerEndMatch(const struct FMatchEndData& MatchEndData);
	void ServerProcessCommandResult(class APlayerController* PlayerController, EPS5MatchServerCommandResult CommandResult, const struct FPS5MatchCommandData& CommandData);
	void ServerRemoveClient(class APlayerController* PlayerController);
	void ServerStartNewSession();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PS5MatchControllerGIS">();
	}
	static class UPS5MatchControllerGIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPS5MatchControllerGIS>();
	}
};
static_assert(alignof(UPS5MatchControllerGIS) == 0x000008, "Wrong alignment on UPS5MatchControllerGIS");
static_assert(sizeof(UPS5MatchControllerGIS) == 0x000198, "Wrong size on UPS5MatchControllerGIS");

// Class SCT.ResurrectCheat
// 0x0000 (0x0440 - 0x0440)
class UResurrectCheat final : public UContextSkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ResurrectCheat">();
	}
	static class UResurrectCheat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UResurrectCheat>();
	}
};
static_assert(alignof(UResurrectCheat) == 0x000008, "Wrong alignment on UResurrectCheat");
static_assert(sizeof(UResurrectCheat) == 0x000440, "Wrong size on UResurrectCheat");

// Class SCT.RoombaCharacter
// 0x0000 (0x05A0 - 0x05A0)
class ARoombaCharacter : public AAfterlifeCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoombaCharacter">();
	}
	static class ARoombaCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARoombaCharacter>();
	}
};
static_assert(alignof(ARoombaCharacter) == 0x000010, "Wrong alignment on ARoombaCharacter");
static_assert(sizeof(ARoombaCharacter) == 0x0005A0, "Wrong size on ARoombaCharacter");

// Class SCT.SabotageSkill
// 0x0000 (0x0440 - 0x0440)
class USabotageSkill final : public UContextSkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SabotageSkill">();
	}
	static class USabotageSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<USabotageSkill>();
	}
};
static_assert(alignof(USabotageSkill) == 0x000008, "Wrong alignment on USabotageSkill");
static_assert(sizeof(USabotageSkill) == 0x000440, "Wrong size on USabotageSkill");

// Class SCT.Scan
// 0x0000 (0x0440 - 0x0440)
class UScan final : public USkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Scan">();
	}
	static class UScan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScan>();
	}
};
static_assert(alignof(UScan) == 0x000008, "Wrong alignment on UScan");
static_assert(sizeof(UScan) == 0x000440, "Wrong size on UScan");

// Class SCT.SkillData
// 0x0008 (0x0108 - 0x0100)
class USkillData : public UPowerData
{
public:
	ECharacterInput                               InputBinding;                                      // 0x0100(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShown;                                           // 0x0101(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x6];                                      // 0x0102(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillData">();
	}
	static class USkillData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USkillData>();
	}
};
static_assert(alignof(USkillData) == 0x000008, "Wrong alignment on USkillData");
static_assert(sizeof(USkillData) == 0x000108, "Wrong size on USkillData");
static_assert(offsetof(USkillData, InputBinding) == 0x000100, "Member 'USkillData::InputBinding' has a wrong offset!");
static_assert(offsetof(USkillData, IsShown) == 0x000101, "Member 'USkillData::IsShown' has a wrong offset!");

// Class SCT.GetCloudDataCallbackProxy
// 0x0000 (0x0060 - 0x0060)
class UGetCloudDataCallbackProxy : public UCloudDataCallbackProxy
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetCloudDataCallbackProxy">();
	}
	static class UGetCloudDataCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetCloudDataCallbackProxy>();
	}
};
static_assert(alignof(UGetCloudDataCallbackProxy) == 0x000008, "Wrong alignment on UGetCloudDataCallbackProxy");
static_assert(sizeof(UGetCloudDataCallbackProxy) == 0x000060, "Wrong size on UGetCloudDataCallbackProxy");

// Class SCT.GetCloudStringDataCallbackProxy
// 0x0010 (0x0070 - 0x0060)
class UGetCloudStringDataCallbackProxy final : public UGetCloudDataCallbackProxy
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UGetCloudStringDataCallbackProxy* GetCloudRecordValue(EUserRecordType UserRecord, const class FString& FieldName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetCloudStringDataCallbackProxy">();
	}
	static class UGetCloudStringDataCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetCloudStringDataCallbackProxy>();
	}
};
static_assert(alignof(UGetCloudStringDataCallbackProxy) == 0x000008, "Wrong alignment on UGetCloudStringDataCallbackProxy");
static_assert(sizeof(UGetCloudStringDataCallbackProxy) == 0x000070, "Wrong size on UGetCloudStringDataCallbackProxy");
static_assert(offsetof(UGetCloudStringDataCallbackProxy, OnSuccess) == 0x000060, "Member 'UGetCloudStringDataCallbackProxy::OnSuccess' has a wrong offset!");

// Class SCT.ScanData
// 0x0000 (0x0108 - 0x0108)
class UScanData final : public USkillData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ScanData">();
	}
	static class UScanData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UScanData>();
	}
};
static_assert(alignof(UScanData) == 0x000008, "Wrong alignment on UScanData");
static_assert(sizeof(UScanData) == 0x000108, "Wrong size on UScanData");

// Class SCT.SCT_GIS
// 0x0018 (0x0048 - 0x0030)
class USCT_GIS final : public UGameInstanceSubsystem
{
public:
	class FString                                 AvatarNameLocal;                                   // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ServerTravels;                                     // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCT_GIS">();
	}
	static class USCT_GIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<USCT_GIS>();
	}
};
static_assert(alignof(USCT_GIS) == 0x000008, "Wrong alignment on USCT_GIS");
static_assert(sizeof(USCT_GIS) == 0x000048, "Wrong size on USCT_GIS");
static_assert(offsetof(USCT_GIS, AvatarNameLocal) == 0x000030, "Member 'USCT_GIS::AvatarNameLocal' has a wrong offset!");
static_assert(offsetof(USCT_GIS, ServerTravels) == 0x000040, "Member 'USCT_GIS::ServerTravels' has a wrong offset!");

// Class SCT.Tags
// 0x0000 (0x0028 - 0x0028)
class UTags final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tags">();
	}
	static class UTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTags>();
	}
};
static_assert(alignof(UTags) == 0x000008, "Wrong alignment on UTags");
static_assert(sizeof(UTags) == 0x000028, "Wrong size on UTags");

// Class SCT.SCT_HUD
// 0x0048 (0x0358 - 0x0310)
class ASCT_HUD : public AHUD
{
public:
	class UVivoxDiagnosticsComponent*             VivoxDiagnosticsComponent;                         // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   FocusBorderImageName;                              // 0x0318(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMargin                                FocusBorderMargin;                                 // 0x0320(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FSlateColor                            FocusBorderColor;                                  // 0x0330(0x0028)(Edit, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCT_HUD">();
	}
	static class ASCT_HUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCT_HUD>();
	}
};
static_assert(alignof(ASCT_HUD) == 0x000008, "Wrong alignment on ASCT_HUD");
static_assert(sizeof(ASCT_HUD) == 0x000358, "Wrong size on ASCT_HUD");
static_assert(offsetof(ASCT_HUD, VivoxDiagnosticsComponent) == 0x000310, "Member 'ASCT_HUD::VivoxDiagnosticsComponent' has a wrong offset!");
static_assert(offsetof(ASCT_HUD, FocusBorderImageName) == 0x000318, "Member 'ASCT_HUD::FocusBorderImageName' has a wrong offset!");
static_assert(offsetof(ASCT_HUD, FocusBorderMargin) == 0x000320, "Member 'ASCT_HUD::FocusBorderMargin' has a wrong offset!");
static_assert(offsetof(ASCT_HUD, FocusBorderColor) == 0x000330, "Member 'ASCT_HUD::FocusBorderColor' has a wrong offset!");

// Class SCT.SCTGameInstance
// 0x0120 (0x02C8 - 0x01A8)
class USCTGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_1A8[0x38];                                     // 0x01A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LevelsCompleted;                                   // 0x01E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PartyCount;                                        // 0x01E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InvalidUserCheckAttempts;                          // 0x01E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1EC[0x4];                                      // 0x01EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, int32>                    CachedInvalidSessionMembers;                       // 0x01F0(0x0050)(NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSaveControllerInitialLoadComplete;               // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSCTControllerTypeChanged;                        // 0x0250(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bConsolePlayerCommunicationRestricted;             // 0x0260(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_261[0x7];                                      // 0x0261(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnXboxUserLoggedOut;                               // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	ESCTControllerType                            LastControllerType;                                // 0x0278(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_279[0x7];                                      // 0x0279(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            ControllerDisconnectWidget;                        // 0x0280(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_288[0x40];                                     // 0x0288(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool DoPendingXboxLogin();
	int32 GetCurrentXboxControllerID();
	ESCTControllerType GetLastControllerType();
	bool HasPendingXboxLogin();
	void InitializeXboxUser();
	bool IsXboxUserLoggedIn();
	void K2_OnControllerConnectionStateChanged(bool Connected, int32 UserId, int32 ControllerId);
	void K2_OnXboxUserLoggedOut();
	void OnLevelRemovedFromWorld(class ULevel* InLevel, class UWorld* InWorld);
	void OpenFinalLevel();
	void OpenFirstLevel();
	void OpenIntermediateLevel(int32 Index_0);
	void SaveController_OnInitialLoadComplete();
	void UpdateControllerType(const struct FKey& LastKeyPressed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTGameInstance">();
	}
	static class USCTGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<USCTGameInstance>();
	}
};
static_assert(alignof(USCTGameInstance) == 0x000008, "Wrong alignment on USCTGameInstance");
static_assert(sizeof(USCTGameInstance) == 0x0002C8, "Wrong size on USCTGameInstance");
static_assert(offsetof(USCTGameInstance, LevelsCompleted) == 0x0001E0, "Member 'USCTGameInstance::LevelsCompleted' has a wrong offset!");
static_assert(offsetof(USCTGameInstance, PartyCount) == 0x0001E4, "Member 'USCTGameInstance::PartyCount' has a wrong offset!");
static_assert(offsetof(USCTGameInstance, InvalidUserCheckAttempts) == 0x0001E8, "Member 'USCTGameInstance::InvalidUserCheckAttempts' has a wrong offset!");
static_assert(offsetof(USCTGameInstance, CachedInvalidSessionMembers) == 0x0001F0, "Member 'USCTGameInstance::CachedInvalidSessionMembers' has a wrong offset!");
static_assert(offsetof(USCTGameInstance, OnSaveControllerInitialLoadComplete) == 0x000240, "Member 'USCTGameInstance::OnSaveControllerInitialLoadComplete' has a wrong offset!");
static_assert(offsetof(USCTGameInstance, OnSCTControllerTypeChanged) == 0x000250, "Member 'USCTGameInstance::OnSCTControllerTypeChanged' has a wrong offset!");
static_assert(offsetof(USCTGameInstance, bConsolePlayerCommunicationRestricted) == 0x000260, "Member 'USCTGameInstance::bConsolePlayerCommunicationRestricted' has a wrong offset!");
static_assert(offsetof(USCTGameInstance, OnXboxUserLoggedOut) == 0x000268, "Member 'USCTGameInstance::OnXboxUserLoggedOut' has a wrong offset!");
static_assert(offsetof(USCTGameInstance, LastControllerType) == 0x000278, "Member 'USCTGameInstance::LastControllerType' has a wrong offset!");
static_assert(offsetof(USCTGameInstance, ControllerDisconnectWidget) == 0x000280, "Member 'USCTGameInstance::ControllerDisconnectWidget' has a wrong offset!");

// Class SCT.SCTGameMode
// 0x0098 (0x03A0 - 0x0308)
class ASCTGameMode : public AGameMode
{
public:
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAllActivePlayersLoaded;                          // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         GracePeriodAfterAllLoaded;                         // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class ACharacterSCT>>      CharacterVariants;                                 // 0x0328(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TMap<int32, TSubclassOf<class ACharacterSCT>> PlayerIdToCharacterClassMap;                       // 0x0338(0x0050)(Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x18];                                     // 0x0388(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelGame();
	bool DisableEndConditionInDevelopment();
	void EndMatchWithCondition(EEndConditions EndCondition);
	TArray<class ASCTPlayerState*> GetAllAlivePersonoids();
	TArray<class ASCTPlayerState*> GetAllAlivePlayers();
	TArray<class ASCTPlayerState*> GetAllAliveResidents();
	TArray<class ASCTPlayerState*> GetAllDeadPlayers();
	TArray<class ASCTPlayerState*> GetAllPersonoids();
	TArray<class ASCTPlayerState*> GetAllResidents();
	void GiveScore(class FName ScoreName, class ASCTPlayerState* PlayerState);
	void K2_OnCharacterDestiny(class AHumanoidCharacter* HumanoidCharacter, class AController* Controller, const struct FDestiny& Destiny, bool IsPersonoid);
	void K2_ServerShutdownBegin();
	void OnCharacterDestiny(class AHumanoidCharacter* HumanoidCharacter, class AController* Controller, const struct FDestiny& Destiny, bool IsPersonoid);
	void OnReceivedGenderPreference(ECustomizationSavedGender GenderSettings, class ASCTPlayerController* PlayerController);
	void Respawn(int32 PlayerId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTGameMode">();
	}
	static class ASCTGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCTGameMode>();
	}
};
static_assert(alignof(ASCTGameMode) == 0x000008, "Wrong alignment on ASCTGameMode");
static_assert(sizeof(ASCTGameMode) == 0x0003A0, "Wrong size on ASCTGameMode");
static_assert(offsetof(ASCTGameMode, OnAllActivePlayersLoaded) == 0x000310, "Member 'ASCTGameMode::OnAllActivePlayersLoaded' has a wrong offset!");
static_assert(offsetof(ASCTGameMode, GracePeriodAfterAllLoaded) == 0x000320, "Member 'ASCTGameMode::GracePeriodAfterAllLoaded' has a wrong offset!");
static_assert(offsetof(ASCTGameMode, CharacterVariants) == 0x000328, "Member 'ASCTGameMode::CharacterVariants' has a wrong offset!");
static_assert(offsetof(ASCTGameMode, PlayerIdToCharacterClassMap) == 0x000338, "Member 'ASCTGameMode::PlayerIdToCharacterClassMap' has a wrong offset!");

// Class SCT.SCTGameMode_Match
// 0x00D0 (0x0470 - 0x03A0)
class ASCTGameMode_Match : public ASCTGameMode
{
public:
	FMulticastInlineDelegateProperty_             OnMatchBeginNotPIE;                                // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B0[0xC0];                                     // 0x03B0(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTGameMode_Match">();
	}
	static class ASCTGameMode_Match* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCTGameMode_Match>();
	}
};
static_assert(alignof(ASCTGameMode_Match) == 0x000008, "Wrong alignment on ASCTGameMode_Match");
static_assert(sizeof(ASCTGameMode_Match) == 0x000470, "Wrong size on ASCTGameMode_Match");
static_assert(offsetof(ASCTGameMode_Match, OnMatchBeginNotPIE) == 0x0003A0, "Member 'ASCTGameMode_Match::OnMatchBeginNotPIE' has a wrong offset!");

// Class SCT.SCTGameMode_Warmup
// 0x0028 (0x03C8 - 0x03A0)
class ASCTGameMode_Warmup final : public ASCTGameMode
{
public:
	float                                         CountdownAllJoinedTime;                            // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           CountdownAllJoinedHandle;                          // 0x03A8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          CountdownAllJoinedFinished;                        // 0x03B0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           SessionStillNotFullTimeoutHandle;                  // 0x03B8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SessionStillNotFullTimeoutTime;                    // 0x03C0(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveSessionStillNotFullTimeout();
	void SessionStillNotFullTimeout();
	void TravelToStartingArea();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTGameMode_Warmup">();
	}
	static class ASCTGameMode_Warmup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCTGameMode_Warmup>();
	}
};
static_assert(alignof(ASCTGameMode_Warmup) == 0x000008, "Wrong alignment on ASCTGameMode_Warmup");
static_assert(sizeof(ASCTGameMode_Warmup) == 0x0003C8, "Wrong size on ASCTGameMode_Warmup");
static_assert(offsetof(ASCTGameMode_Warmup, CountdownAllJoinedTime) == 0x0003A0, "Member 'ASCTGameMode_Warmup::CountdownAllJoinedTime' has a wrong offset!");
static_assert(offsetof(ASCTGameMode_Warmup, CountdownAllJoinedHandle) == 0x0003A8, "Member 'ASCTGameMode_Warmup::CountdownAllJoinedHandle' has a wrong offset!");
static_assert(offsetof(ASCTGameMode_Warmup, CountdownAllJoinedFinished) == 0x0003B0, "Member 'ASCTGameMode_Warmup::CountdownAllJoinedFinished' has a wrong offset!");
static_assert(offsetof(ASCTGameMode_Warmup, SessionStillNotFullTimeoutHandle) == 0x0003B8, "Member 'ASCTGameMode_Warmup::SessionStillNotFullTimeoutHandle' has a wrong offset!");
static_assert(offsetof(ASCTGameMode_Warmup, SessionStillNotFullTimeoutTime) == 0x0003C0, "Member 'ASCTGameMode_Warmup::SessionStillNotFullTimeoutTime' has a wrong offset!");

// Class SCT.SCTGameSession
// 0x0000 (0x0238 - 0x0238)
class ASCTGameSession final : public AGameSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTGameSession">();
	}
	static class ASCTGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCTGameSession>();
	}
};
static_assert(alignof(ASCTGameSession) == 0x000008, "Wrong alignment on ASCTGameSession");
static_assert(sizeof(ASCTGameSession) == 0x000238, "Wrong size on ASCTGameSession");

// Class SCT.SCTGameState
// 0x0098 (0x0328 - 0x0290)
class ASCTGameState : public AGameState
{
public:
	int32                                         NumPersonoids;                                     // 0x0290(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmergencyMeetingInProgress;                     // 0x0294(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_295[0x3];                                      // 0x0295(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UCustomGameSettingsComponent*           CustomGameSettingsComponent;                       // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimesHasTravelled;                                 // 0x02A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PS5MatchID;                                        // 0x02A8(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPS5MatchControllerClientStateData     PS5MatchControllerClientStateData;                 // 0x02B8(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	class FString                                 XboxGameSessionID;                                 // 0x02D8(0x0010)(Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FXboxGameSessionControllerClientStateData XboxGameSessionControllerClientStateData;          // 0x02E8(0x0020)(Net, RepNotify, NativeAccessSpecifierPrivate)
	TArray<class ASCTPlayerState*>                OnJoinedPlayerStateWaitingToReplicate;             // 0x0308(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           ReplicationValidationTimerHandle;                  // 0x0318(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckForReplicatedPlayerStates();
	void K2_OnMatchStarted();
	void MulticastOnFinishedChangingLevels();
	void MulticastOnStartingChangingLevels();
	void OnRep_PS5MatchControllerClientStateData();
	void OnRep_XboxGameSessionControllerClientStateData();
	void RemoveAllPassengerLogs();
	void SetEmergencyMeetingInProgress(bool InProgress);
	void SetPS5MatchControllerClientStateData(const struct FPS5MatchControllerClientStateData& InPS5MatchControllerClientStateData);
	void SetPS5MatchID(const class FString& InMatchID);
	void SetTimesHasTravelled(int32 TimesTravelled);
	void SetXboxGameSessionControllerClientStateData(const struct FXboxGameSessionControllerClientStateData& InXboxGameSessionControllerClientStateData);
	void SetXboxGameSessionID(const class FString& InGameSessionID);

	int32 GetNumberOfTimesHasTravelled() const;
	class FString GetPS5MatchID() const;
	class FString GetXboxGameSessionID() const;
	bool HasTravelledBefore() const;
	bool IsBackfillLevel() const;
	bool IsFirstLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTGameState">();
	}
	static class ASCTGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCTGameState>();
	}
};
static_assert(alignof(ASCTGameState) == 0x000008, "Wrong alignment on ASCTGameState");
static_assert(sizeof(ASCTGameState) == 0x000328, "Wrong size on ASCTGameState");
static_assert(offsetof(ASCTGameState, NumPersonoids) == 0x000290, "Member 'ASCTGameState::NumPersonoids' has a wrong offset!");
static_assert(offsetof(ASCTGameState, bIsEmergencyMeetingInProgress) == 0x000294, "Member 'ASCTGameState::bIsEmergencyMeetingInProgress' has a wrong offset!");
static_assert(offsetof(ASCTGameState, CustomGameSettingsComponent) == 0x000298, "Member 'ASCTGameState::CustomGameSettingsComponent' has a wrong offset!");
static_assert(offsetof(ASCTGameState, TimesHasTravelled) == 0x0002A0, "Member 'ASCTGameState::TimesHasTravelled' has a wrong offset!");
static_assert(offsetof(ASCTGameState, PS5MatchID) == 0x0002A8, "Member 'ASCTGameState::PS5MatchID' has a wrong offset!");
static_assert(offsetof(ASCTGameState, PS5MatchControllerClientStateData) == 0x0002B8, "Member 'ASCTGameState::PS5MatchControllerClientStateData' has a wrong offset!");
static_assert(offsetof(ASCTGameState, XboxGameSessionID) == 0x0002D8, "Member 'ASCTGameState::XboxGameSessionID' has a wrong offset!");
static_assert(offsetof(ASCTGameState, XboxGameSessionControllerClientStateData) == 0x0002E8, "Member 'ASCTGameState::XboxGameSessionControllerClientStateData' has a wrong offset!");
static_assert(offsetof(ASCTGameState, OnJoinedPlayerStateWaitingToReplicate) == 0x000308, "Member 'ASCTGameState::OnJoinedPlayerStateWaitingToReplicate' has a wrong offset!");
static_assert(offsetof(ASCTGameState, ReplicationValidationTimerHandle) == 0x000318, "Member 'ASCTGameState::ReplicationValidationTimerHandle' has a wrong offset!");

// Class SCT.SCTGameState_Match
// 0x0030 (0x0358 - 0x0328)
class ASCTGameState_Match : public ASCTGameState
{
public:
	FMulticastInlineDelegateProperty_             OnMatchEnded;                                      // 0x0328(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class ULevelVoteComponent*                    LevelVoteComponent;                                // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchEndData                          MatchEndData;                                      // 0x0340(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, Protected, NativeAccessSpecifierProtected)

public:
	void MatchEnded(const struct FMatchEndData& EndData);
	void OnRep_MatchEndData();
	void SetMatchEndState(const struct FMatchEndData& EndData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTGameState_Match">();
	}
	static class ASCTGameState_Match* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCTGameState_Match>();
	}
};
static_assert(alignof(ASCTGameState_Match) == 0x000008, "Wrong alignment on ASCTGameState_Match");
static_assert(sizeof(ASCTGameState_Match) == 0x000358, "Wrong size on ASCTGameState_Match");
static_assert(offsetof(ASCTGameState_Match, OnMatchEnded) == 0x000328, "Member 'ASCTGameState_Match::OnMatchEnded' has a wrong offset!");
static_assert(offsetof(ASCTGameState_Match, LevelVoteComponent) == 0x000338, "Member 'ASCTGameState_Match::LevelVoteComponent' has a wrong offset!");
static_assert(offsetof(ASCTGameState_Match, MatchEndData) == 0x000340, "Member 'ASCTGameState_Match::MatchEndData' has a wrong offset!");

// Class SCT.GetCloudIntDataCallbackProxy
// 0x0010 (0x0070 - 0x0060)
class UGetCloudIntDataCallbackProxy final : public UGetCloudDataCallbackProxy
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UGetCloudIntDataCallbackProxy* GetCloudRecordValue(EUserRecordType UserRecord, const class FString& FieldName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetCloudIntDataCallbackProxy">();
	}
	static class UGetCloudIntDataCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetCloudIntDataCallbackProxy>();
	}
};
static_assert(alignof(UGetCloudIntDataCallbackProxy) == 0x000008, "Wrong alignment on UGetCloudIntDataCallbackProxy");
static_assert(sizeof(UGetCloudIntDataCallbackProxy) == 0x000070, "Wrong size on UGetCloudIntDataCallbackProxy");
static_assert(offsetof(UGetCloudIntDataCallbackProxy, OnSuccess) == 0x000060, "Member 'UGetCloudIntDataCallbackProxy::OnSuccess' has a wrong offset!");

// Class SCT.SCTGameState_Warmup
// 0x0020 (0x0348 - 0x0328)
class ASCTGameState_Warmup final : public ASCTGameState
{
public:
	float                                         ServerStartTime;                                   // 0x0328(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsGameStarting;                                    // 0x032C(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32D[0x3];                                      // 0x032D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ClientGoodbyeCountdown;                            // 0x0330(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnGameStartCancelled;                              // 0x0338(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CancelStart();
	void DestroyAllCharacters();
	void OnCancelStart();
	void OnClientGoodbyeTick(int32 TimeLeft);
	void OnRep_ClientGoodbyeCountdown();
	void OnRep_ServerStartTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTGameState_Warmup">();
	}
	static class ASCTGameState_Warmup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCTGameState_Warmup>();
	}
};
static_assert(alignof(ASCTGameState_Warmup) == 0x000008, "Wrong alignment on ASCTGameState_Warmup");
static_assert(sizeof(ASCTGameState_Warmup) == 0x000348, "Wrong size on ASCTGameState_Warmup");
static_assert(offsetof(ASCTGameState_Warmup, ServerStartTime) == 0x000328, "Member 'ASCTGameState_Warmup::ServerStartTime' has a wrong offset!");
static_assert(offsetof(ASCTGameState_Warmup, IsGameStarting) == 0x00032C, "Member 'ASCTGameState_Warmup::IsGameStarting' has a wrong offset!");
static_assert(offsetof(ASCTGameState_Warmup, ClientGoodbyeCountdown) == 0x000330, "Member 'ASCTGameState_Warmup::ClientGoodbyeCountdown' has a wrong offset!");
static_assert(offsetof(ASCTGameState_Warmup, OnGameStartCancelled) == 0x000338, "Member 'ASCTGameState_Warmup::OnGameStartCancelled' has a wrong offset!");

// Class SCT.SCTGameUserSettings
// 0x0008 (0x0128 - 0x0120)
class USCTGameUserSettings final : public UGameUserSettings
{
public:
	float                                         MasterSoundVolume;                                 // 0x0120(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USCTGameUserSettings* GetSCTGameUserSettings();

	void ApplySoundSettings();
	float GetMasterSoundVolume();
	void SetMasterSoundVolume(float Volume);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTGameUserSettings">();
	}
	static class USCTGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<USCTGameUserSettings>();
	}
};
static_assert(alignof(USCTGameUserSettings) == 0x000008, "Wrong alignment on USCTGameUserSettings");
static_assert(sizeof(USCTGameUserSettings) == 0x000128, "Wrong size on USCTGameUserSettings");
static_assert(offsetof(USCTGameUserSettings, MasterSoundVolume) == 0x000120, "Member 'USCTGameUserSettings::MasterSoundVolume' has a wrong offset!");

// Class SCT.SCTKeySelector
// 0x0000 (0x0700 - 0x0700)
class USCTKeySelector : public UInputKeySelector
{
public:
	void SetActionMapping(const struct FInputChord& Chord);
	void SetGamepadStyle(const struct FInputChord& Chord);
	void SetKeyboardStyle(const struct FInputChord& Chord);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTKeySelector">();
	}
	static class USCTKeySelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<USCTKeySelector>();
	}
};
static_assert(alignof(USCTKeySelector) == 0x000008, "Wrong alignment on USCTKeySelector");
static_assert(sizeof(USCTKeySelector) == 0x000700, "Wrong size on USCTKeySelector");

// Class SCT.SCTKismetArrayLibrary
// 0x0000 (0x0028 - 0x0028)
class USCTKismetArrayLibrary final : public UKismetArrayLibrary
{
public:
	static void Array_ShuffleFromSeed(const TArray<int32>& TargetArray, int32 Seed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTKismetArrayLibrary">();
	}
	static class USCTKismetArrayLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<USCTKismetArrayLibrary>();
	}
};
static_assert(alignof(USCTKismetArrayLibrary) == 0x000008, "Wrong alignment on USCTKismetArrayLibrary");
static_assert(sizeof(USCTKismetArrayLibrary) == 0x000028, "Wrong size on USCTKismetArrayLibrary");

// Class SCT.SCTLoadingScreenWidget
// 0x0000 (0x0280 - 0x0280)
class USCTLoadingScreenWidget : public UWidgetSCT
{
public:
	void Start(const class FString& PendingURL);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTLoadingScreenWidget">();
	}
	static class USCTLoadingScreenWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USCTLoadingScreenWidget>();
	}
};
static_assert(alignof(USCTLoadingScreenWidget) == 0x000008, "Wrong alignment on USCTLoadingScreenWidget");
static_assert(sizeof(USCTLoadingScreenWidget) == 0x000280, "Wrong size on USCTLoadingScreenWidget");

// Class SCT.SCTLocalPlayer
// 0x0000 (0x0258 - 0x0258)
class USCTLocalPlayer final : public ULocalPlayer
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTLocalPlayer">();
	}
	static class USCTLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<USCTLocalPlayer>();
	}
};
static_assert(alignof(USCTLocalPlayer) == 0x000008, "Wrong alignment on USCTLocalPlayer");
static_assert(sizeof(USCTLocalPlayer) == 0x000258, "Wrong size on USCTLocalPlayer");

// Class SCT.GetUserPresenceStatusCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UGetUserPresenceStatusCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UGetUserPresenceStatusCallbackProxy* GetPresenceStatusByUserId(const class FString& UserId, class UAccelByteGIS* AccelByteGIS);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetUserPresenceStatusCallbackProxy">();
	}
	static class UGetUserPresenceStatusCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetUserPresenceStatusCallbackProxy>();
	}
};
static_assert(alignof(UGetUserPresenceStatusCallbackProxy) == 0x000008, "Wrong alignment on UGetUserPresenceStatusCallbackProxy");
static_assert(sizeof(UGetUserPresenceStatusCallbackProxy) == 0x000050, "Wrong size on UGetUserPresenceStatusCallbackProxy");
static_assert(offsetof(UGetUserPresenceStatusCallbackProxy, OnSuccess) == 0x000030, "Member 'UGetUserPresenceStatusCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UGetUserPresenceStatusCallbackProxy, OnError) == 0x000040, "Member 'UGetUserPresenceStatusCallbackProxy::OnError' has a wrong offset!");

// Class SCT.SCTPlayerController
// 0x00B8 (0x0628 - 0x0570)
class ASCTPlayerController : public APlayerController
{
public:
	uint8                                         Pad_570[0x8];                                      // 0x0570(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadSkillcheckValue;                            // 0x0578(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57C[0x4];                                      // 0x057C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPersonoidChatToggled;                            // 0x0580(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerStateReceived;                             // 0x0590(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerStateRemoved;                              // 0x05A0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UModal*                                 Modal;                                             // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USymbolPuzzleComponent*                 SymbolPuzzleComponent;                             // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAchievementComponent*                  AchievementComponent;                              // 0x05C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USkillcheckController*                  SkillcheckController;                              // 0x05C8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetOrganizer*                       WidgetOrganizer;                                   // 0x05D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x8];                                      // 0x05D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UVivoxNetworkComponent*                 VivoxNetworkComponent;                             // 0x05E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UVivoxInputComponent*                   VivoxInputComponent;                               // 0x05E8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPersonoidInformationComponent*         PersonoidInformationComponent;                     // 0x05F0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5F8[0x30];                                     // 0x05F8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AchievementGrantedError(const class FString& Message);
	void AchievementGrantedSucceeded(class UFCTAchievement* AchievementInfo, const class FString& Message);
	void ClientGetSessionID(const class FString& SessionID);
	void ClientOnGrantedPassengerLogInformation(const struct FPassengerLogInformation& LogInformation);
	void CloseVirtualKeyboard();
	void ForceDestroyLoadingScreen();
	void GrantAchievement(class FName AchievementName);
	void HandlePushToTalkSharedChannel(bool IsPressed);
	void K2_OnGrantedPassengerLogInformation(const struct FPassengerLogInformation& LogInformation);
	void K2_PreClientTravel(const class FString& PendingURL, ETravelType TravelType, bool bIsSeamlessTravel);
	void LeavePS5Match();
	void LeaveXboxGameSession();
	void OnSetUserCustomization();
	void OnSkillcheckGamepadAxis(float Val);
	void QuitToMainMenu(const class FText& Reason);
	void RunPS5GameStatsClientCommand(EPS5GameStatsClientCommand ClientCommand, const struct FPS5GameStatsCommandData& CommandData);
	void RunPS5MatchClientCommand(EPS5MatchClientCommand ClientCommand, const struct FPS5MatchCommandData& CommandData);
	void RunXboxGameSessionClientCommand(EXboxGameSessionClientCommand ClientCommand, const struct FXboxGameSessionCommandData& CommandData);
	void ServerPS5MatchCommand(EPS5MatchServerCommandResult CommandResult, const struct FPS5MatchCommandData& CommandData);
	void ServerSetAccelByteBlockingList(const TArray<class FString>& BlockedByAccelByteIDs);
	void ServerSetAccelByteBlockList(const TArray<class FString>& BlockedAccelByteIDs);
	void ServerSetAccelByteDisallowList(const TArray<class FString>& DisallowedAccelByteIDs);
	void ServerSetAccelByteID(const class FString& InAccelByteID);
	void ServerSetSonyBlockList(const TArray<class FString>& BlockedPSNIDs);
	void ServerSetSonyInfo(const class FString& PSNID, bool bInRunningOnPS5);
	void ServerSetSteamUserID(const class FString& UserId);
	void ServerSetXboxBlockList(const TArray<class FString>& BlockedXboxLiveIDs);
	void ServerSetXboxDisallowList(const TArray<class FString>& DisallowedXboxLiveIDs);
	void ServerSetXboxInfo(const class FString& XboxLiveID);
	void ServerXboxGameSessionCommand(EXboxGameSessionServerCommandResult CommandResult, const struct FXboxGameSessionCommandData& CommandData);
	void SetAirlockWidget(bool bIsVisible);
	void SetEmergencyWidget(bool bIsVisible);
	void SetMapVotingWidget(bool bIsVisible);
	void SetPawnAccelByteID();
	void SetPlayerListWidget(bool bIsVisible);
	void SetVOIPCommunication(bool Enable);
	void ToggleInGameMenu();

	class FString GetAccelbyteID() const;
	class UModal* GetModal() const;
	class USymbolPuzzleComponent* GetSymbolPuzzleComponent() const;
	class UWidgetOrganizer* GetWidgetOrganizer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTPlayerController">();
	}
	static class ASCTPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCTPlayerController>();
	}
};
static_assert(alignof(ASCTPlayerController) == 0x000008, "Wrong alignment on ASCTPlayerController");
static_assert(sizeof(ASCTPlayerController) == 0x000628, "Wrong size on ASCTPlayerController");
static_assert(offsetof(ASCTPlayerController, GamepadSkillcheckValue) == 0x000578, "Member 'ASCTPlayerController::GamepadSkillcheckValue' has a wrong offset!");
static_assert(offsetof(ASCTPlayerController, OnPersonoidChatToggled) == 0x000580, "Member 'ASCTPlayerController::OnPersonoidChatToggled' has a wrong offset!");
static_assert(offsetof(ASCTPlayerController, OnPlayerStateReceived) == 0x000590, "Member 'ASCTPlayerController::OnPlayerStateReceived' has a wrong offset!");
static_assert(offsetof(ASCTPlayerController, OnPlayerStateRemoved) == 0x0005A0, "Member 'ASCTPlayerController::OnPlayerStateRemoved' has a wrong offset!");
static_assert(offsetof(ASCTPlayerController, Modal) == 0x0005B0, "Member 'ASCTPlayerController::Modal' has a wrong offset!");
static_assert(offsetof(ASCTPlayerController, SymbolPuzzleComponent) == 0x0005B8, "Member 'ASCTPlayerController::SymbolPuzzleComponent' has a wrong offset!");
static_assert(offsetof(ASCTPlayerController, AchievementComponent) == 0x0005C0, "Member 'ASCTPlayerController::AchievementComponent' has a wrong offset!");
static_assert(offsetof(ASCTPlayerController, SkillcheckController) == 0x0005C8, "Member 'ASCTPlayerController::SkillcheckController' has a wrong offset!");
static_assert(offsetof(ASCTPlayerController, WidgetOrganizer) == 0x0005D0, "Member 'ASCTPlayerController::WidgetOrganizer' has a wrong offset!");
static_assert(offsetof(ASCTPlayerController, VivoxNetworkComponent) == 0x0005E0, "Member 'ASCTPlayerController::VivoxNetworkComponent' has a wrong offset!");
static_assert(offsetof(ASCTPlayerController, VivoxInputComponent) == 0x0005E8, "Member 'ASCTPlayerController::VivoxInputComponent' has a wrong offset!");
static_assert(offsetof(ASCTPlayerController, PersonoidInformationComponent) == 0x0005F0, "Member 'ASCTPlayerController::PersonoidInformationComponent' has a wrong offset!");

// Class SCT.SCTPlayerController_Match
// 0x0008 (0x0630 - 0x0628)
class ASCTPlayerController_Match : public ASCTPlayerController
{
public:
	bool                                          ShouldReinitializePlayerList;                      // 0x0628(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_629[0x7];                                      // 0x0629(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EndConsoleOnlineMode();
	void Server_ProxyVoteOnLevel(int32 LevelIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTPlayerController_Match">();
	}
	static class ASCTPlayerController_Match* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCTPlayerController_Match>();
	}
};
static_assert(alignof(ASCTPlayerController_Match) == 0x000008, "Wrong alignment on ASCTPlayerController_Match");
static_assert(sizeof(ASCTPlayerController_Match) == 0x000630, "Wrong size on ASCTPlayerController_Match");
static_assert(offsetof(ASCTPlayerController_Match, ShouldReinitializePlayerList) == 0x000628, "Member 'ASCTPlayerController_Match::ShouldReinitializePlayerList' has a wrong offset!");

// Class SCT.SCTPlayerController_Warmup
// 0x0000 (0x0628 - 0x0628)
class ASCTPlayerController_Warmup : public ASCTPlayerController
{
public:
	void Server_ApplyCustomGameSettings(const struct FCustomGameSettings& CustomSettings);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTPlayerController_Warmup">();
	}
	static class ASCTPlayerController_Warmup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCTPlayerController_Warmup>();
	}
};
static_assert(alignof(ASCTPlayerController_Warmup) == 0x000008, "Wrong alignment on ASCTPlayerController_Warmup");
static_assert(sizeof(ASCTPlayerController_Warmup) == 0x000628, "Wrong size on ASCTPlayerController_Warmup");

// Class SCT.SCTPlayerState
// 0x01D0 (0x04F0 - 0x0320)
class ASCTPlayerState : public APlayerState
{
public:
	FMulticastInlineDelegateProperty_             OnAnyVoteChanged;                                  // 0x0320(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUpvoteChanged;                                   // 0x0330(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDownvoteChanged;                                 // 0x0340(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPortraitChanged;                                 // 0x0350(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FLinearColor                           IdentificationColor;                               // 0x0360(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalUpVotes;                                      // 0x0370(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalDownVotes;                                    // 0x0374(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerFaction                                Faction;                                           // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EFate                                         Fate;                                              // 0x0379(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37A[0x6];                                      // 0x037A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SteamUserID;                                       // 0x0380(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PSNID;                                             // 0x0390(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRunningOnPS5;                                     // 0x03A0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 XboxLiveID;                                        // 0x03A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ABUserID;                                          // 0x03B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SessionID;                                         // 0x03C8(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPower>                     UniquePowerType;                                   // 0x03D8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFateChanged;                                     // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNameChanged;                                     // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerIdChanged;                                 // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UThumbsVoteInfoComponent*               ThumbsVoteInfoComponent;                           // 0x0410(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAgendaObjectState                            HiddenAgendaState;                                 // 0x0418(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_419[0x7];                                      // 0x0419(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 HiddenAgendaProgression;                           // 0x0420(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 HiddenAgendaDescription;                           // 0x0430(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPassengerLogInformation>       PassengerLogInfo;                                  // 0x0440(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	class FString                                 PlayerSessionId;                                   // 0x0450(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UVivoxTalkerComponent*                  VivoxTalkerComponentClient;                        // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         PSNIDsToBlock;                                     // 0x0468(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<class FString>                         BlockedByPSNIDs;                                   // 0x0478(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<class FString>                         XboxLiveIDsToBlock;                                // 0x0488(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<class FString>                         BlockedByXboxLiveIDs;                              // 0x0498(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<class FString>                         AccelByteIDsToBlock;                               // 0x04A8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<class FString>                         BlockedByAccelByteIDs;                             // 0x04B8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<class FString>                         DisallowedXboxLiveIDs;                             // 0x04C8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<class FString>                         DisallowedAccelByteIDs;                            // 0x04D8(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0x8];                                      // 0x04E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GrantPassengerLog(const struct FPassengerLogInformation& PassengerLogInformation);
	void K2_OnRep_ABUserID();
	void OnRep_ABUserID();
	void OnRep_AccelByteIDsToBlock();
	void OnRep_BlockedByAccelByteIDs();
	void OnRep_BlockedByPSNIDs();
	void OnRep_BlockedByXboxLiveIDs();
	void OnRep_DisallowedAccelByteIDs();
	void OnRep_DisallowedXboxLiveIDs();
	void OnRep_Fate();
	void OnRep_HiddenAgendaDescription();
	void OnRep_HiddenAgendaProgression();
	void OnRep_HiddenAgendaState();
	void OnRep_IdentificationColor();
	void OnRep_PassengerLogInfo();
	void OnRep_PSNID();
	void OnRep_PSNIDsToBlock();
	void OnRep_RunningOnPS5();
	void OnRep_SteamUserID();
	void OnRep_TotalDownVotes();
	void OnRep_TotalUpVotes();
	void OnRep_XboxLiveID();
	void OnRep_XboxLiveIDsToBlock();
	void RemoveAllPassengerLogs();

	struct FPassengerLogInformation GetLatestPassengerLog() const;
	int32 GetVoteSum() const;
	bool HasPassengerLog() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTPlayerState">();
	}
	static class ASCTPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCTPlayerState>();
	}
};
static_assert(alignof(ASCTPlayerState) == 0x000008, "Wrong alignment on ASCTPlayerState");
static_assert(sizeof(ASCTPlayerState) == 0x0004F0, "Wrong size on ASCTPlayerState");
static_assert(offsetof(ASCTPlayerState, OnAnyVoteChanged) == 0x000320, "Member 'ASCTPlayerState::OnAnyVoteChanged' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, OnUpvoteChanged) == 0x000330, "Member 'ASCTPlayerState::OnUpvoteChanged' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, OnDownvoteChanged) == 0x000340, "Member 'ASCTPlayerState::OnDownvoteChanged' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, OnPortraitChanged) == 0x000350, "Member 'ASCTPlayerState::OnPortraitChanged' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, IdentificationColor) == 0x000360, "Member 'ASCTPlayerState::IdentificationColor' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, TotalUpVotes) == 0x000370, "Member 'ASCTPlayerState::TotalUpVotes' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, TotalDownVotes) == 0x000374, "Member 'ASCTPlayerState::TotalDownVotes' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, Faction) == 0x000378, "Member 'ASCTPlayerState::Faction' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, Fate) == 0x000379, "Member 'ASCTPlayerState::Fate' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, SteamUserID) == 0x000380, "Member 'ASCTPlayerState::SteamUserID' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, PSNID) == 0x000390, "Member 'ASCTPlayerState::PSNID' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, bRunningOnPS5) == 0x0003A0, "Member 'ASCTPlayerState::bRunningOnPS5' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, XboxLiveID) == 0x0003A8, "Member 'ASCTPlayerState::XboxLiveID' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, ABUserID) == 0x0003B8, "Member 'ASCTPlayerState::ABUserID' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, SessionID) == 0x0003C8, "Member 'ASCTPlayerState::SessionID' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, UniquePowerType) == 0x0003D8, "Member 'ASCTPlayerState::UniquePowerType' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, OnFateChanged) == 0x0003E0, "Member 'ASCTPlayerState::OnFateChanged' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, OnNameChanged) == 0x0003F0, "Member 'ASCTPlayerState::OnNameChanged' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, OnPlayerIdChanged) == 0x000400, "Member 'ASCTPlayerState::OnPlayerIdChanged' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, ThumbsVoteInfoComponent) == 0x000410, "Member 'ASCTPlayerState::ThumbsVoteInfoComponent' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, HiddenAgendaState) == 0x000418, "Member 'ASCTPlayerState::HiddenAgendaState' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, HiddenAgendaProgression) == 0x000420, "Member 'ASCTPlayerState::HiddenAgendaProgression' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, HiddenAgendaDescription) == 0x000430, "Member 'ASCTPlayerState::HiddenAgendaDescription' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, PassengerLogInfo) == 0x000440, "Member 'ASCTPlayerState::PassengerLogInfo' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, PlayerSessionId) == 0x000450, "Member 'ASCTPlayerState::PlayerSessionId' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, VivoxTalkerComponentClient) == 0x000460, "Member 'ASCTPlayerState::VivoxTalkerComponentClient' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, PSNIDsToBlock) == 0x000468, "Member 'ASCTPlayerState::PSNIDsToBlock' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, BlockedByPSNIDs) == 0x000478, "Member 'ASCTPlayerState::BlockedByPSNIDs' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, XboxLiveIDsToBlock) == 0x000488, "Member 'ASCTPlayerState::XboxLiveIDsToBlock' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, BlockedByXboxLiveIDs) == 0x000498, "Member 'ASCTPlayerState::BlockedByXboxLiveIDs' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, AccelByteIDsToBlock) == 0x0004A8, "Member 'ASCTPlayerState::AccelByteIDsToBlock' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, BlockedByAccelByteIDs) == 0x0004B8, "Member 'ASCTPlayerState::BlockedByAccelByteIDs' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, DisallowedXboxLiveIDs) == 0x0004C8, "Member 'ASCTPlayerState::DisallowedXboxLiveIDs' has a wrong offset!");
static_assert(offsetof(ASCTPlayerState, DisallowedAccelByteIDs) == 0x0004D8, "Member 'ASCTPlayerState::DisallowedAccelByteIDs' has a wrong offset!");

// Class SCT.SCTPlayerState_Match
// 0x0000 (0x04F0 - 0x04F0)
class ASCTPlayerState_Match : public ASCTPlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTPlayerState_Match">();
	}
	static class ASCTPlayerState_Match* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCTPlayerState_Match>();
	}
};
static_assert(alignof(ASCTPlayerState_Match) == 0x000008, "Wrong alignment on ASCTPlayerState_Match");
static_assert(sizeof(ASCTPlayerState_Match) == 0x0004F0, "Wrong size on ASCTPlayerState_Match");

// Class SCT.SCTPlayerState_Warmup
// 0x0000 (0x04F0 - 0x04F0)
class ASCTPlayerState_Warmup final : public ASCTPlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTPlayerState_Warmup">();
	}
	static class ASCTPlayerState_Warmup* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASCTPlayerState_Warmup>();
	}
};
static_assert(alignof(ASCTPlayerState_Warmup) == 0x000008, "Wrong alignment on ASCTPlayerState_Warmup");
static_assert(sizeof(ASCTPlayerState_Warmup) == 0x0004F0, "Wrong size on ASCTPlayerState_Warmup");

// Class SCT.SCTSaveSlot
// 0x0018 (0x0040 - 0x0028)
class USCTSaveSlot : public USaveGame
{
public:
	TArray<class FString>                         PS5MatchIDs;                                       // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHasStartedPS5Match;                               // 0x0038(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTSaveSlot">();
	}
	static class USCTSaveSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<USCTSaveSlot>();
	}
};
static_assert(alignof(USCTSaveSlot) == 0x000008, "Wrong alignment on USCTSaveSlot");
static_assert(sizeof(USCTSaveSlot) == 0x000040, "Wrong size on USCTSaveSlot");
static_assert(offsetof(USCTSaveSlot, PS5MatchIDs) == 0x000028, "Member 'USCTSaveSlot::PS5MatchIDs' has a wrong offset!");
static_assert(offsetof(USCTSaveSlot, bHasStartedPS5Match) == 0x000038, "Member 'USCTSaveSlot::bHasStartedPS5Match' has a wrong offset!");

// Class SCT.SCTWidgetComponent
// 0x0000 (0x0590 - 0x0590)
class USCTWidgetComponent : public UWidgetComponent
{
public:
	void K2_InitWidget(class UWidget* InitializedWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SCTWidgetComponent">();
	}
	static class USCTWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<USCTWidgetComponent>();
	}
};
static_assert(alignof(USCTWidgetComponent) == 0x000010, "Wrong alignment on USCTWidgetComponent");
static_assert(sizeof(USCTWidgetComponent) == 0x000590, "Wrong size on USCTWidgetComponent");

// Class SCT.SecondaryInteractionSkill
// 0x0000 (0x0440 - 0x0440)
class USecondaryInteractionSkill : public UGenericInteractionSkill
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SecondaryInteractionSkill">();
	}
	static class USecondaryInteractionSkill* GetDefaultObj()
	{
		return GetDefaultObjImpl<USecondaryInteractionSkill>();
	}
};
static_assert(alignof(USecondaryInteractionSkill) == 0x000008, "Wrong alignment on USecondaryInteractionSkill");
static_assert(sizeof(USecondaryInteractionSkill) == 0x000440, "Wrong size on USecondaryInteractionSkill");

// Class SCT.SettingsObject
// 0x0070 (0x0098 - 0x0028)
class USettingsObject : public USaveGame
{
public:
	class FString                                 SlotName;                                          // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStateChanged;                                    // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<class FName, struct FInputInformationFloatSlider> FloatSliderEntries;                                // 0x0048(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void Apply();
	void K2_Apply();
	void K2_Loaded();
	void K2_Revert(const class USettingsObject* CachedData);
	void Reset();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SettingsObject">();
	}
	static class USettingsObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<USettingsObject>();
	}
};
static_assert(alignof(USettingsObject) == 0x000008, "Wrong alignment on USettingsObject");
static_assert(sizeof(USettingsObject) == 0x000098, "Wrong size on USettingsObject");
static_assert(offsetof(USettingsObject, SlotName) == 0x000028, "Member 'USettingsObject::SlotName' has a wrong offset!");
static_assert(offsetof(USettingsObject, OnStateChanged) == 0x000038, "Member 'USettingsObject::OnStateChanged' has a wrong offset!");
static_assert(offsetof(USettingsObject, FloatSliderEntries) == 0x000048, "Member 'USettingsObject::FloatSliderEntries' has a wrong offset!");

// Class SCT.SkillcheckManager
// 0x0028 (0x0248 - 0x0220)
class ASkillcheckManager final : public AActor
{
public:
	int32                                         WavesToComplete;                                   // 0x0220(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USkillcheckController*>          AllInteractors;                                    // 0x0228(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	ESkillcheckEndCondition                       EndCondition;                                      // 0x0238(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_239[0x3];                                      // 0x0239(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TargetInteractors;                                 // 0x023C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SkillcheckManager">();
	}
	static class ASkillcheckManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASkillcheckManager>();
	}
};
static_assert(alignof(ASkillcheckManager) == 0x000008, "Wrong alignment on ASkillcheckManager");
static_assert(sizeof(ASkillcheckManager) == 0x000248, "Wrong size on ASkillcheckManager");
static_assert(offsetof(ASkillcheckManager, WavesToComplete) == 0x000220, "Member 'ASkillcheckManager::WavesToComplete' has a wrong offset!");
static_assert(offsetof(ASkillcheckManager, AllInteractors) == 0x000228, "Member 'ASkillcheckManager::AllInteractors' has a wrong offset!");
static_assert(offsetof(ASkillcheckManager, EndCondition) == 0x000238, "Member 'ASkillcheckManager::EndCondition' has a wrong offset!");
static_assert(offsetof(ASkillcheckManager, TargetInteractors) == 0x00023C, "Member 'ASkillcheckManager::TargetInteractors' has a wrong offset!");

// Class SCT.StartingLevelChangeEvent
// 0x0000 (0x0040 - 0x0040)
class UStartingLevelChangeEvent final : public UGlobalEventVoid
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StartingLevelChangeEvent">();
	}
	static class UStartingLevelChangeEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStartingLevelChangeEvent>();
	}
};
static_assert(alignof(UStartingLevelChangeEvent) == 0x000008, "Wrong alignment on UStartingLevelChangeEvent");
static_assert(sizeof(UStartingLevelChangeEvent) == 0x000040, "Wrong size on UStartingLevelChangeEvent");

// Class SCT.SteamUserIDChanged
// 0x0010 (0x0040 - 0x0030)
class USteamUserIDChanged final : public UGlobalEvent
{
public:
	FMulticastInlineDelegateProperty_             Event;                                             // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void Broadcast(const class FString& SteamID, int32 PlayerId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SteamUserIDChanged">();
	}
	static class USteamUserIDChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<USteamUserIDChanged>();
	}
};
static_assert(alignof(USteamUserIDChanged) == 0x000008, "Wrong alignment on USteamUserIDChanged");
static_assert(sizeof(USteamUserIDChanged) == 0x000040, "Wrong size on USteamUserIDChanged");
static_assert(offsetof(USteamUserIDChanged, Event) == 0x000030, "Member 'USteamUserIDChanged::Event' has a wrong offset!");

// Class SCT.SubMenuUserWidget
// 0x0020 (0x02D0 - 0x02B0)
class USubMenuUserWidget : public UControllerIconWidget
{
public:
	class UHorizontalBox*                         MenubarHzBox;                                      // 0x02B0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B8[0x10];                                     // 0x02B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class USubMenuSelectionButtonUserWidget> SubMenuClass;                                      // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class USubMenuSelectionButtonUserWidget* AddMenuItemWithEvent(const class FText& Title, const TDelegate<void()>& InOnPressed, float Width);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubMenuUserWidget">();
	}
	static class USubMenuUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubMenuUserWidget>();
	}
};
static_assert(alignof(USubMenuUserWidget) == 0x000008, "Wrong alignment on USubMenuUserWidget");
static_assert(sizeof(USubMenuUserWidget) == 0x0002D0, "Wrong size on USubMenuUserWidget");
static_assert(offsetof(USubMenuUserWidget, MenubarHzBox) == 0x0002B0, "Member 'USubMenuUserWidget::MenubarHzBox' has a wrong offset!");
static_assert(offsetof(USubMenuUserWidget, SubMenuClass) == 0x0002C8, "Member 'USubMenuUserWidget::SubMenuClass' has a wrong offset!");

// Class SCT.SymbolPuzzleWidget
// 0x0010 (0x0290 - 0x0280)
class USymbolPuzzleWidget final : public UWidgetSCT
{
public:
	uint8                                         Pad_280[0x10];                                     // 0x0280(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceivedSeed(int32 Seed);
	void SymbolSelected(int32 Index_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SymbolPuzzleWidget">();
	}
	static class USymbolPuzzleWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USymbolPuzzleWidget>();
	}
};
static_assert(alignof(USymbolPuzzleWidget) == 0x000008, "Wrong alignment on USymbolPuzzleWidget");
static_assert(sizeof(USymbolPuzzleWidget) == 0x000290, "Wrong size on USymbolPuzzleWidget");

// Class SCT.SyringeData
// 0x0000 (0x0108 - 0x0108)
class USyringeData final : public UItemData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SyringeData">();
	}
	static class USyringeData* GetDefaultObj()
	{
		return GetDefaultObjImpl<USyringeData>();
	}
};
static_assert(alignof(USyringeData) == 0x000008, "Wrong alignment on USyringeData");
static_assert(sizeof(USyringeData) == 0x000108, "Wrong size on USyringeData");

// Class SCT.ThumbsVoteInfoComponent
// 0x0098 (0x0148 - 0x00B0)
class UThumbsVoteInfoComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnAllVotedUpReplicated;                            // 0x00B0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTotalUpVotesReplicated;                          // 0x00C0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAllVotedDownReplicated;                          // 0x00D0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTotalDownVotesReplicated;                        // 0x00E0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<int32>                                 AllVotedUp;                                        // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 AllVotedDown;                                      // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 CachedDownVotes;                                   // 0x0110(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 CachedUpVotes;                                     // 0x0120(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 CachedRemovedVotes;                                // 0x0130(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           ReplicationTimerHandle;                            // 0x0140(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void DownVote(int32 PlayerId);
	void RemoveVotes(int32 Player);
	void ReplicateToServer();
	void Server_SetVotes(const TArray<int32>& RemovedVotes, const TArray<int32>& UpVotes, const TArray<int32>& DownVotes);
	void UpVote(int32 PlayerId);

	TArray<class UThumbsVoteInfoComponent*> GetAllOtherThumbsVoteComponents() const;
	int32 GetOwnerPlayerID() const;
	bool HasDownvotedPlayer(int32 Player) const;
	bool HasUpvotedPlayer(int32 Player) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ThumbsVoteInfoComponent">();
	}
	static class UThumbsVoteInfoComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UThumbsVoteInfoComponent>();
	}
};
static_assert(alignof(UThumbsVoteInfoComponent) == 0x000008, "Wrong alignment on UThumbsVoteInfoComponent");
static_assert(sizeof(UThumbsVoteInfoComponent) == 0x000148, "Wrong size on UThumbsVoteInfoComponent");
static_assert(offsetof(UThumbsVoteInfoComponent, OnAllVotedUpReplicated) == 0x0000B0, "Member 'UThumbsVoteInfoComponent::OnAllVotedUpReplicated' has a wrong offset!");
static_assert(offsetof(UThumbsVoteInfoComponent, OnTotalUpVotesReplicated) == 0x0000C0, "Member 'UThumbsVoteInfoComponent::OnTotalUpVotesReplicated' has a wrong offset!");
static_assert(offsetof(UThumbsVoteInfoComponent, OnAllVotedDownReplicated) == 0x0000D0, "Member 'UThumbsVoteInfoComponent::OnAllVotedDownReplicated' has a wrong offset!");
static_assert(offsetof(UThumbsVoteInfoComponent, OnTotalDownVotesReplicated) == 0x0000E0, "Member 'UThumbsVoteInfoComponent::OnTotalDownVotesReplicated' has a wrong offset!");
static_assert(offsetof(UThumbsVoteInfoComponent, AllVotedUp) == 0x0000F0, "Member 'UThumbsVoteInfoComponent::AllVotedUp' has a wrong offset!");
static_assert(offsetof(UThumbsVoteInfoComponent, AllVotedDown) == 0x000100, "Member 'UThumbsVoteInfoComponent::AllVotedDown' has a wrong offset!");
static_assert(offsetof(UThumbsVoteInfoComponent, CachedDownVotes) == 0x000110, "Member 'UThumbsVoteInfoComponent::CachedDownVotes' has a wrong offset!");
static_assert(offsetof(UThumbsVoteInfoComponent, CachedUpVotes) == 0x000120, "Member 'UThumbsVoteInfoComponent::CachedUpVotes' has a wrong offset!");
static_assert(offsetof(UThumbsVoteInfoComponent, CachedRemovedVotes) == 0x000130, "Member 'UThumbsVoteInfoComponent::CachedRemovedVotes' has a wrong offset!");
static_assert(offsetof(UThumbsVoteInfoComponent, ReplicationTimerHandle) == 0x000140, "Member 'UThumbsVoteInfoComponent::ReplicationTimerHandle' has a wrong offset!");

// Class SCT.UserDataCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UUserDataCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UUserDataCallbackProxy* GetUserData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserDataCallbackProxy">();
	}
	static class UUserDataCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserDataCallbackProxy>();
	}
};
static_assert(alignof(UUserDataCallbackProxy) == 0x000008, "Wrong alignment on UUserDataCallbackProxy");
static_assert(sizeof(UUserDataCallbackProxy) == 0x000050, "Wrong size on UUserDataCallbackProxy");
static_assert(offsetof(UUserDataCallbackProxy, OnSuccess) == 0x000030, "Member 'UUserDataCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UUserDataCallbackProxy, OnError) == 0x000040, "Member 'UUserDataCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTAuthUpdateUserCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UFCTAuthUpdateUserCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UFCTAuthUpdateUserCallbackProxy* UpdateUser(const class FString& DisplayName, const class FString& BirthDate, const class FString& Email);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTAuthUpdateUserCallbackProxy">();
	}
	static class UFCTAuthUpdateUserCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTAuthUpdateUserCallbackProxy>();
	}
};
static_assert(alignof(UFCTAuthUpdateUserCallbackProxy) == 0x000008, "Wrong alignment on UFCTAuthUpdateUserCallbackProxy");
static_assert(sizeof(UFCTAuthUpdateUserCallbackProxy) == 0x000050, "Wrong size on UFCTAuthUpdateUserCallbackProxy");
static_assert(offsetof(UFCTAuthUpdateUserCallbackProxy, OnSuccess) == 0x000030, "Member 'UFCTAuthUpdateUserCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UFCTAuthUpdateUserCallbackProxy, OnError) == 0x000040, "Member 'UFCTAuthUpdateUserCallbackProxy::OnError' has a wrong offset!");

// Class SCT.GetCloudFloatDataCallbackProxy
// 0x0010 (0x0070 - 0x0060)
class UGetCloudFloatDataCallbackProxy final : public UGetCloudDataCallbackProxy
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UGetCloudFloatDataCallbackProxy* GetCloudRecordValue(EUserRecordType UserRecord, const class FString& FieldName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetCloudFloatDataCallbackProxy">();
	}
	static class UGetCloudFloatDataCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetCloudFloatDataCallbackProxy>();
	}
};
static_assert(alignof(UGetCloudFloatDataCallbackProxy) == 0x000008, "Wrong alignment on UGetCloudFloatDataCallbackProxy");
static_assert(sizeof(UGetCloudFloatDataCallbackProxy) == 0x000070, "Wrong size on UGetCloudFloatDataCallbackProxy");
static_assert(offsetof(UGetCloudFloatDataCallbackProxy, OnSuccess) == 0x000060, "Member 'UGetCloudFloatDataCallbackProxy::OnSuccess' has a wrong offset!");

// Class SCT.SetCloudFloatDataCallbackProxy
// 0x0008 (0x0088 - 0x0080)
class USetCloudFloatDataCallbackProxy final : public USetCloudDataCallbackProxy
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class USetCloudFloatDataCallbackProxy* SetCloudRecordValue(EUserRecordType UserRecord, const class FString& FieldName, const float AddValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SetCloudFloatDataCallbackProxy">();
	}
	static class USetCloudFloatDataCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<USetCloudFloatDataCallbackProxy>();
	}
};
static_assert(alignof(USetCloudFloatDataCallbackProxy) == 0x000008, "Wrong alignment on USetCloudFloatDataCallbackProxy");
static_assert(sizeof(USetCloudFloatDataCallbackProxy) == 0x000088, "Wrong size on USetCloudFloatDataCallbackProxy");

// Class SCT.CloudCustomizationDataCallbackProxy
// 0x0020 (0x0050 - 0x0030)
class UCloudCustomizationDataCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UCloudCustomizationDataCallbackProxy* GetPublicUserCustomizationRecordByGender(const class FString& UserId, bool Male);
	static class UCloudCustomizationDataCallbackProxy* GetPublicUserCustomizationRecordBySelectedGender(const class FString& UserId);
	static class UCloudCustomizationDataCallbackProxy* GetUserCustomizationRecordByGender(bool Male);
	static class UCloudCustomizationDataCallbackProxy* GetUserCustomizationRecordBySelectedGender();
	static class UCloudCustomizationDataCallbackProxy* SetUserCustomizationRecord(const struct FCloudCustomizationPayload& MalePayload, const struct FCloudCustomizationPayload& FemalePayload, bool MaleIsSelected);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CloudCustomizationDataCallbackProxy">();
	}
	static class UCloudCustomizationDataCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCloudCustomizationDataCallbackProxy>();
	}
};
static_assert(alignof(UCloudCustomizationDataCallbackProxy) == 0x000008, "Wrong alignment on UCloudCustomizationDataCallbackProxy");
static_assert(sizeof(UCloudCustomizationDataCallbackProxy) == 0x000050, "Wrong size on UCloudCustomizationDataCallbackProxy");
static_assert(offsetof(UCloudCustomizationDataCallbackProxy, OnSuccess) == 0x000030, "Member 'UCloudCustomizationDataCallbackProxy::OnSuccess' has a wrong offset!");
static_assert(offsetof(UCloudCustomizationDataCallbackProxy, OnError) == 0x000040, "Member 'UCloudCustomizationDataCallbackProxy::OnError' has a wrong offset!");

// Class SCT.FCTUpdateUserProfileCustomAttributesCallbackProxy
// 0x0018 (0x0048 - 0x0030)
class UFCTUpdateUserProfileCustomAttributesCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnComplete;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFCTUpdateUserProfileCustomAttributesCallbackProxy* UpdateUserProfileCustomAttributes(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FCTUpdateUserProfileCustomAttributesCallbackProxy">();
	}
	static class UFCTUpdateUserProfileCustomAttributesCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFCTUpdateUserProfileCustomAttributesCallbackProxy>();
	}
};
static_assert(alignof(UFCTUpdateUserProfileCustomAttributesCallbackProxy) == 0x000008, "Wrong alignment on UFCTUpdateUserProfileCustomAttributesCallbackProxy");
static_assert(sizeof(UFCTUpdateUserProfileCustomAttributesCallbackProxy) == 0x000048, "Wrong size on UFCTUpdateUserProfileCustomAttributesCallbackProxy");
static_assert(offsetof(UFCTUpdateUserProfileCustomAttributesCallbackProxy, OnComplete) == 0x000030, "Member 'UFCTUpdateUserProfileCustomAttributesCallbackProxy::OnComplete' has a wrong offset!");

// Class SCT.UserInputSettings
// 0x01B0 (0x0248 - 0x0098)
class UUserInputSettings : public USettingsObject
{
public:
	TMap<class FName, struct FInputSavedAction>   SavedActions;                                      // 0x0098(0x0050)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, struct FInputSavedAxis>     SavedAxes;                                         // 0x00E8(0x0050)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, bool>                       SavedToggles;                                      // 0x0138(0x0050)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, float>                      SavedFloats;                                       // 0x0188(0x0050)(BlueprintVisible, BlueprintReadOnly, SaveGame, NativeAccessSpecifierPublic)
	TMap<class FName, struct FCachedInput>        CachedInput;                                       // 0x01D8(0x0050)(Transient, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UInputSettingsSubComponent>> SubComponentTypes;                                 // 0x0228(0x0010)(Edit, ZeroConstructor, Transient, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class UInputSettingsSubComponent*>     SubComponents;                                     // 0x0238(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	float GetFloatValue(const class FName& InfoKey, float FallbackValue);
	class UInputSettingsSubComponent* GetSubComponent(TSubclassOf<class UInputSettingsSubComponent> SubComponentType);
	void SetFloatValue(const class FName& InfoKey, float NewValue);

	bool IsKeyBound(const class FName& Name_0, const struct FInputChord& Key) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UserInputSettings">();
	}
	static class UUserInputSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUserInputSettings>();
	}
};
static_assert(alignof(UUserInputSettings) == 0x000008, "Wrong alignment on UUserInputSettings");
static_assert(sizeof(UUserInputSettings) == 0x000248, "Wrong size on UUserInputSettings");
static_assert(offsetof(UUserInputSettings, SavedActions) == 0x000098, "Member 'UUserInputSettings::SavedActions' has a wrong offset!");
static_assert(offsetof(UUserInputSettings, SavedAxes) == 0x0000E8, "Member 'UUserInputSettings::SavedAxes' has a wrong offset!");
static_assert(offsetof(UUserInputSettings, SavedToggles) == 0x000138, "Member 'UUserInputSettings::SavedToggles' has a wrong offset!");
static_assert(offsetof(UUserInputSettings, SavedFloats) == 0x000188, "Member 'UUserInputSettings::SavedFloats' has a wrong offset!");
static_assert(offsetof(UUserInputSettings, CachedInput) == 0x0001D8, "Member 'UUserInputSettings::CachedInput' has a wrong offset!");
static_assert(offsetof(UUserInputSettings, SubComponentTypes) == 0x000228, "Member 'UUserInputSettings::SubComponentTypes' has a wrong offset!");
static_assert(offsetof(UUserInputSettings, SubComponents) == 0x000238, "Member 'UUserInputSettings::SubComponents' has a wrong offset!");

// Class SCT.WetnessAttributeSet
// 0x0030 (0x0060 - 0x0030)
class UWetnessAttributeSet final : public UAttributeSet
{
public:
	FMulticastInlineDelegateProperty_             OnWetnessChanged;                                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Wetness;                                           // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxWetness;                                        // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_MaxWetness();
	void OnRep_Wetness();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WetnessAttributeSet">();
	}
	static class UWetnessAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWetnessAttributeSet>();
	}
};
static_assert(alignof(UWetnessAttributeSet) == 0x000008, "Wrong alignment on UWetnessAttributeSet");
static_assert(sizeof(UWetnessAttributeSet) == 0x000060, "Wrong size on UWetnessAttributeSet");
static_assert(offsetof(UWetnessAttributeSet, OnWetnessChanged) == 0x000030, "Member 'UWetnessAttributeSet::OnWetnessChanged' has a wrong offset!");
static_assert(offsetof(UWetnessAttributeSet, Wetness) == 0x000040, "Member 'UWetnessAttributeSet::Wetness' has a wrong offset!");
static_assert(offsetof(UWetnessAttributeSet, MaxWetness) == 0x000050, "Member 'UWetnessAttributeSet::MaxWetness' has a wrong offset!");

// Class SCT.WorldSettingsSCT
// 0x0020 (0x03C0 - 0x03A0)
class AWorldSettingsSCT final : public AWorldSettings
{
public:
	float                                         OxygenLevel;                                       // 0x03A0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeUntilFullyDrained;                             // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StartOxygenPercentage;                             // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         TicksPerSecond;                                    // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisableDeaths;                                    // 0x03B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomSettingsOxygenMultiplier;                    // 0x03B4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UOxygenChangedEvent>     CachedOxygenChangedEvent;                          // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_OxygenLevel();
	void OxygenTick();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSettingsSCT">();
	}
	static class AWorldSettingsSCT* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldSettingsSCT>();
	}
};
static_assert(alignof(AWorldSettingsSCT) == 0x000008, "Wrong alignment on AWorldSettingsSCT");
static_assert(sizeof(AWorldSettingsSCT) == 0x0003C0, "Wrong size on AWorldSettingsSCT");
static_assert(offsetof(AWorldSettingsSCT, OxygenLevel) == 0x0003A0, "Member 'AWorldSettingsSCT::OxygenLevel' has a wrong offset!");
static_assert(offsetof(AWorldSettingsSCT, TimeUntilFullyDrained) == 0x0003A4, "Member 'AWorldSettingsSCT::TimeUntilFullyDrained' has a wrong offset!");
static_assert(offsetof(AWorldSettingsSCT, StartOxygenPercentage) == 0x0003A8, "Member 'AWorldSettingsSCT::StartOxygenPercentage' has a wrong offset!");
static_assert(offsetof(AWorldSettingsSCT, TicksPerSecond) == 0x0003AC, "Member 'AWorldSettingsSCT::TicksPerSecond' has a wrong offset!");
static_assert(offsetof(AWorldSettingsSCT, bDisableDeaths) == 0x0003B0, "Member 'AWorldSettingsSCT::bDisableDeaths' has a wrong offset!");
static_assert(offsetof(AWorldSettingsSCT, CustomSettingsOxygenMultiplier) == 0x0003B4, "Member 'AWorldSettingsSCT::CustomSettingsOxygenMultiplier' has a wrong offset!");
static_assert(offsetof(AWorldSettingsSCT, CachedOxygenChangedEvent) == 0x0003B8, "Member 'AWorldSettingsSCT::CachedOxygenChangedEvent' has a wrong offset!");

// Class SCT.XboxLoginWidget
// 0x0018 (0x0278 - 0x0260)
class UXboxLoginWidget : public UUserWidget
{
public:
	uint8                                         Pad_260[0x18];                                     // 0x0260(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnButtonAPressed();
	void OnLoginFailure();
	void OnLoginSuccess();
	void WaitForButtonPress();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XboxLoginWidget">();
	}
	static class UXboxLoginWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXboxLoginWidget>();
	}
};
static_assert(alignof(UXboxLoginWidget) == 0x000008, "Wrong alignment on UXboxLoginWidget");
static_assert(sizeof(UXboxLoginWidget) == 0x000278, "Wrong size on UXboxLoginWidget");

// Class SCT.XboxUserPrivilegeCheckData
// 0x0040 (0x0068 - 0x0028)
class UXboxUserPrivilegeCheckData final : public UObject
{
public:
	uint8                                         Pad_28[0x30];                                      // 0x0028(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UXboxUserPrivilegeCheckTargetUserData*> TargetUserIDData;                                  // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XboxUserPrivilegeCheckData">();
	}
	static class UXboxUserPrivilegeCheckData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXboxUserPrivilegeCheckData>();
	}
};
static_assert(alignof(UXboxUserPrivilegeCheckData) == 0x000008, "Wrong alignment on UXboxUserPrivilegeCheckData");
static_assert(sizeof(UXboxUserPrivilegeCheckData) == 0x000068, "Wrong size on UXboxUserPrivilegeCheckData");
static_assert(offsetof(UXboxUserPrivilegeCheckData, TargetUserIDData) == 0x000058, "Member 'UXboxUserPrivilegeCheckData::TargetUserIDData' has a wrong offset!");

// Class SCT.XboxUserPrivilegeManagerGIS
// 0x0058 (0x0088 - 0x0030)
class UXboxUserPrivilegeManagerGIS final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UXboxUserPrivilegeCheckData*            CurrentUserPrivilegeCheck;                         // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UXboxAnonymousUserPrivilegeCheckData*   CurrentAnonymousUserPrivilegeCheck;                // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UXboxUserPrivilegeCheckData*>    UserPrivilegeCheckQueue;                           // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UXboxAnonymousUserPrivilegeCheckData*> AnonymouseUserPrivilegeCheckQueue;                 // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x20];                                      // 0x0068(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearCache(bool bInClearUserCacheOnly);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"XboxUserPrivilegeManagerGIS">();
	}
	static class UXboxUserPrivilegeManagerGIS* GetDefaultObj()
	{
		return GetDefaultObjImpl<UXboxUserPrivilegeManagerGIS>();
	}
};
static_assert(alignof(UXboxUserPrivilegeManagerGIS) == 0x000008, "Wrong alignment on UXboxUserPrivilegeManagerGIS");
static_assert(sizeof(UXboxUserPrivilegeManagerGIS) == 0x000088, "Wrong size on UXboxUserPrivilegeManagerGIS");
static_assert(offsetof(UXboxUserPrivilegeManagerGIS, CurrentUserPrivilegeCheck) == 0x000038, "Member 'UXboxUserPrivilegeManagerGIS::CurrentUserPrivilegeCheck' has a wrong offset!");
static_assert(offsetof(UXboxUserPrivilegeManagerGIS, CurrentAnonymousUserPrivilegeCheck) == 0x000040, "Member 'UXboxUserPrivilegeManagerGIS::CurrentAnonymousUserPrivilegeCheck' has a wrong offset!");
static_assert(offsetof(UXboxUserPrivilegeManagerGIS, UserPrivilegeCheckQueue) == 0x000048, "Member 'UXboxUserPrivilegeManagerGIS::UserPrivilegeCheckQueue' has a wrong offset!");
static_assert(offsetof(UXboxUserPrivilegeManagerGIS, AnonymouseUserPrivilegeCheckQueue) == 0x000058, "Member 'UXboxUserPrivilegeManagerGIS::AnonymouseUserPrivilegeCheckQueue' has a wrong offset!");

// Class SCT.BlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy
// 0x0038 (0x0068 - 0x0030)
class UBlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnComplete;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x28];                                      // 0x0040(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UBlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy* CheckMultipleCommunicationPrivileges(class UObject* WorldContextObject, class APlayerController* InPlayerController, const TArray<class FString>& InXboxLiveUserIDs, bool bInForceUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy">();
	}
	static class UBlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy>();
	}
};
static_assert(alignof(UBlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy) == 0x000008, "Wrong alignment on UBlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy");
static_assert(sizeof(UBlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy) == 0x000068, "Wrong size on UBlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy");
static_assert(offsetof(UBlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy, OnComplete) == 0x000030, "Member 'UBlueprintXboxUserMultiplePrivilegeCheckerCallbackProxy::OnComplete' has a wrong offset!");

}

